<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="search" type="application/opensearchdescription+xml" title="ZIO" href="/opensearch.xml">
<link rel="stylesheet" href="/css/prism/prism-material-dark.css"><title data-react-helmet="true">Hub | ZIO</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://zio.dev/datatypes/concurrency/hub"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Hub | ZIO"><meta data-react-helmet="true" name="description" content="A Hub[A] is an asynchronous message hub. Publishers can publish messages of type A to the hub and subscribers can subscribe to receive messages of type A from the hub."><meta data-react-helmet="true" property="og:description" content="A Hub[A] is an asynchronous message hub. Publishers can publish messages of type A to the hub and subscribers can subscribe to receive messages of type A from the hub."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://zio.dev/datatypes/concurrency/hub"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/datatypes/concurrency/hub" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/datatypes/concurrency/hub" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.c1d60d2d.css">
<link rel="preload" href="/assets/js/runtime~main.9ec2f6f2.js" as="script">
<link rel="preload" href="/assets/js/main.aa9aa3fa.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/overview/overview_index">Overview</a><a class="navbar__item navbar__link" href="/datatypes/index">Data Types</a><a class="navbar__item navbar__link" href="/usecases/usecases_index">Use Cases</a><a class="navbar__item navbar__link" href="/howto/index">How to</a><a class="navbar__item navbar__link" href="/resources/index">Resources</a><a class="navbar__item navbar__link" href="/about/index">About</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/overview/overview_index">ZIO 2.x</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/datatypes/concurrency/hub">ZIO 2.x</a></li><li><a class="dropdown__link" href="/1.x/datatypes/concurrency/hub">ZIO 1.x</a></li></ul></div><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_1Doo"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Overview</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Core Data Types</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Contextual Types</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Concurrency</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">ZIO Fibers</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">Concurrency Primitives</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/datatypes/concurrency/index">Introduction</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Mutable References</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/datatypes/concurrency/promise">Promise</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/datatypes/concurrency/queue">Queue</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/datatypes/concurrency/hub">Hub</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/datatypes/concurrency/semaphore">Semaphore</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">STM</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Resource Safety</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Streaming</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Metrics</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Miscellaneous</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><span class="theme-doc-version-badge badge badge--secondary">Version: ZIO 2.x</span><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Hub</h1></header><p>A <code>Hub[A]</code> is an asynchronous message hub. Publishers can publish messages of type <code>A</code> to the hub and subscribers can subscribe to receive messages of type <code>A</code> from the hub.</p><p>Unlike a <code>Queue</code>, where each value offered to the queue can be taken by <em>one</em> taker, each value published to a hub can be received by <em>all</em> subscribers. Whereas a <code>Queue</code> represents the optimal solution to the problem of how to <em>distribute</em> values, a <code>Hub</code> represents the optimal solution to the problem of how to <em>broadcast</em> them.</p><p>The fundamental operators on a <code>Hub</code> are <code>publish</code> and <code>subscribe</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">import zio._</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">trait Hub[A] {</span></span><span class="token-line"><span class="token plain">  def publish(a: A): UIO[Boolean]</span></span><span class="token-line"><span class="token plain">  def subscribe: ZManaged[Any, Nothing, Dequeue[A]]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The <code>publish</code> operator returns a <code>ZIO</code> effect that publishes a message of type <code>A</code> to the hub and succeeds with a value describing whether the message was successfully published to the hub.</p><p>The <code>subscribe</code> operator returns a <code>ZManaged</code> effect where the <code>acquire</code> action of the <code>ZManaged</code> subscribes to the hub and the <code>release</code> action unsubscribes from the hub. Within the context of the <code>ZManaged</code> we have access to a <code>Dequeue</code>, which is a <code>Queue</code> that can only be dequeued from, that allows us to take messages published to the hub.</p><p>For example, we can use a hub to broadcast a message to multiple subscribers like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">Hub.bounded[String](2).flatMap { hub =&gt;</span></span><span class="token-line"><span class="token plain">  hub.subscribe.zip(hub.subscribe).use { case (left, right) =&gt;</span></span><span class="token-line"><span class="token plain">    for {</span></span><span class="token-line"><span class="token plain">      _ &lt;- hub.publish(&quot;Hello from a hub!&quot;)</span></span><span class="token-line"><span class="token plain">      _ &lt;- left.take.flatMap(Console.printLine(_))</span></span><span class="token-line"><span class="token plain">      _ &lt;- right.take.flatMap(Console.printLine(_))</span></span><span class="token-line"><span class="token plain">    } yield ()</span></span><span class="token-line"><span class="token plain">  }</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>A subscriber will only receive messages that are published to the hub while it is subscribed. So if we want to make sure that a particular message is received by a subscriber we must take care that the subscription has completed before publishing the message to the hub.</p><p>We can do this by publishing a message to the hub within the scope of the subscription as in the example above or by using other coordination mechanisms such as completing a <code>Promise</code>  when the <code>acquire</code> action of the <code>ZManaged</code> has completed.</p><p>Of course, in many cases such as subscribing to receive real time data we may not care about this because we are happy to just pick up with the most recent messages after we have subscribed. But for testing and simple applications this can be an important point to keep in mind.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="constructing-hubs"></a>Constructing Hubs<a class="hash-link" href="#constructing-hubs" title="Direct link to heading">#</a></h2><p>The most common way to create a hub is with the <code>bounded</code> constructor, which returns an effect that creates a new hub with the specified requested capacity.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def bounded[A](requestedCapacity: Int): UIO[Hub[A]] =</span></span><span class="token-line"><span class="token plain">  ???</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>For maximum efficiency you should create hubs with capacities that are powers of two.</p><p>Just like a bounded queue, a bounded hub applies back pressure to publishers when it is at capacity, so publishers will semantically block on calls to <code>publish</code> if the hub is full.</p><p>The advantage of the back pressure strategy is that it guarantees that all subscribers will receive all messages published to the hub while they are subscribed. However, it does create the risk that a slow subscriber will slow down the rate at which messages are published and received by other subscribers.</p><p>If you do not want this you can create a hub with the <code>dropping</code> constructor.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def dropping[A](requestedCapacity: Int): UIO[Hub[A]] =</span></span><span class="token-line"><span class="token plain">  ???</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>A dropping hub will simply drop values published to it if the hub is at capacity, returning <code>false</code> on calls to <code>publish</code> if the hub is full to signal that the value was not successfully published.</p><p>The advantage of the dropping strategy is that publishers can continue to publish new values so when there is space in the hub the newest values can be published to the hub. However, subscribers are no longer guaranteed to receive all values published to the hub and a slow subscriber can still prevent messages from being published to the hub and received by other subscribers.</p><p>You can also create a hub with the <code>sliding</code> constructor.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def sliding[A](requestedCapacity: Int): UIO[Hub[A]] =</span></span><span class="token-line"><span class="token plain">  ???</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>A sliding hub will drop the oldest value if a new value is published to it and the hub is at capacity, so publishing will always succeed immediately.</p><p>The advantage of the sliding strategy is that a slow subscriber cannot slow down that rate at which messages are published to the hub or received by other subscribers. However, it creates the risk that slow subscribers may not receive all messages published to the hub.</p><p>Finally, you can create a hub with the <code>unbounded</code> constructor.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def unbounded[A]: UIO[Hub[A]] =</span></span><span class="token-line"><span class="token plain">  ???</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>An unbounded hub is never at capacity so publishing to an unbounded hub always immediately succeeds.</p><p>The advantage of an unbounded hub is that it combines the guarantees that all subscribers will receive all messages published to the hub and that a slow subscriber will not slow down the rate at which messages are published and received by other subscribers. However, it does this at the cost of potentially growing without bound if messages are published to the hub more quickly than they are taken by the slowest subscriber.</p><p>In general you should prefer bounded, dropping, or sliding hubs for this reason. However, unbounded hubs can be useful in certain situations where you do not know exactly how many values will be published to the hub but are confident that it will not exceed a reasonable size or want to handle that concern at a higher level of your application.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="operators-on-hubs"></a>Operators On Hubs<a class="hash-link" href="#operators-on-hubs" title="Direct link to heading">#</a></h2><p>In addition to <code>publish</code> and <code>subscribe</code>, many of the same operators that are available on queues are available on hubs.</p><p>We can publish multiple values to the hub using the <code>publishAll</code> operator.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait Hub[A] {</span></span><span class="token-line"><span class="token plain">  def publishAll(as: Iterable[A]): UIO[Boolean]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We can check the capacity of the hub as well as the number of messages currently in the hub using the <code>size</code> and <code>capacity</code> operators.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait Hub[A] {</span></span><span class="token-line"><span class="token plain">  def capacity: Int</span></span><span class="token-line"><span class="token plain">  def size: UIO[Int]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Note that <code>capacity</code> returns an <code>Int</code> because the capacity is set at hub creation and never changes. In contrast, <code>size</code> returns a <code>ZIO</code> effect that determines the current size of the hub since the number of messages in the hub can change over time.</p><p>We can also shut down the hub, check whether it has been shut down, or await its shut down. Shutting down a hub will shut down all the queues associated with subscriptions to the hub, properly propagating the shut down signal.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait Hub[A] {</span></span><span class="token-line"><span class="token plain">  def awaitShutdown: UIO[Unit]</span></span><span class="token-line"><span class="token plain">  def isShutdown: UIO[Boolean]</span></span><span class="token-line"><span class="token plain">  def shutdown: UIO[Unit]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>As you can see, the operators on <code>Hub</code> are identical to the ones on <code>Queue</code> with the exception of <code>publish</code> and <code>subscribe</code> replacing <code>offer</code> and <code>take</code>. So if you know how to use a <code>Queue</code> you already know how to use a <code>Hub</code>.</p><p>In fact, a <code>Hub</code> can be viewed as a <code>Queue</code> that can only be written to.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait Hub[A] {</span></span><span class="token-line"><span class="token plain">  def toQueue[A]: Enqueue[A]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Here the <code>Enqueue</code> type represents a queue that can only be enqueued. Enqueing to the queue publishes a value to the hub, shutting down the queue shuts down the hub, and so on.</p><p>This can be extremely useful because it allows us to use a <code>Hub</code> anywhere we are currently using a <code>Queue</code> that we only write to.</p><p>For example, say we are using the <code>into</code> operator on <code>ZStream</code> to send all elements of a stream of financial transactions to a <code>Queue</code> for processing by a downstream consumer.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">import zio.stream._</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">trait ZStream[-R, +E, +O] {</span></span><span class="token-line"><span class="token plain">  def into[R1 &lt;: R, E1 &gt;: E](</span></span><span class="token-line"><span class="token plain">    queue: ZEnqueue[R1, Nothing, Take[E1, O]]</span></span><span class="token-line"><span class="token plain">  ): ZIO[R1, E1, Unit]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We would now like to have multiple downstream consumers process each of these transactions, for example to persist them and log them in addition to applying our business logic to them. With <code>Hub</code> this is easy because we can just use the <code>toQueue</code> operator to view any <code>Hub</code> as a <code>Queue</code> that can only be written to.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">type Transaction = ???</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val transactionStream: ZStream[Any, Nothing, Transaction] =</span></span><span class="token-line"><span class="token plain">  ???</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val hub: Hub[Transaction] =</span></span><span class="token-line"><span class="token plain">  ???</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">transactionStream.into(hub.toQueue)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>All of the elements from the transaction stream will now be published to the hub. We can now have multiple downstream consumers process elements from the financial transactions stream with the guarantee that all downstream consumers will see all transactions in the stream, changing the topology of our data flow from one-to-one to one-to-many with a single line change.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="polymorphic-hubs"></a>Polymorphic Hubs<a class="hash-link" href="#polymorphic-hubs" title="Direct link to heading">#</a></h2><p>Like many of the other data structures in ZIO, a <code>Hub</code> is actually a type alias for a more polymorphic data structure called a <code>ZHub</code>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait ZHub[-RA, -RB, +EA, +EB, -A, B] {</span></span><span class="token-line"><span class="token plain">  def publish(a: A): ZIO[RA, EA, Boolean]</span></span><span class="token-line"><span class="token plain">  def subscribe: ZManaged[Any, Nothing, ZDequeue[RB, EB, B]]</span></span><span class="token-line"><span class="token plain">}</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">type Hub[A] = ZHub[Any, Any, Nothing, Nothing, A, A]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>A <code>ZHub</code> allows publishers to publish messages of type <code>A</code> to the hub and subscribers to subscribe to receive messages of type <code>B</code> from the hub. Publishing messages to the hub can require an environment of type <code>RA</code> and fail with an error of type <code>EA</code> and taking messages from the hub can require an environment of type <code>RB</code> and fail with an error of type <code>EB</code>.</p><p>Defining hubs polymorphically like this allows us to describe hubs that potentially transform their inputs or outputs in some way.</p><p>To create a polymorphic hub we begin with a normal hub as described above and then add logic to it for transforming its inputs or outputs.</p><p>We can transform the type of messages received from the hub using the <code>map</code> and <code>mapZIO</code> operators.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait ZHub[-RA, -RB, +EA, +EB, -A, +B] {</span></span><span class="token-line"><span class="token plain">  def map[C](f: B =&gt; C): ZHub[RA, RB, EA, EB, A, C]</span></span><span class="token-line"><span class="token plain">  def mapZIO[RC &lt;: RB, EC &gt;: EB, C](f: B =&gt; ZIO[RC, EC, C]): ZHub[RA, RC, EA, EC, A, C]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The <code>map</code> operator allows us to transform the type of messages received from the hub with the specified function. Conceptually, every time a message is taken from the hub by a subscriber it will first be transformed with the function <code>f</code> before being received by the subscriber.</p><p>The <code>mapZIO</code> operator works the same way except it allows us to perform an effect each time a value is taken from the hub. We could use this for example to log each time a message is taken from the hub.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val hub: Hub[Int] = ???</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val hubWithLogging: ZHub[Any, Has[Clock] with Has[Console], Nothing, Nothing, Int, Int] =</span></span><span class="token-line"><span class="token plain">  hub.mapZIO { n =&gt;</span></span><span class="token-line"><span class="token plain">    Clock.currentDateTime.flatMap { currentDateTime =&gt;</span></span><span class="token-line"><span class="token plain">      Console.printLine(s&quot;Took message $n from the hub at $currentDateTime&quot;).orDie</span></span><span class="token-line"><span class="token plain">    }.as(n)</span></span><span class="token-line"><span class="token plain">  }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Note that the specified function in <code>map</code> or <code>mapZIO</code> will be applied each time a message is taken from the hub by a subscriber. Thus, if there are <code>n</code> subscribers to the hub the function will be evaluated <code>n</code> times for each message published to the hub.</p><p>This can be useful if we want to, for example, observe the different times that different subscribers are taking messages from the hub as in the example above. However, it is less efficient if we want to apply a transformation once for each value published to the hub.</p><p>For this we can use the <code>contramap</code> and <code>contramapZIO</code> operators defined on <code>ZHub</code>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait ZHub[-RA, -RB, +EA, +EB, -A, +B] {</span></span><span class="token-line"><span class="token plain">  def contramap[C](</span></span><span class="token-line"><span class="token plain">    f: C =&gt; A</span></span><span class="token-line"><span class="token plain">  ): ZHub[RA, RB, EA, EB, C, B]</span></span><span class="token-line"><span class="token plain">  def contramapZIO[RC &lt;: RA, EC &gt;: EA, C](</span></span><span class="token-line"><span class="token plain">    f: C =&gt; ZIO[RC, EC, A]</span></span><span class="token-line"><span class="token plain">  ): ZHub[RC, RB, EC, EB, C, B]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The <code>contramap</code> operator allows us to transform each value published to the hub by applying the specified function. Conceptually it returns a new hub where every time we publish a value we first transform it with the specified function before publishing it to the original hub.</p><p>The <code>contramapZIO</code> operator works the same way except it allows us to perform an effect each time a message is published to the hub.</p><p>Using these operators, we could describe a hub that validates its inputs, allowing publishers to publish raw data and subscribers to receive validated data while signaling to publishers when data they attempt to publish is not valid.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val hub: Hub[Int] = ???</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val hubWithLogging: ZHub[Any, Any, String, Nothing, String, Int] =</span></span><span class="token-line"><span class="token plain">  hub.contramapZIO { (s: String) =&gt;</span></span><span class="token-line"><span class="token plain">    ZIO.attempt(s.toInt).orElseFail(s&quot;$s is not a valid message&quot;)</span></span><span class="token-line"><span class="token plain">  }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We can also transform inputs and outputs at the same time using the <code>dimap</code> or <code>dimapZIO</code> operators.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait ZHub[-RA, -RB, +EA, +EB, -A, +B] {</span></span><span class="token-line"><span class="token plain">  def dimap[C, D](</span></span><span class="token-line"><span class="token plain">    f: C =&gt; A,</span></span><span class="token-line"><span class="token plain">    g: B =&gt; D</span></span><span class="token-line"><span class="token plain">  ): ZHub[RA, RB, EA, EB, C, D]</span></span><span class="token-line"><span class="token plain">  def dimapZIO[RC &lt;: RA, RD &lt;: RB, EC &gt;: EA, ED &gt;: EB, C, D](</span></span><span class="token-line"><span class="token plain">    f: C =&gt; ZIO[RC, EC, A],</span></span><span class="token-line"><span class="token plain">    g: B =&gt; ZIO[RD, ED, D]</span></span><span class="token-line"><span class="token plain">  ): ZHub[RC, RD, EC, ED, C, D]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>These correspond to transforming the inputs and outputs of a hub at the same time using the specified functions. This is the same as transforming the outputs with <code>map</code> or <code>mapZIO</code> and the inputs with <code>contramap</code> or <code>contramapZIO</code>.</p><p>In addition to just transforming the inputs and outputs of a hub we can also filter the inputs or outputs of a hub.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait ZHub[-RA, -RB, +EA, +EB, -A, +B] {</span></span><span class="token-line"><span class="token plain">  def filterInput[A1 &lt;: A](</span></span><span class="token-line"><span class="token plain">    f: A1 =&gt; Boolean</span></span><span class="token-line"><span class="token plain">  ): ZHub[RA, RB, EA, EB, A1, B]</span></span><span class="token-line"><span class="token plain">  def filterInputZIO[RA1 &lt;: RA, EA1 &gt;: EA, A1 &lt;: A](</span></span><span class="token-line"><span class="token plain">    f: A1 =&gt; ZIO[RA1, EA1, Boolean]</span></span><span class="token-line"><span class="token plain">  ): ZHub[RA1, RB, EA1, EB, A1, B]</span></span><span class="token-line"><span class="token plain">  def filterOutput(</span></span><span class="token-line"><span class="token plain">    f: B =&gt; Boolean</span></span><span class="token-line"><span class="token plain">  ): ZHub[RA, RB, EA, EB, A, B]</span></span><span class="token-line"><span class="token plain">  def filterOutputZIO[RB1 &lt;: RB, EB1 &gt;: EB](</span></span><span class="token-line"><span class="token plain">    f: B =&gt; ZIO[RB1, EB1, Boolean]</span></span><span class="token-line"><span class="token plain">  ): ZHub[RA, RB1, EA, EB1, A, B]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Filtering the inputs to a hub conceptually &quot;throws away&quot; messages that do not meet the filter predicate before they are published to the hub. The <code>publish</code> operator will return <code>false</code> to signal that such a message was not successfully published to the hub.</p><p>Similarly, filtering the outputs from a hub causes subscribers to ignore messages that do not meet the filter predicate, continuing to take messages from the hub until they find one that does meet the filter predicate.</p><p>We could, for example, create a hub that only handles tweets containing a particular term.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">final case class Tweet(text: String)</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val hub: Hub[Tweet] = ???</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val zioHub: Hub[Tweet] =</span></span><span class="token-line"><span class="token plain">  hub.filterInput(_.text.contains(&quot;zio&quot;))</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>In most cases the hubs we work with in practice will be monomorphic hubs and we will use the hub purely to broadcast values, performing any necessary effects before publishing values to the hub or after taking values from the hub. But it is nice to know that we have this kind of power if we need it.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="hubs-and-streams"></a>Hubs And Streams<a class="hash-link" href="#hubs-and-streams" title="Direct link to heading">#</a></h2><p>Hubs play extremely well with streams.</p><p>We can create a <code>ZStream</code> from a subscription to a hub using the <code>fromHub</code> operator.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">import zio.stream._</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">object ZStream {</span></span><span class="token-line"><span class="token plain">  def fromHub[R, E, O](hub: ZHub[Nothing, R, Any, E, Nothing, O]): ZStream[R, E, O] =</span></span><span class="token-line"><span class="token plain">    ???</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>This will return a stream that subscribes to receive values from a hub and then emits every value published to the hub while the subscription is active. When the stream ends the subscriber will automatically be unsubscribed from the hub.</p><p>There is also a <code>fromHubManaged</code> operator that returns the stream in the context of a managed effect.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">object ZStream {</span></span><span class="token-line"><span class="token plain">  def fromHubManaged[R, E, O](</span></span><span class="token-line"><span class="token plain">    hub: ZHub[Nothing, R, Any, E, Nothing, O]</span></span><span class="token-line"><span class="token plain">  ): ZManaged[Any, Nothing, ZStream[R, E, O]] =</span></span><span class="token-line"><span class="token plain">    ???</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The managed effect here describes subscribing to receive messages from the hub while the stream describes taking messages from the hub. This can be useful when we need to ensure that a consumer has subscribed before a producer begins publishing values.</p><p>Here is an example of using it:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">for {</span></span><span class="token-line"><span class="token plain">  promise &lt;- Promise.make[Nothing, Unit]</span></span><span class="token-line"><span class="token plain">  hub     &lt;- Hub.bounded[String](2)</span></span><span class="token-line"><span class="token plain">  managed  = ZStream.fromHubManaged(hub).tapZIO(_ =&gt; promise.succeed(()))</span></span><span class="token-line"><span class="token plain">  stream   = ZStream.unwrapManaged(managed)</span></span><span class="token-line"><span class="token plain">  fiber   &lt;- stream.take(2).runCollect.fork</span></span><span class="token-line"><span class="token plain">  _       &lt;- promise.await</span></span><span class="token-line"><span class="token plain">  _       &lt;- hub.publish(&quot;Hello&quot;)</span></span><span class="token-line"><span class="token plain">  _       &lt;- hub.publish(&quot;World&quot;)</span></span><span class="token-line"><span class="token plain">  _       &lt;- fiber.join</span></span><span class="token-line"><span class="token plain">} yield ()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Notice that in this case we used a <code>Promise</code> to ensure that the subscription had completed before publishing to the hub. The <code>ZManaged</code> in the return type of <code>fromHubManaged</code> made it easy for us to signal when the subscription had occurred by using <code>tapM</code> and completing the <code>Promise</code>.</p><p>Of course in many real applications we don&#x27;t need this kind of sequencing and just want to subscribe to receive new messages. In this case we can use the <code>fromHub</code> operator to return a <code>ZStream</code> that will automatically handle subscribing and unsubscribing for us.</p><p>There is also a <code>fromHubWithShutdown</code> variant that shuts down the hub itself when the stream ends. This is useful when the stream represents your main application logic and you want to shut down other subscriptions to the hub when the stream ends.</p><p>Each of these constructors also has <code>Chunk</code> variants, <code>fromChunkHub</code> and <code>fromChunkHubWithShutdown</code>, that allow you to preserve the chunked structure of data when working with hubs and streams.</p><p>In addition to being able to create streams from subscriptions to hubs, there are a variety of ways to send values emitted by streams to hubs to build more complex data flow graphs.</p><p>The simplest of these is the <code>toHub</code> operator, which constructs a new hub and publishes each element emitted by the stream to that hub.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait ZStream[-R, +E, +O] {</span></span><span class="token-line"><span class="token plain">  def toHub(</span></span><span class="token-line"><span class="token plain">    capacity: Int</span></span><span class="token-line"><span class="token plain">  ): ZManaged[R, Nothing, ZHub[Nothing, Any, Any, Nothing, Nothing, Take[E, O]]]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The hub will be constructed with the <code>bounded</code> constructor using the specified capacity.</p><p>If you want to send values emitted by a stream to an existing hub or a hub created using one of the other hub constructors you can use the <code>intoHub</code> operator.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait ZStream[-R, +E, +O] {</span></span><span class="token-line"><span class="token plain">  def intoHub[R1 &lt;: R, E1 &gt;: E](</span></span><span class="token-line"><span class="token plain">    hub: ZHub[R1, Nothing, Nothing, Any, Take[E1, O], Any]</span></span><span class="token-line"><span class="token plain">  ): ZIO[R1, E1, Unit]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>There is an <code>intoHubManaged</code> variant of this if you want to send values to the hub in the context of a <code>ZManaged</code> instead of a <code>ZIO</code> effect.</p><p>You can also create a sink that sends values to a hub.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">object ZSink {</span></span><span class="token-line"><span class="token plain">  def fromHub[R, E, I](</span></span><span class="token-line"><span class="token plain">    hub: ZHub[R, Nothing, E, Any, I, Any]</span></span><span class="token-line"><span class="token plain">  ): ZSink[R, E, I, Nothing, Unit] =</span></span><span class="token-line"><span class="token plain">    ???</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The sink will publish each value sent to the sink to the specified hub. Again there is a <code>fromHubWithShutdown</code> variant that will shut down the hub when the stream ends.</p><p>Finally, <code>ZHub</code> is used internally to provide a highly efficient implementation of the <code>broadcast</code> family of operators, including <code>broadcast</code> and <code>broadcastDynamic</code>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">trait ZStream[-R, +E, +O] {</span></span><span class="token-line"><span class="token plain">  def broadcast(</span></span><span class="token-line"><span class="token plain">    n: Int,</span></span><span class="token-line"><span class="token plain">    maximumLag: Int</span></span><span class="token-line"><span class="token plain">  ): ZManaged[R, Nothing, List[ZStream[Any, E, O]]]</span></span><span class="token-line"><span class="token plain">  def broadcastDynamic(</span></span><span class="token-line"><span class="token plain">    maximumLag: Int</span></span><span class="token-line"><span class="token plain">  ): ZManaged[R, Nothing, ZManaged[Any, Nothing, ZStream[Any, E, O]]]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The <code>broadcast</code> operator generates the specified number of new streams and broadcasts each value from the original stream to each of the new streams. The <code>broadcastDynamic</code> operator returns a new <code>ZManaged</code> value that you can use to dynamically subscribe and unsubscribe to receive values broadcast from the original stream.</p><p>You don&#x27;t have to do anything with <code>ZHub</code> to take advantage of these operators other than enjoy their optimized implementation in terms of <code>ZHub</code>.</p><p>With <code>broadcast</code> and other <code>ZStream</code> operators that model distributing values to different streams and combining values from different streams it is straightforward to build complex data flow graphs, all while being as performant as possible.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/datatypes/concurrency/queue"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Queue</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/datatypes/concurrency/semaphore"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Semaphore Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#constructing-hubs" class="table-of-contents__link">Constructing Hubs</a></li><li><a href="#operators-on-hubs" class="table-of-contents__link">Operators On Hubs</a></li><li><a href="#polymorphic-hubs" class="table-of-contents__link">Polymorphic Hubs</a></li><li><a href="#hubs-and-streams" class="table-of-contents__link">Hubs And Streams</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><ul class="footer__items"><li class="footer__item">
                <img src="/img/navbar_brand.png" alt="zio">
            </li></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items"><li class="footer__item">
              <a href="https://github.com/zio/zio">
                <img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github">
              </a>
            </li></ul></div><div class="col footer__col"><div class="footer__title">Chat with us on Discord</div><ul class="footer__items"><li class="footer__item">
                <a href="https://discord.gg/2ccFBr4">
                  <img src="https://img.shields.io/discord/629491597070827530?logo=discord&style=social" alt="discord">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Follow us on Twitter</div><ul class="footer__items"><li class="footer__item">
                <a href="https://twitter.com/zioscala">
                  <img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&style=social" alt="twitter">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Additional resources</div><ul class="footer__items"><li class="footer__item"><a href="/api/zio/" target="_blank">Latest Scaladoc of ZIO</a></li><li class="footer__item"><a href="/api-1.x/zio/" target="_blank">Scaladoc of ZIO-1.x</a></li><li class="footer__item"><a href="https://javadoc.io/doc/dev.zio/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scaladoc on javadoc.io<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><ul class="footer__items"><li class="footer__item">
                <a href="https://www.netlify.com">
                  <img src="https://www.netlify.com/img/global/badges/netlify-color-accent.svg" alt="Deploys by Netlify">
                </a>
              </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 ZIO Maintainers - Built with <a href="https://v2.docusaurus.io/">Docusaurus v2</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.9ec2f6f2.js"></script>
<script src="/assets/js/main.aa9aa3fa.js"></script>
</body>
</html>