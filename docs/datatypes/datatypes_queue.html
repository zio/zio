<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Queue · ZIO</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`Queue` is a lightweight in-memory queue built on ZIO with composable and transparent back-pressure. It is fully asynchronous (no locks or blocking), purely-functional and type-safe."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Queue · ZIO"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.dev/"/><meta property="og:description" content="`Queue` is a lightweight in-memory queue built on ZIO with composable and transparent back-pressure. It is fully asynchronous (no locks or blocking), purely-functional and type-safe."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/navbar_brand.png" alt="ZIO"/><h2 class="headerTitleWithLogo">ZIO</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/docs/datatypes/datatypes_index" target="_self">Data Types</a></li><li class=""><a href="/docs/interop/interop_index" target="_self">Interop</a></li><li class=""><a href="/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/docs/howto/howto_index" target="_self">How to</a></li><li class=""><a href="/docs/resources/resources" target="_self">Resources</a></li><li class=""><a href="/docs/ecosystem/ecosystem" target="_self">Ecosystem</a></li><li class=""><a href="/docs/about/about_index" target="_self">About</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Data Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Data Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_index">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_chunk">Chunk</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_fiber">Fiber</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_fiberref">FiberRef</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_has">Has</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_io">IO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_managed">Managed</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_promise">Promise</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/datatypes/datatypes_queue">Queue</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_ref">Ref</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_schedule">Schedule</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_semaphore">Semaphore</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_sink">Sink</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_stream">Stream</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_tarray">TArray</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_tmap">TMap</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_tpriorityqueue">TPriorityQueue</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_tpromise">TPromise</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_tqueue">TQueue</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_treentrantlock">TReentrantLock</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_tref">TRef</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_tsemaphore">TSemaphore</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_tset">TSet</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/datatypes_zlayer">ZLayer</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Queue</h1></header><article><div><span><p><code>Queue</code> is a lightweight in-memory queue built on ZIO with composable and transparent back-pressure. It is fully asynchronous (no locks or blocking), purely-functional and type-safe.</p>
<p>A <code>Queue[A]</code> contains values of type <code>A</code> and has two basic operations: <code>offer</code>, which places an <code>A</code> in the <code>Queue</code>, and <code>take</code> which removes and returns the oldest value in the <code>Queue</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._

<span class="hljs-keyword">val</span> res: <span class="hljs-type">UIO</span>[<span class="hljs-type">Int</span>] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
  _ &lt;- queue.offer(<span class="hljs-number">1</span>)
  v1 &lt;- queue.take
} <span class="hljs-keyword">yield</span> v1
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="creating-a-queue"></a><a href="#creating-a-queue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a queue</h2>
<p>A <code>Queue</code> can be bounded (with a limited capacity) or unbounded.</p>
<p>There are several strategies to process new values when the queue is full:</p>
<ul>
<li>The default <code>bounded</code> queue is back-pressured: when full, any offering fiber will be suspended until the queue is able to add the item;</li>
<li>A <code>dropping</code> queue will drop new items when the queue is full;</li>
<li>A <code>sliding</code> queue will drop old items when the queue is full.</li>
</ul>
<p>To create a back-pressured bounded queue:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> boundedQueue: <span class="hljs-type">UIO</span>[<span class="hljs-type">Queue</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
</code></pre>
<p>To create a dropping queue:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> droppingQueue: <span class="hljs-type">UIO</span>[<span class="hljs-type">Queue</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">Queue</span>.dropping[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
</code></pre>
<p>To create a sliding queue:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> slidingQueue: <span class="hljs-type">UIO</span>[<span class="hljs-type">Queue</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">Queue</span>.sliding[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
</code></pre>
<p>To create an unbounded queue:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> unboundedQueue: <span class="hljs-type">UIO</span>[<span class="hljs-type">Queue</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">Queue</span>.unbounded[<span class="hljs-type">Int</span>]
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="adding-items-to-a-queue"></a><a href="#adding-items-to-a-queue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding items to a queue</h2>
<p>The simplest way to add a value to the queue is <code>offer</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> res1: <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
  _ &lt;- queue.offer(<span class="hljs-number">1</span>)
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>When using a back-pressured queue, offer might suspend if the queue is full: you can use <code>fork</code> to wait in a different fiber.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> res2: <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">1</span>)
  _ &lt;- queue.offer(<span class="hljs-number">1</span>)
  f &lt;- queue.offer(<span class="hljs-number">1</span>).fork <span class="hljs-comment">// will be suspended because the queue is full</span>
  _ &lt;- queue.take
  _ &lt;- f.join
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>It is also possible to add multiple values at once with <code>offerAll</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> res3: <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
  items = <span class="hljs-type">Range</span>.inclusive(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).toList
  _ &lt;- queue.offerAll(items)
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="consuming-items-from-a-queue"></a><a href="#consuming-items-from-a-queue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consuming Items from a Queue</h2>
<p>The <code>take</code> operation removes the oldest item from the queue and returns it. If the queue is empty, this will suspend, and resume only when an item has been added to the queue. As with <code>offer</code>, you can use <code>fork</code> to wait for the value in a different fiber.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> oldestItem: <span class="hljs-type">UIO</span>[<span class="hljs-type">String</span>] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">String</span>](<span class="hljs-number">100</span>)
  f &lt;- queue.take.fork <span class="hljs-comment">// will be suspended because the queue is empty</span>
  _ &lt;- queue.offer(<span class="hljs-string">"something"</span>)
  v &lt;- f.join
} <span class="hljs-keyword">yield</span> v
</code></pre>
<p>You can consume the first item with <code>poll</code>. If the queue is empty you will get <code>None</code>, otherwise the top item will be returned wrapped in <code>Some</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> polled: <span class="hljs-type">UIO</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
  _ &lt;- queue.offer(<span class="hljs-number">10</span>)
  _ &lt;- queue.offer(<span class="hljs-number">20</span>)
  head &lt;- queue.poll
} <span class="hljs-keyword">yield</span> head
</code></pre>
<p>You can consume multiple items at once with <code>takeUpTo</code>. If the queue doesn't have enough items to return, it will return all the items without waiting for more offers.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> taken: <span class="hljs-type">UIO</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
  _ &lt;- queue.offer(<span class="hljs-number">10</span>)
  _ &lt;- queue.offer(<span class="hljs-number">20</span>)
  list  &lt;- queue.takeUpTo(<span class="hljs-number">5</span>)
} <span class="hljs-keyword">yield</span> list
</code></pre>
<p>Similarly, you can get all items at once with <code>takeAll</code>. It also returns without waiting (an empty list if the queue is empty).</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> all: <span class="hljs-type">UIO</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">100</span>)
  _ &lt;- queue.offer(<span class="hljs-number">10</span>)
  _ &lt;- queue.offer(<span class="hljs-number">20</span>)
  list  &lt;- queue.takeAll
} <span class="hljs-keyword">yield</span> list
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="shutting-down-a-queue"></a><a href="#shutting-down-a-queue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shutting Down a Queue</h2>
<p>It is possible with <code>shutdown</code> to interrupt all the fibers that are suspended on <code>offer*</code> or <code>take*</code>. It will also empty the queue and make all future calls to <code>offer*</code> and <code>take*</code> terminate immediately.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> takeFromShutdownQueue: <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)
  f &lt;- queue.take.fork
  _ &lt;- queue.shutdown <span class="hljs-comment">// will interrupt f</span>
  _ &lt;- f.join <span class="hljs-comment">// Will terminate</span>
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>You can use <code>awaitShutdown</code> to execute an effect when the queue is shut down. This will wait until the queue is shut down. If the queue is already shutdown, it will resume right away.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> awaitShutdown: <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
  queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)
  p &lt;- <span class="hljs-type">Promise</span>.make[<span class="hljs-type">Nothing</span>, <span class="hljs-type">Boolean</span>]
  f &lt;- queue.awaitShutdown.fork
  _ &lt;- queue.shutdown
  _ &lt;- f.join
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="transforming-queues"></a><a href="#transforming-queues" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transforming queues</h2>
<p>A <code>Queue[A]</code> is in fact a type alias for <code>ZQueue[Any, Any, Nothing, Nothing, A, A]</code>.
The signature for the expanded version is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ZQueue</span>[<span class="hljs-type">RA</span>, <span class="hljs-type">RB</span>, <span class="hljs-type">EA</span>, <span class="hljs-type">EB</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>]</span>
</code></pre>
<p>Which is to say:</p>
<ul>
<li>The queue may be offered values of type <code>A</code>. The enqueueing operations require an environment of type <code>RA</code> and may fail with errors of type <code>EA</code>;</li>
<li>The queue will yield values of type <code>B</code>. The dequeueing operations require an environment of type <code>RB</code> and may fail with errors of type <code>EB</code>.</li>
</ul>
<p>Note how the basic <code>Queue[A]</code> cannot fail or require any environment for any of its operations.</p>
<p>With separate type parameters for input and output, there are rich composition opportunities for queues:</p>
<h3><a class="anchor" aria-hidden="true" id="zqueuemap"></a><a href="#zqueuemap" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ZQueue#map</h3>
<p>The output of the queue may be mapped:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> mapped: <span class="hljs-type">UIO</span>[<span class="hljs-type">String</span>] = 
  <span class="hljs-keyword">for</span> {
    queue  &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)
    mapped = queue.map(_.toString)
    _      &lt;- mapped.offer(<span class="hljs-number">1</span>)
    s      &lt;- mapped.take
  } <span class="hljs-keyword">yield</span> s
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="zqueuemapm"></a><a href="#zqueuemapm" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ZQueue#mapM</h3>
<p>We may also use an effectful function to map the output. For example,
we could annotate each element with the timestamp at which it was dequeued:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.util.concurrent.<span class="hljs-type">TimeUnit</span>
<span class="hljs-keyword">import</span> zio.clock._

<span class="hljs-keyword">val</span> currentTimeMillis = currentTime(<span class="hljs-type">TimeUnit</span>.<span class="hljs-type">MILLISECONDS</span>)

<span class="hljs-keyword">val</span> annotatedOut: <span class="hljs-type">UIO</span>[<span class="hljs-type">ZQueue</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">Clock</span>, <span class="hljs-type">Nothing</span>, <span class="hljs-type">Nothing</span>, <span class="hljs-type">String</span>, (<span class="hljs-type">Long</span>, <span class="hljs-type">String</span>)]] =
  <span class="hljs-keyword">for</span> {
    queue &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">String</span>](<span class="hljs-number">3</span>)
    mapped = queue.mapM { el =&gt;
      currentTimeMillis.map((_, el))
    }
  } <span class="hljs-keyword">yield</span> mapped
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="zqueuecontramapm"></a><a href="#zqueuecontramapm" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ZQueue#contramapM</h3>
<p>Similarly to <code>mapM</code>, we can also apply an effectful function to
elements as they are enqueued. This queue will annotate the elements
with their enqueue timestamp:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> annotatedIn: <span class="hljs-type">UIO</span>[<span class="hljs-type">ZQueue</span>[<span class="hljs-type">Clock</span>, <span class="hljs-type">Any</span>, <span class="hljs-type">Nothing</span>, <span class="hljs-type">Nothing</span>, <span class="hljs-type">String</span>, (<span class="hljs-type">Long</span>, <span class="hljs-type">String</span>)]] =
  <span class="hljs-keyword">for</span> {
    queue &lt;- <span class="hljs-type">Queue</span>.bounded[(<span class="hljs-type">Long</span>, <span class="hljs-type">String</span>)](<span class="hljs-number">3</span>)
    mapped = queue.contramapM { el: <span class="hljs-type">String</span> =&gt;
      currentTimeMillis.map((_, el))
    }
  } <span class="hljs-keyword">yield</span> mapped
</code></pre>
<p>This queue has the same type as the previous one, but the timestamp is
attached to the elements when they are enqueued. This is reflected in
the type of the environment required by the queue for enqueueing.</p>
<p>To complete this example, we could combine this queue with <code>mapM</code> to
compute the time that the elements stayed in the queue:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.duration._

<span class="hljs-keyword">val</span> timeQueued: <span class="hljs-type">UIO</span>[<span class="hljs-type">ZQueue</span>[<span class="hljs-type">Clock</span>, <span class="hljs-type">Clock</span>, <span class="hljs-type">Nothing</span>, <span class="hljs-type">Nothing</span>, <span class="hljs-type">String</span>, (<span class="hljs-type">Duration</span>, <span class="hljs-type">String</span>)]] =
  <span class="hljs-keyword">for</span> {
    queue &lt;- <span class="hljs-type">Queue</span>.bounded[(<span class="hljs-type">Long</span>, <span class="hljs-type">String</span>)](<span class="hljs-number">3</span>)
    enqueueTimestamps = queue.contramapM { el: <span class="hljs-type">String</span> =&gt;
      currentTimeMillis.map((_, el))
    }
    durations = enqueueTimestamps.mapM { <span class="hljs-keyword">case</span> (enqueueTs, el) =&gt;
      currentTimeMillis
        .map(dequeueTs =&gt; ((dequeueTs - enqueueTs).millis, el))
    }
  } <span class="hljs-keyword">yield</span> durations
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="zqueuebothwith"></a><a href="#zqueuebothwith" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ZQueue#bothWith</h3>
<p>We may also compose two queues together into a single queue that
broadcasts offers and takes from both of the queues:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> fromComposedQueues: <span class="hljs-type">UIO</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>)] = 
  <span class="hljs-keyword">for</span> {
    q1       &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)
    q2       &lt;- <span class="hljs-type">Queue</span>.bounded[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>)
    q2Mapped =  q2.map(_.toString)
    both     =  q1.bothWith(q2Mapped)((_, _))
    _        &lt;- both.offer(<span class="hljs-number">1</span>)
    iAndS    &lt;- both.take
    (i, s)   =  iAndS
  } <span class="hljs-keyword">yield</span> (i, s)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="additional-resources"></a><a href="#additional-resources" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Additional Resources</h2>
<ul>
<li><a href="https://www.slideshare.net/jdegoes/zio-queue">ZIO Queue Talk by John De Goes @ ScalaWave 2018</a></li>
<li><a href="https://www.slideshare.net/wiemzin/psug-zio-queue">ZIO Queue Talk by Wiem Zine El Abidine @ PSUG 2018</a></li>
<li><a href="https://medium.com/@wiemzin/elevator-control-system-using-zio-c718ae423c58">Elevator Control System using ZIO</a></li>
<li><a href="https://blog.softwaremill.com/scalaz-8-io-vs-akka-typed-actors-vs-monix-part-1-5672657169e1">Scalaz 8 IO vs Akka (typed) actors vs Monix</a></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/datatypes/datatypes_promise"><span class="arrow-prev">← </span><span>Promise</span></a><a class="docs-next button" href="/docs/datatypes/datatypes_ref"><span>Ref</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#creating-a-queue">Creating a queue</a></li><li><a href="#adding-items-to-a-queue">Adding items to a queue</a></li><li><a href="#consuming-items-from-a-queue">Consuming Items from a Queue</a></li><li><a href="#shutting-down-a-queue">Shutting Down a Queue</a></li><li><a href="#transforming-queues">Transforming queues</a><ul class="toc-headings"><li><a href="#zqueuemap">ZQueue#map</a></li><li><a href="#zqueuemapm">ZQueue#mapM</a></li><li><a href="#zqueuecontramapm">ZQueue#contramapM</a></li><li><a href="#zqueuebothwith">ZQueue#bothWith</a></li></ul></li><li><a href="#additional-resources">Additional Resources</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/navbar_brand.png" alt="ZIO"/></a><div><h5>GitHub</h5><a href="https://github.com/zio/zio"><img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github"/></a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="https://img.shields.io/discord/629491597070827530?logo=discord&amp;style=social" alt="discord"/></a></div><div><h5>Follow us on Twitter</h5><a href="https://twitter.com/zioscala"><img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&amp;style=social" alt="twitter"/></a></div><div><h5>Additional resources</h5><a href="https://javadoc.io/doc/dev.zio/zio_2.12/">Scaladoc of zio</a></div><div><a href="https://www.netlify.com"><img src="https://www.netlify.com/img/global/badges/netlify-color-accent.svg" alt="Deploys by Netlify"/></a></div></section><section class="copyright">Copyright © 2021 ZIO Maintainers</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0c94b59071da7001757d08ab43d9e033',
                indexName: 'zio',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>