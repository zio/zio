<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>ZIO · ZIO</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A `ZIO[R, E, A]` value is an immutable value that lazily describes a workflow or job. The workflow requires some environment `R`, and may fail with an error of type `E`, or succeed with a value of type `A`."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="ZIO · ZIO"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.dev/"/><meta property="og:description" content="A `ZIO[R, E, A]` value is an immutable value that lazily describes a workflow or job. The workflow requires some environment `R`, and may fail with an error of type `E`, or succeed with a value of type `A`."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/navbar_brand.png" alt="ZIO"/><h2 class="headerTitleWithLogo">ZIO</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/docs/datatypes/" target="_self">Data Types</a></li><li class=""><a href="/docs/services/" target="_self">Services</a></li><li class=""><a href="/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/docs/howto/" target="_self">How to</a></li><li class=""><a href="/docs/resources/" target="_self">Resources</a></li><li class=""><a href="/docs/about/about_index" target="_self">About</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Core Data Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Overview<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Core Data Types<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/">Summary</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/datatypes/core/zio">ZIO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/uio">UIO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/urio">URIO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/task">Task</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/rio">RIO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/io">IO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/exit">Exit</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/cause">Cause</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/runtime">Runtime</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/zlayer">ZLayer</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Fiber Primitives<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/fiber">Fiber</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/fiberref">FiberRef</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/fiberid">Fiber.Id</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/fiberstatus">Fiber.Status</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Concurrency Primitives<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/hub">Hub</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/promise">Promise</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/semaphore">Semaphore</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/zref">ZRef</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/ref">Ref</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/zrefm">ZRefM</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/refm">RefM</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/queue">Queue</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">STM<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/stm">STM</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tarray">TArray</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tset">TSet</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tmap">TMap</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tref">TRef</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tpriorityqueue">TPriorityQueue</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tpromise">TPromise</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tqueue">TQueue</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/treentrantlock">TReentrantLock</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tsemaphore">TSemaphore</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Resource Safety<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/managed">Managed</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Streaming<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/stream">SubscriptionRef</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/sink">Sink</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Miscellaneous<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/chunk">Chunk</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/schedule">Schedule</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/has">Has</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/supervisor">Supervisor</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/zio/zio/edit/master/docs/datatypes/core/zio.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">ZIO</h1></header><article><div><span><p>A <code>ZIO[R, E, A]</code> value is an immutable value that lazily describes a workflow or job. The workflow requires some environment <code>R</code>, and may fail with an error of type <code>E</code>, or succeed with a value of type <code>A</code>.</p>
<p>A value of type <code>ZIO[R, E, A]</code> is like an effectful version of the following function type:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">R</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]
</code></pre>
<p>This function, which requires an <code>R</code>, might produce either an <code>E</code>, representing failure, or an <code>A</code>, representing success. ZIO effects are not actually functions, of course, because they model complex effects, like asynchronous and concurrent effects.</p>
<p>ZIO effects model resourceful interaction with the outside world, including synchronous, asynchronous, concurrent, and parallel interaction.</p>
<p>ZIO effects use a fiber-based concurrency model, with built-in support for
scheduling, fine-grained interruption, structured concurrency, and high scalability.</p>
<p>The <code>ZIO[R, E, A]</code> data type has three type parameters:</p>
<ul>
<li><strong><code>R</code> - Environment Type</strong>. The effect requires an environment of type <code>R</code>. If this type parameter is <code>Any</code>, it means the effect has no requirements, because we can run the effect with any value (for example, the unit value <code>()</code>).</li>
<li><strong><code>E</code> - Failure Type</strong>. The effect may fail with a value of type <code>E</code>. Some applications will use <code>Throwable</code>. If this type parameter is <code>Nothing</code>, it means the effect cannot fail, because there are no values of type <code>Nothing</code>.</li>
<li><strong><code>A</code> - Success Type</strong>. The effect may succeed with a value of type <code>A</code>. If this type parameter is <code>Unit</code>, it means the effect produces no useful information, while if it is <code>Nothing</code>, it means the effect runs forever (or until failure).</li>
</ul>
<p>In the following example, the <code>getStrLn</code> function requires the <code>Console</code> service, it may fail with value of type <code>IOException</code>, or may succeed with a value of type <code>String</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> getStrLn: <span class="hljs-type">ZIO</span>[<span class="hljs-type">Console</span>, <span class="hljs-type">IOException</span>, <span class="hljs-type">String</span>] =
  <span class="hljs-type">ZIO</span>.accessM(_.get.getStrLn)
</code></pre>
<p><code>ZIO</code> values are immutable, and all <code>ZIO</code> functions produce new <code>ZIO</code> values, enabling <code>ZIO</code> to be reasoned about and used like any ordinary Scala immutable data structure.</p>
<p><code>ZIO</code> values do not actually <em>do</em> anything; they are just values that <em>model</em> or <em>describe</em> effectful interactions.</p>
<p><code>ZIO</code> can be <em>interpreted</em> by the ZIO runtime system into effectful interactions with the external world. Ideally, this occurs at a single time, in our application's <code>main</code> function. The <code>App</code> class provides this functionality automatically.</p>
<h2><a class="anchor" aria-hidden="true" id="table-of-content"></a><a href="#table-of-content" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Table of Content</h2>
<ul>
<li><a href="#creation">Creation</a>
<ul>
<li><a href="#success-values">Success Values</a></li>
<li><a href="#failure-values">Failure Values</a></li>
<li><a href="#from-values">From Values</a>
<ul>
<li><a href="#option">Option</a></li>
<li><a href="#either">Either</a></li>
<li><a href="#try">Try</a></li>
<li><a href="#function">Function</a></li>
<li><a href="#future">Future</a></li>
<li><a href="#promise">Promise</a></li>
<li><a href="#fiber">Fiber</a></li>
</ul></li>
<li><a href="#from-side-effects">From Side-Effects</a>
<ul>
<li><a href="#synchronous">Synchronous</a>
<ul>
<li><a href="#blocking-synchronous-side-effects">Blocking Synchronous Side-Effects</a></li>
</ul></li>
<li><a href="#asynchronous">Asynchronous</a></li>
</ul></li>
<li><a href="#creating-suspended-effects">Creating Suspended Effects</a></li>
</ul></li>
<li><a href="#mapping">Mapping</a>
<ul>
<li><a href="#map">map</a></li>
<li><a href="#maperror">mapError</a></li>
<li><a href="#mapeffect">mapEffect</a></li>
</ul></li>
<li><a href="#zipping">Zipping</a>
<ul>
<li><a href="#zipleft-and-zipright">zipLeft and zipRight</a></li>
</ul></li>
<li><a href="#chaining">Chaining</a></li>
<li><a href="#parallelism">Parallelism</a>
<ul>
<li><a href="#racing">Racing</a></li>
</ul></li>
<li><a href="#timeout">Timeout</a></li>
<li><a href="#resource-management">Resource Management</a>
<ul>
<li><a href="#finalizing">Finalizing</a>
<ul>
<li><a href="#asynchronous-try---finally">Asynchronous Try / Finally</a></li>
<li><a href="#unstoppable-finalizers">Unstoppable Finalizers</a></li>
</ul></li>
<li><a href="#brackets">Brackets</a></li>
</ul></li>
<li><a href="#unswallowed-exceptions">Unswallowed Exceptions</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="creation"></a><a href="#creation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation</h2>
<p>In this section we explore some of the common ways to create ZIO effects from values, from common Scala types, and from both synchronous and asynchronous side-effects. Here is the summary list of them:</p>
<h3><a class="anchor" aria-hidden="true" id="success-values"></a><a href="#success-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Success Values</h3>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>succeed</code></td><td><code>A</code></td><td><code>UIO[A]</code></td></tr>
</tbody>
</table>
<p>Using the <code>ZIO.succeed</code> method, we can create an effect that succeeds with the specified value:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> s1 = <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-number">42</span>)
</code></pre>
<p>We can also use methods in the companion objects of the <code>ZIO</code> type aliases:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> s2: <span class="hljs-type">Task</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Task</span>.succeed(<span class="hljs-number">42</span>)
</code></pre>
<blockquote>
<p><em><strong>Note:</strong></em> <code>succeed</code> vs. <code>effectTotal</code></p>
<p>The <code>succeed</code> is nothing different than <code>effectTotal</code> they are the same but for different purposes for clarity. The <code>succeed</code> method takes a by-name parameter to make sure that any accidental side effects from constructing the value can be properly managed by the ZIO Runtime. However, <code>succeed</code> is intended for values which do not have any side effects. If we know that our value does have side effects, we should consider using <code>ZIO.effectTotal</code> for clarity.</p>
</blockquote>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> now = <span class="hljs-type">ZIO</span>.effectTotal(<span class="hljs-type">System</span>.currentTimeMillis())
</code></pre>
<p>The value inside a successful effect constructed with <code>ZIO.effectTotal</code> will only be constructed if absolutely required.</p>
<h3><a class="anchor" aria-hidden="true" id="failure-values"></a><a href="#failure-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Failure Values</h3>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fail</code></td><td><code>E</code></td><td><code>IO[E, Nothing]</code></td></tr>
</tbody>
</table>
<p>Using the <code>ZIO.fail</code> method, we can create an effect that models failure:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> f1 = <span class="hljs-type">ZIO</span>.fail(<span class="hljs-string">"Uh oh!"</span>)
</code></pre>
<p>For the <code>ZIO</code> data type, there is no restriction on the error type. We may use strings, exceptions, or custom data types appropriate for our application.</p>
<p>Many applications will model failures with classes that extend <code>Throwable</code> or <code>Exception</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> f2 = <span class="hljs-type">Task</span>.fail(<span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"Uh oh!"</span>))
</code></pre>
<p>Note that unlike the other effect companion objects, the <code>UIO</code> companion object does not have <code>UIO.fail</code>, because <code>UIO</code> values cannot fail.</p>
<h3><a class="anchor" aria-hidden="true" id="from-values"></a><a href="#from-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>From Values</h3>
<p>ZIO contains several constructors which help us to convert various data types into the <code>ZIO</code> effect.</p>
<h4><a class="anchor" aria-hidden="true" id="option"></a><a href="#option" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Option</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fromOption</code></td><td><code>Option[A]</code></td><td><code>IO[Option[Nothing], A]</code></td></tr>
<tr><td><code>some</code></td><td><code>A</code></td><td><code>UIO[Option[A]]</code></td></tr>
<tr><td><code>none</code></td><td></td><td><code>UIO[Option[Nothing]]</code></td></tr>
<tr><td><code>getOrFail</code></td><td><code>Option[A]</code></td><td><code>Task[A]</code></td></tr>
<tr><td><code>getOrFailUnit</code></td><td><code>Option[A]</code></td><td><code>IO[Unit, A]</code></td></tr>
<tr><td><code>getOrFailWith</code></td><td><code>e:=&gt; E, v:=&gt; Option[A]</code></td><td><code>IO[E, A]</code></td></tr>
</tbody>
</table>
<p>An <code>Option</code> can be converted into a ZIO effect using <code>ZIO.fromOption</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> zoption: <span class="hljs-type">IO</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Nothing</span>], <span class="hljs-type">Int</span>] = <span class="hljs-type">ZIO</span>.fromOption(<span class="hljs-type">Some</span>(<span class="hljs-number">2</span>))
</code></pre>
<p>The error type of the resulting effect is <code>Option[Nothing]</code>, which provides no information on why the value is not there. We can change the <code>Option[Nothing]</code> into a more specific error type using <code>ZIO#mapError</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> zoption2: <span class="hljs-type">IO</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = zoption.mapError(_ =&gt; <span class="hljs-string">"It wasn't there!"</span>)
</code></pre>
<p>We can also readily compose it with other operators while preserving the optional nature of the result (similar to an <code>OptionT</code>)</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> maybeId: <span class="hljs-type">IO</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Nothing</span>], <span class="hljs-type">String</span>] = <span class="hljs-type">ZIO</span>.fromOption(<span class="hljs-type">Some</span>(<span class="hljs-string">"abc123"</span>))
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getUser</span></span>(userId: <span class="hljs-type">String</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">Option</span>[<span class="hljs-type">User</span>]] = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTeam</span></span>(teamId: <span class="hljs-type">String</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">Team</span>] = ???


<span class="hljs-keyword">val</span> result: <span class="hljs-type">IO</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">Option</span>[(<span class="hljs-type">User</span>, <span class="hljs-type">Team</span>)]] = (<span class="hljs-keyword">for</span> {
  id   &lt;- maybeId
  user &lt;- getUser(id).some
  team &lt;- getTeam(user.teamId).asSomeError 
} <span class="hljs-keyword">yield</span> (user, team)).optional 
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="either"></a><a href="#either" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Either</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fromEither</code></td><td><code>Either[E, A]</code></td><td><code>IO[E, A]</code></td></tr>
<tr><td><code>left</code></td><td><code>A</code></td><td><code>UIO[Either[A, Nothing]]</code></td></tr>
<tr><td><code>right</code></td><td><code>A</code></td><td><code>UIO[Either[Nothing, B]]</code></td></tr>
</tbody>
</table>
<p>An <code>Either</code> can be converted into a ZIO effect using <code>ZIO.fromEither</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> zeither = <span class="hljs-type">ZIO</span>.fromEither(<span class="hljs-type">Right</span>(<span class="hljs-string">"Success!"</span>))
</code></pre>
<p>The error type of the resulting effect will be whatever type the <code>Left</code> case has, while the success type will be whatever type the <code>Right</code> case has.</p>
<h4><a class="anchor" aria-hidden="true" id="try"></a><a href="#try" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Try</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fromTry</code></td><td><code>scala.util.Try[A]</code></td><td><code>Task[A]</code></td></tr>
</tbody>
</table>
<p>A <code>Try</code> value can be converted into a ZIO effect using <code>ZIO.fromTry</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.util.<span class="hljs-type">Try</span>

<span class="hljs-keyword">val</span> ztry = <span class="hljs-type">ZIO</span>.fromTry(<span class="hljs-type">Try</span>(<span class="hljs-number">42</span> / <span class="hljs-number">0</span>))
</code></pre>
<p>The error type of the resulting effect will always be <code>Throwable</code>, because <code>Try</code> can only fail with values of type <code>Throwable</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="function"></a><a href="#function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Function</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fromFunction</code></td><td><code>R =&gt; A</code></td><td><code>URIO[R, A]</code></td></tr>
<tr><td><code>fromFunctionM</code></td><td><code>R =&gt; IO[E, A]</code></td><td><code>ZIO[R, E, A]</code></td></tr>
</tbody>
</table>
<p>A function <code>A =&gt; B</code> can be converted into a ZIO effect with <code>ZIO.fromFunction</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> zfun: <span class="hljs-type">URIO</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>] =
  <span class="hljs-type">ZIO</span>.fromFunction((i: <span class="hljs-type">Int</span>) =&gt; i * i)
</code></pre>
<p>The environment type of the effect is <code>A</code> (the input type of the function), because in order to run the effect, it must be supplied with a value of this type.</p>
<h4><a class="anchor" aria-hidden="true" id="future"></a><a href="#future" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Future</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fromFuture</code></td><td><code>ExecutionContext =&gt; scala.concurrent.Future[A]</code></td><td><code>Task[A]</code></td></tr>
<tr><td><code>fromFutureJava</code></td><td><code>java.util.concurrent.Future[A]</code></td><td><code>RIO[Blocking, A]</code></td></tr>
<tr><td><code>fromFunctionFuture</code></td><td><code>R =&gt; scala.concurrent.Future[A]</code></td><td><code>RIO[R, A]</code></td></tr>
<tr><td><code>fromFutureInterrupt</code></td><td><code>ExecutionContext =&gt; scala.concurrent.Future[A]</code></td><td><code>Task[A]</code></td></tr>
</tbody>
</table>
<p>A <code>Future</code> can be converted into a ZIO effect using <code>ZIO.fromFuture</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">Future</span>

<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> future = <span class="hljs-type">Future</span>.successful(<span class="hljs-string">"Hello!"</span>)

<span class="hljs-keyword">val</span> zfuture: <span class="hljs-type">Task</span>[<span class="hljs-type">String</span>] =
  <span class="hljs-type">ZIO</span>.fromFuture { <span class="hljs-keyword">implicit</span> ec =&gt;
    future.map(_ =&gt; <span class="hljs-string">"Goodbye!"</span>)
  }
</code></pre>
<p>The function passed to <code>fromFuture</code> is passed an <code>ExecutionContext</code>, which allows ZIO to manage where the <code>Future</code> runs (of course, we can ignore this <code>ExecutionContext</code>).</p>
<p>The error type of the resulting effect will always be <code>Throwable</code>, because <code>Future</code> can only fail with values of type <code>Throwable</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="promise"></a><a href="#promise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fromPromiseScala</code></td><td><code>scala.concurrent.Promise[A]</code></td><td><code>Task[A]</code></td></tr>
</tbody>
</table>
<p>A <code>Promise</code> can be converted into a ZIO effect using <code>ZIO.fromPromiseScala</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> func: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">String</span> = s =&gt; s.toUpperCase
<span class="hljs-keyword">for</span> {
  promise &lt;- <span class="hljs-type">ZIO</span>.succeed(scala.concurrent.<span class="hljs-type">Promise</span>[<span class="hljs-type">String</span>]())
  _ &lt;- <span class="hljs-type">ZIO</span>.effect {
    <span class="hljs-type">Try</span>(func(<span class="hljs-string">"hello world from future"</span>)) <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> <span class="hljs-type">Success</span>(value) =&gt; promise.success(value)
      <span class="hljs-keyword">case</span> <span class="hljs-type">Failure</span>(exception) =&gt; promise.failure(exception)
    }
  }.fork
  value &lt;- <span class="hljs-type">ZIO</span>.fromPromiseScala(promise)
  _ &lt;- putStrLn(<span class="hljs-string">s"Hello World in UpperCase: <span class="hljs-subst">$value</span>"</span>)
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="fiber"></a><a href="#fiber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fiber</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fromFiber</code></td><td><code>Fiber[E, A]</code></td><td><code>IO[E, A]</code></td></tr>
<tr><td><code>fromFiberM</code></td><td><code>IO[E, Fiber[E, A]]</code></td><td><code>IO[E, A]</code></td></tr>
</tbody>
</table>
<p>A <code>Fiber</code> can be converted into a ZIO effect using <code>ZIO.fromFiber</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> io: <span class="hljs-type">IO</span>[<span class="hljs-type">Nothing</span>, <span class="hljs-type">String</span>] = <span class="hljs-type">ZIO</span>.fromFiber(<span class="hljs-type">Fiber</span>.succeed(<span class="hljs-string">"Hello From Fiber!"</span>))
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="from-side-effects"></a><a href="#from-side-effects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>From Side-Effects</h3>
<p>ZIO can convert both synchronous and asynchronous side-effects into ZIO effects (pure values).</p>
<p>These functions can be used to wrap procedural code, allowing us to seamlessly use all features of ZIO with legacy Scala and Java code, as well as third-party libraries.</p>
<h4><a class="anchor" aria-hidden="true" id="synchronous"></a><a href="#synchronous" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Synchronous</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th><th>Note</th></tr>
</thead>
<tbody>
<tr><td><code>effectTotal</code></td><td><code>A</code></td><td><code>UIO[A]</code></td><td>Imports a total synchronous effect</td></tr>
<tr><td><code>effect</code></td><td><code>A</code></td><td>Task[A]</td><td>Imports a (partial) synchronous side-effect</td></tr>
</tbody>
</table>
<p>A synchronous side-effect can be converted into a ZIO effect using <code>ZIO.effect</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.io.<span class="hljs-type">StdIn</span>

<span class="hljs-keyword">val</span> getStrLine: <span class="hljs-type">Task</span>[<span class="hljs-type">String</span>] =
  <span class="hljs-type">ZIO</span>.effect(<span class="hljs-type">StdIn</span>.readLine())
</code></pre>
<p>The error type of the resulting effect will always be <code>Throwable</code>, because side-effects may throw exceptions with any value of type <code>Throwable</code>.</p>
<p>If a given side-effect is known to not throw any exceptions, then the side-effect can be converted into a ZIO effect using <code>ZIO.effectTotal</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">putStrLine</span></span>(line: <span class="hljs-type">String</span>): <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>] =
  <span class="hljs-type">ZIO</span>.effectTotal(println(line))

<span class="hljs-keyword">val</span> effectTotalTask: <span class="hljs-type">UIO</span>[<span class="hljs-type">Long</span>] =
  <span class="hljs-type">ZIO</span>.effectTotal(<span class="hljs-type">System</span>.nanoTime())
</code></pre>
<p>We should be careful when using <code>ZIO.effectTotal</code>—when in doubt about whether or not a side-effect is total, prefer <code>ZIO.effect</code> to convert the effect.</p>
<p>If this is too broad, the <code>refineOrDie</code> method of <code>ZIO</code> may be used to retain only certain types of exceptions, and to die on any other types of exceptions:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">IOException</span>

<span class="hljs-keyword">val</span> getStrLn2: <span class="hljs-type">IO</span>[<span class="hljs-type">IOException</span>, <span class="hljs-type">String</span>] =
  <span class="hljs-type">ZIO</span>.effect(<span class="hljs-type">StdIn</span>.readLine()).refineToOrDie[<span class="hljs-type">IOException</span>]
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="blocking-synchronous-side-effects"></a><a href="#blocking-synchronous-side-effects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blocking Synchronous Side-Effects</h5>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>blocking</code></td><td><code>ZIO[R, E, A]</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>effectBlocking</code></td><td><code>A</code></td><td><code>RIO[Blocking, A]</code></td></tr>
<tr><td><code>effectBlockingCancelable</code></td><td><code>effect: =&gt; A</code>, <code>cancel: UIO[Unit]</code></td><td><code>RIO[Blocking, A]</code></td></tr>
<tr><td><code>effectBlockingInterrupt</code></td><td><code>A</code></td><td><code>RIO[Blocking, A]</code></td></tr>
<tr><td><code>effectBlockingIO</code></td><td><code>A</code></td><td><code>ZIO[Blocking, IOException, A]</code></td></tr>
</tbody>
</table>
<p>Some side-effects use blocking IO or otherwise put a thread into a waiting state. If not carefully managed, these side-effects can deplete threads from our application's main thread pool, resulting in work starvation.</p>
<p>ZIO provides the <code>zio.blocking</code> package, which can be used to safely convert such blocking side-effects into ZIO effects.</p>
<p>A blocking side-effect can be converted directly into a ZIO effect blocking with the <code>effectBlocking</code> method:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.blocking._

<span class="hljs-keyword">val</span> sleeping =
  effectBlocking(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-type">Long</span>.<span class="hljs-type">MaxValue</span>))
</code></pre>
<p>The resulting effect will be executed on a separate thread pool designed specifically for blocking effects.</p>
<p>Blocking side-effects can be interrupted by invoking <code>Thread.interrupt</code> using the <code>effectBlockingInterrupt</code> method.</p>
<p>Some blocking side-effects can only be interrupted by invoking a cancellation effect. We can convert these side-effects using the <code>effectBlockingCancelable</code> method:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.net.<span class="hljs-type">ServerSocket</span>
<span class="hljs-keyword">import</span> zio.<span class="hljs-type">UIO</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">accept</span></span>(l: <span class="hljs-type">ServerSocket</span>) =
  effectBlockingCancelable(l.accept())(<span class="hljs-type">UIO</span>.effectTotal(l.close()))
</code></pre>
<p>If a side-effect has already been converted into a ZIO effect, then instead of <code>effectBlocking</code>, the <code>blocking</code> method can be used to ensure the effect will be executed on the blocking thread pool:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.io.{ <span class="hljs-type">Codec</span>, <span class="hljs-type">Source</span> }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span></span>(url: <span class="hljs-type">String</span>) =
  <span class="hljs-type">Task</span>.effect {
    <span class="hljs-type">Source</span>.fromURL(url)(<span class="hljs-type">Codec</span>.<span class="hljs-type">UTF8</span>).mkString
  }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">safeDownload</span></span>(url: <span class="hljs-type">String</span>) =
  blocking(download(url))
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="asynchronous"></a><a href="#asynchronous" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asynchronous</h4>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>effectAsync</code></td><td><code>(ZIO[R, E, A] =&gt; Unit) =&gt; Any</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>effectAsyncM</code></td><td><code>(ZIO[R, E, A] =&gt; Unit) =&gt; ZIO[R, E, Any]</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>effectAsyncMaybe</code></td><td><code>(ZIO[R, E, A] =&gt; Unit) =&gt; Option[ZIO[R, E, A]]</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>effectAsyncInterrupt</code></td><td><code>(ZIO[R, E, A] =&gt; Unit) =&gt; Either[Canceler[R], ZIO[R, E, A]]</code></td><td><code>ZIO[R, E, A]</code></td></tr>
</tbody>
</table>
<p>An asynchronous side-effect with a callback-based API can be converted into a ZIO effect using <code>ZIO.effectAsync</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">legacy</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span></span>(
    onSuccess: <span class="hljs-type">User</span> =&gt; <span class="hljs-type">Unit</span>,
    onFailure: <span class="hljs-type">AuthError</span> =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = ???
}

<span class="hljs-keyword">val</span> login: <span class="hljs-type">IO</span>[<span class="hljs-type">AuthError</span>, <span class="hljs-type">User</span>] =
  <span class="hljs-type">IO</span>.effectAsync[<span class="hljs-type">AuthError</span>, <span class="hljs-type">User</span>] { callback =&gt;
    legacy.login(
      user =&gt; callback(<span class="hljs-type">IO</span>.succeed(user)),
      err  =&gt; callback(<span class="hljs-type">IO</span>.fail(err))
    )
  }
</code></pre>
<p>Asynchronous ZIO effects are much easier to use than callback-based APIs, and they benefit from ZIO features like interruption, resource-safety, and superior error handling.</p>
<h3><a class="anchor" aria-hidden="true" id="creating-suspended-effects"></a><a href="#creating-suspended-effects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating Suspended Effects</h3>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>effectSuspend</code></td><td><code>RIO[R, A]</code></td><td><code>RIO[R, A]</code></td></tr>
<tr><td><code>effectSuspendTotal</code></td><td><code>ZIO[R, E, A]</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>effectSuspendTotalWith</code></td><td><code>(Platform, Fiber.Id) =&gt; ZIO[R, E, A]</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>effectSuspendWith</code></td><td><code>(Platform, Fiber.Id) =&gt; RIO[R, A]</code></td><td><code>RIO[R, A]</code></td></tr>
</tbody>
</table>
<p>A <code>RIO[R, A]</code> effect can be suspended using <code>effectSuspend</code> function:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> suspendedEffect: <span class="hljs-type">RIO</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">URIO</span>[<span class="hljs-type">Console</span>, <span class="hljs-type">Unit</span>]] =
  <span class="hljs-type">ZIO</span>.effectSuspend(<span class="hljs-type">ZIO</span>.effect(putStrLn(<span class="hljs-string">"Suspended Hello World!"</span>)))
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="mapping"></a><a href="#mapping" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mapping</h2>
<h3><a class="anchor" aria-hidden="true" id="map"></a><a href="#map" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>map</h3>
<p>We can change an <code>IO[E, A]</code> to an <code>IO[E, B]</code> by calling the <code>map</code> method with a function <code>A =&gt; B</code>. This lets us transform values produced by actions into other values.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.{ <span class="hljs-type">UIO</span>, <span class="hljs-type">IO</span> }

<span class="hljs-keyword">val</span> mappedValue: <span class="hljs-type">UIO</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">IO</span>.succeed(<span class="hljs-number">21</span>).map(_ * <span class="hljs-number">2</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="maperror"></a><a href="#maperror" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mapError</h3>
<p>We can transform an <code>IO[E, A]</code> into an <code>IO[E2, A]</code> by calling the <code>mapError</code> method with a function <code>E =&gt; E2</code>.  This lets us transform the failure values of effects:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> mappedError: <span class="hljs-type">IO</span>[<span class="hljs-type">Exception</span>, <span class="hljs-type">String</span>] = 
  <span class="hljs-type">IO</span>.fail(<span class="hljs-string">"No no!"</span>).mapError(msg =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(msg))
</code></pre>
<blockquote>
<p><em><strong>Note:</strong></em></p>
<p>Note that mapping over an effect's success or error channel does not change the success or failure of the effect, in the same way that mapping over an <code>Either</code> does not change whether the <code>Either</code> is <code>Left</code> or <code>Right</code>.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="mapeffect"></a><a href="#mapeffect" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mapEffect</h3>
<p><code>mapEffect</code> returns an effect whose success is mapped by the specified side-effecting <code>f</code> function, translating any thrown exceptions into typed failed effects.</p>
<p>Converting literal &quot;Five&quot; String to Int by calling <code>toInt</code> is a side effecting because it will throws <code>NumberFormatException</code> exception:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> task: <span class="hljs-type">RIO</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-string">"hello"</span>).mapEffect(_.toInt)
</code></pre>
<p><code>mapEffect</code> converts an unchecked exception to a checked one by returning the <code>RIO</code> effect.</p>
<h2><a class="anchor" aria-hidden="true" id="chaining"></a><a href="#chaining" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chaining</h2>
<p>We can execute two actions in sequence with the <code>flatMap</code> method. The second action may depend on the value produced by the first action.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> chainedActionsValue: <span class="hljs-type">UIO</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">IO</span>.succeed(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).flatMap { list =&gt;
  <span class="hljs-type">IO</span>.succeed(list.map(_ + <span class="hljs-number">1</span>))
}
</code></pre>
<p>If the first effect fails, the callback passed to <code>flatMap</code> will never be invoked, and the composed effect returned by <code>flatMap</code> will also fail.</p>
<p>In <em>any</em> chain of effects, the first failure will short-circuit the whole chain, just like throwing an exception will prematurely exit a sequence of statements.</p>
<p>Because the <code>ZIO</code> data type supports both <code>flatMap</code> and <code>map</code>, we can use Scala's <em>for comprehensions</em> to build sequential effects:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> program = 
  <span class="hljs-keyword">for</span> {
    _    &lt;- putStrLn(<span class="hljs-string">"Hello! What is your name?"</span>)
    name &lt;- getStrLn
    _    &lt;- putStrLn(<span class="hljs-string">s"Hello, <span class="hljs-subst">${name}</span>, welcome to ZIO!"</span>)
  } <span class="hljs-keyword">yield</span> ()
</code></pre>
<p><em>For comprehensions</em> provide a more procedural syntax for composing chains of effects.</p>
<h2><a class="anchor" aria-hidden="true" id="zipping"></a><a href="#zipping" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Zipping</h2>
<p>We can combine two effects into a single effect with the <code>zip</code> method. The resulting effect succeeds with a tuple that contains the success values of both effects:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> zipped: <span class="hljs-type">UIO</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = 
  <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-string">"4"</span>).zip(<span class="hljs-type">ZIO</span>.succeed(<span class="hljs-number">2</span>))
</code></pre>
<p>Note that <code>zip</code> operates sequentially: the effect on the left side is executed before the effect on the right side.</p>
<p>In any <code>zip</code> operation, if either the left or right-hand sides fail, then the composed effect will fail, because <em>both</em> values are required to construct the tuple.</p>
<h3><a class="anchor" aria-hidden="true" id="zipleft-and-zipright"></a><a href="#zipleft-and-zipright" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>zipLeft and zipRight</h3>
<p>Sometimes, when the success value of an effect is not useful (or example, it is <code>Unit</code>), it can be more convenient to use the <code>zipLeft</code> or <code>zipRight</code> functions, which first perform a <code>zip</code>, and then map over the tuple to discard one side or the other:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> zipRight1 = 
  putStrLn(<span class="hljs-string">"What is your name?"</span>).zipRight(getStrLn)
</code></pre>
<p>The <code>zipRight</code> and <code>zipLeft</code> functions have symbolic aliases, known as <code>*&gt;</code> and <code>&lt;*</code>, respectively. Some developers find these operators easier to read:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> zipRight2 = 
  putStrLn(<span class="hljs-string">"What is your name?"</span>) *&gt;
  getStrLn
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="parallelism"></a><a href="#parallelism" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parallelism</h2>
<p>ZIO provides many operations for performing effects in parallel. These methods are all named with a <code>Par</code> suffix that helps us identify opportunities to parallelize our code.</p>
<p>For example, the ordinary <code>ZIO#zip</code> method zips two effects together, sequentially. But there is also a <code>ZIO#zipPar</code> method, which zips two effects together in parallel.</p>
<p>The following table summarizes some of the sequential operations and their corresponding parallel versions:</p>
<table>
<thead>
<tr><th style="text-align:right"><strong>Description</strong></th><th style="text-align:center"><strong>Sequential</strong></th><th style="text-align:center"><strong>Parallel</strong></th></tr>
</thead>
<tbody>
<tr><td style="text-align:right">Zips two effects into one</td><td style="text-align:center"><code>ZIO#zip</code></td><td style="text-align:center"><code>ZIO#zipPar</code></td></tr>
<tr><td style="text-align:right">Zips two effects into one</td><td style="text-align:center"><code>ZIO#zipWith</code></td><td style="text-align:center"><code>ZIO#zipWithPar</code></td></tr>
<tr><td style="text-align:right">Collects from many effects</td><td style="text-align:center"><code>ZIO.collectAll</code></td><td style="text-align:center"><code>ZIO.collectAllPar</code></td></tr>
<tr><td style="text-align:right">Effectfully loop over values</td><td style="text-align:center"><code>ZIO.foreach</code></td><td style="text-align:center"><code>ZIO.foreachPar</code></td></tr>
<tr><td style="text-align:right">Reduces many values</td><td style="text-align:center"><code>ZIO.reduceAll</code></td><td style="text-align:center"><code>ZIO.reduceAllPar</code></td></tr>
<tr><td style="text-align:right">Merges many values</td><td style="text-align:center"><code>ZIO.mergeAll</code></td><td style="text-align:center"><code>ZIO.mergeAllPar</code></td></tr>
</tbody>
</table>
<p>For all the parallel operations, if one effect fails, then others will be interrupted, to minimize unnecessary computation.</p>
<p>If the fail-fast behavior is not desired, potentially failing effects can be first converted into infallible effects using the <code>ZIO#either</code> or <code>ZIO#option</code> methods.</p>
<h3><a class="anchor" aria-hidden="true" id="racing"></a><a href="#racing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Racing</h3>
<p>ZIO lets us race multiple effects in parallel, returning the first successful result:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  winner &lt;- <span class="hljs-type">IO</span>.succeed(<span class="hljs-string">"Hello"</span>).race(<span class="hljs-type">IO</span>.succeed(<span class="hljs-string">"Goodbye"</span>))
} <span class="hljs-keyword">yield</span> winner
</code></pre>
<p>If we want the first success or failure, rather than the first success, then we can use <code>left.either race right.either</code>, for any effects <code>left</code> and <code>right</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="timeout"></a><a href="#timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Timeout</h2>
<p>ZIO lets us timeout any effect using the <code>ZIO#timeout</code> method, which returns a new effect that succeeds with an <code>Option</code>. A value of <code>None</code> indicates the timeout elapsed before the effect completed.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.duration._

<span class="hljs-type">IO</span>.succeed(<span class="hljs-string">"Hello"</span>).timeout(<span class="hljs-number">10.</span>seconds)
</code></pre>
<p>If an effect times out, then instead of continuing to execute in the background, it will be interrupted so no resources will be wasted.</p>
<h2><a class="anchor" aria-hidden="true" id="error-management"></a><a href="#error-management" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Error Management</h2>
<h3><a class="anchor" aria-hidden="true" id="either-1"></a><a href="#either-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Either</h3>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>ZIO#either</code></td><td></td><td><code>URIO[R, Either[E, A]]</code></td></tr>
<tr><td><code>ZIO.absolve</code></td><td><code>ZIO[R, E, Either[E, A]]</code></td><td><code>ZIO[R, E, A]</code></td></tr>
</tbody>
</table>
<p>We can surface failures with <code>ZIO#either</code>, which takes an <code>ZIO[R, E, A]</code> and produces an <code>ZIO[R, Nothing, Either[E, A]]</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> zeither: <span class="hljs-type">UIO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]] = 
  <span class="hljs-type">IO</span>.fail(<span class="hljs-string">"Uh oh!"</span>).either
</code></pre>
<p>We can submerge failures with <code>ZIO.absolve</code>, which is the opposite of <code>either</code> and turns an <code>ZIO[R, Nothing, Either[E, A]]</code> into a <code>ZIO[R, E, A]</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sqrt</span></span>(io: <span class="hljs-type">UIO</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>] =
  <span class="hljs-type">ZIO</span>.absolve(
    io.map(value =&gt;
      <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0.0</span>) <span class="hljs-type">Left</span>(<span class="hljs-string">"Value must be &gt;= 0.0"</span>)
      <span class="hljs-keyword">else</span> <span class="hljs-type">Right</span>(<span class="hljs-type">Math</span>.sqrt(value))
    )
  )
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="catching"></a><a href="#catching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Catching</h3>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>ZIO#catchAll</code></td><td><code>E =&gt; ZIO[R1, E2, A1]</code></td><td><code>ZIO[R1, E2, A1]</code></td></tr>
<tr><td><code>ZIO#catchAllCause</code></td><td><code>Cause[E] =&gt; ZIO[R1, E2, A1]</code></td><td><code>ZIO[R1, E2, A1]</code></td></tr>
<tr><td><code>ZIO#catchAllDefect</code></td><td><code>Throwable =&gt; ZIO[R1, E1, A1]</code></td><td><code>ZIO[R1, E1, A1]</code></td></tr>
<tr><td><code>ZIO#catchAllTrace</code></td><td><code>((E, Option[ZTrace])) =&gt; ZIO[R1, E2, A1]</code></td><td><code>ZIO[R1, E2, A1]</code></td></tr>
<tr><td><code>ZIO#catchSome</code></td><td><code>PartialFunction[E, ZIO[R1, E1, A1]]</code></td><td><code>ZIO[R1, E1, A1]</code></td></tr>
<tr><td><code>ZIO#catchSomeCause</code></td><td><code>PartialFunction[Cause[E], ZIO[R1, E1, A1]]</code></td><td><code>ZIO[R1, E1, A1]</code></td></tr>
<tr><td><code>ZIO#catchSomeDefect</code></td><td><code>PartialFunction[Throwable, ZIO[R1, E1, A1]]</code></td><td><code>ZIO[R1, E1, A1]</code></td></tr>
<tr><td><code>ZIO#catchSomeTrace</code></td><td><code>PartialFunction[(E, Option[ZTrace]), ZIO[R1, E1, A1]]</code></td><td><code>ZIO[R1, E1, A1]</code></td></tr>
</tbody>
</table>
<h4><a class="anchor" aria-hidden="true" id="catching-all-errors"></a><a href="#catching-all-errors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Catching All Errors</h4>
<p>If we want to catch and recover from all types of errors and effectfully attempt recovery, we can use the <code>catchAll</code> method:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> z: <span class="hljs-type">IO</span>[<span class="hljs-type">IOException</span>, <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]] = 
  readFile(<span class="hljs-string">"primary.json"</span>).catchAll(_ =&gt; 
    readFile(<span class="hljs-string">"backup.json"</span>))
</code></pre>
<p>In the callback passed to <code>catchAll</code>, we may return an effect with a different error type (or perhaps <code>Nothing</code>), which will be reflected in the type of effect returned by <code>catchAll</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="catching-some-errors"></a><a href="#catching-some-errors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Catching Some Errors</h4>
<p>If we want to catch and recover from only some types of exceptions and effectfully attempt recovery, we can use the <code>catchSome</code> method:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> data: <span class="hljs-type">IO</span>[<span class="hljs-type">IOException</span>, <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]] = 
  readFile(<span class="hljs-string">"primary.data"</span>).catchSome {
    <span class="hljs-keyword">case</span> _ : <span class="hljs-type">FileNotFoundException</span> =&gt; 
      readFile(<span class="hljs-string">"backup.data"</span>)
  }
</code></pre>
<p>Unlike <code>catchAll</code>, <code>catchSome</code> cannot reduce or eliminate the error type, although it can widen the error type to a broader class of errors.</p>
<h3><a class="anchor" aria-hidden="true" id="fallback"></a><a href="#fallback" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fallback</h3>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>orElse</code></td><td><code>ZIO[R1, E2, A1]</code></td><td><code>ZIO[R1, E2, A1]</code></td></tr>
<tr><td><code>orElseEither</code></td><td><code>ZIO[R1, E2, B]</code></td><td><code>ZIO[R1, E2, Either[A, B]]</code></td></tr>
<tr><td><code>orElseFail</code></td><td><code>E1</code></td><td><code>ZIO[R, E1, A]</code></td></tr>
<tr><td><code>orElseOptional</code></td><td><code>ZIO[R1, Option[E1], A1]</code></td><td><code>ZIO[R1, Option[E1], A1]</code></td></tr>
<tr><td><code>orElseSucceed</code></td><td><code>A1</code></td><td><code>URIO[R, A1]</code></td></tr>
</tbody>
</table>
<p>We can try one effect, or, if it fails, try another effect, with the <code>orElse</code> combinator:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> primaryOrBackupData: <span class="hljs-type">IO</span>[<span class="hljs-type">IOException</span>, <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]] = 
  readFile(<span class="hljs-string">"primary.data"</span>).orElse(readFile(<span class="hljs-string">"backup.data"</span>))
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="folding"></a><a href="#folding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Folding</h3>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>fold</code></td><td><code>failure: E =&gt; B, success: A =&gt; B</code></td><td><code>URIO[R, B]</code></td></tr>
<tr><td><code>foldCause</code></td><td><code>failure: Cause[E] =&gt; B, success: A =&gt; B</code></td><td><code>URIO[R, B]</code></td></tr>
<tr><td><code>foldM</code></td><td><code>failure: E =&gt; ZIO[R1, E2, B], success: A =&gt; ZIO[R1, E2, B]</code></td><td><code>ZIO[R1, E2, B]</code></td></tr>
<tr><td><code>foldCauseM</code></td><td><code>failure: Cause[E] =&gt; ZIO[R1, E2, B], success: A =&gt; ZIO[R1, E2, B]</code></td><td><code>ZIO[R1, E2, B]</code></td></tr>
<tr><td><code>foldTraceM</code></td><td><code>failure: ((E, Option[ZTrace])) =&gt; ZIO[R1, E2, B], success: A =&gt; ZIO[R1, E2, B]</code></td><td><code>ZIO[R1, E2, B]</code></td></tr>
</tbody>
</table>
<p>Scala's <code>Option</code> and <code>Either</code> data types have <code>fold</code>, which let us handle both failure and success at the same time. In a similar fashion, <code>ZIO</code> effects also have several methods that allow us to handle both failure and success.</p>
<p>The first fold method, <code>fold</code>, lets us non-effectfully handle both failure and success, by supplying a non-effectful handler for each case:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> <span class="hljs-type">DefaultData</span>: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>] = <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)

<span class="hljs-keyword">val</span> primaryOrDefaultData: <span class="hljs-type">UIO</span>[<span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]] = 
  readFile(<span class="hljs-string">"primary.data"</span>).fold(
    _    =&gt; <span class="hljs-type">DefaultData</span>,
    data =&gt; data)
</code></pre>
<p>The second fold method, <code>foldM</code>, lets us effectfully handle both failure and success, by supplying an effectful (but still pure) handler for each case:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> primaryOrSecondaryData: <span class="hljs-type">IO</span>[<span class="hljs-type">IOException</span>, <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]] = 
  readFile(<span class="hljs-string">"primary.data"</span>).foldM(
    _    =&gt; readFile(<span class="hljs-string">"secondary.data"</span>),
    data =&gt; <span class="hljs-type">ZIO</span>.succeed(data))
</code></pre>
<p>Nearly all error handling methods are defined in terms of <code>foldM</code>, because it is both powerful and fast.</p>
<p>In the following example, <code>foldM</code> is used to handle both failure and success of the <code>readUrls</code> method:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> urls: <span class="hljs-type">UIO</span>[<span class="hljs-type">Content</span>] =
  readUrls(<span class="hljs-string">"urls.json"</span>).foldM(
    error   =&gt; <span class="hljs-type">IO</span>.succeed(<span class="hljs-type">NoContent</span>(error)), 
    success =&gt; fetchContent(success)
  )
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="retrying"></a><a href="#retrying" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Retrying</h3>
<table>
<thead>
<tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr>
</thead>
<tbody>
<tr><td><code>retry</code></td><td><code>Schedule[R1, E, S]</code></td><td><code>ZIO[R1 with Clock, E, A]</code></td></tr>
<tr><td><code>retryN</code></td><td><code>n: Int</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>retryOrElse</code></td><td><code>policy: Schedule[R1, E, S], orElse: (E, S) =&gt; ZIO[R1, E1, A1]</code></td><td><code>ZIO[R1 with Clock, E1, A1]</code></td></tr>
<tr><td><code>retryOrElseEither</code></td><td><code>schedule: Schedule[R1, E, Out], orElse: (E, Out) =&gt; ZIO[R1, E1, B]</code></td><td><code>ZIO[R1 with Clock, E1, Either[B, A]]</code></td></tr>
<tr><td><code>retryUntil</code></td><td><code>E =&gt; Boolean</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>retryUntilEquals</code></td><td><code>E1</code></td><td><code>ZIO[R, E1, A]</code></td></tr>
<tr><td><code>retryUntilM</code></td><td><code>E =&gt; URIO[R1, Boolean]</code></td><td><code>ZIO[R1, E, A]</code></td></tr>
<tr><td><code>retryWhile</code></td><td><code>E =&gt; Boolean</code></td><td><code>ZIO[R, E, A]</code></td></tr>
<tr><td><code>retryWhileEquals</code></td><td><code>E1</code></td><td><code>ZIO[R, E1, A]</code></td></tr>
<tr><td><code>retryWhileM</code></td><td><code>E =&gt; URIO[R1, Boolean]</code></td><td><code>ZIO[R1, E, A]</code></td></tr>
</tbody>
</table>
<p>When we are building applications we want to be resilient in the face of a transient failure. This is where we need to retry to overcome these failures.</p>
<p>There are a number of useful methods on the ZIO data type for retrying failed effects.</p>
<p>The most basic of these is <code>ZIO#retry</code>, which takes a <code>Schedule</code> and returns a new effect that will retry the first effect if it fails, according to the specified policy:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.clock._

<span class="hljs-keyword">val</span> retriedOpenFile: <span class="hljs-type">ZIO</span>[<span class="hljs-type">Clock</span>, <span class="hljs-type">IOException</span>, <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]] = 
  readFile(<span class="hljs-string">"primary.data"</span>).retry(<span class="hljs-type">Schedule</span>.recurs(<span class="hljs-number">5</span>))
</code></pre>
<p>The next most powerful function is <code>ZIO#retryOrElse</code>, which allows specification of a fallback to use, if the effect does not succeed with the specified policy:</p>
<pre><code class="hljs css language-scala">readFile(<span class="hljs-string">"primary.data"</span>).retryOrElse(
  <span class="hljs-type">Schedule</span>.recurs(<span class="hljs-number">5</span>), 
  (_, _:<span class="hljs-type">Long</span>) =&gt; <span class="hljs-type">ZIO</span>.succeed(<span class="hljs-type">DefaultData</span>)
)
</code></pre>
<p>The final method, <code>ZIO#retryOrElseEither</code>, allows returning a different type for the fallback.</p>
<h2><a class="anchor" aria-hidden="true" id="resource-management"></a><a href="#resource-management" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resource Management</h2>
<p>ZIO's resource management features work across synchronous, asynchronous, concurrent, and other effect types, and provide strong guarantees even in the presence of failure, interruption, or defects in the application.</p>
<h3><a class="anchor" aria-hidden="true" id="finalizing"></a><a href="#finalizing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Finalizing</h3>
<p>Scala has a <code>try</code> / <code>finally</code> construct which helps us to make sure we don't leak resources because no matter what happens in the try, the <code>finally</code> block will be executed. So we can open files in the try block, and then we can close them in the <code>finally</code> block, and that gives us the guarantee that we will not leak resources.</p>
<h4><a class="anchor" aria-hidden="true" id="asynchronous-try--finally"></a><a href="#asynchronous-try--finally" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asynchronous Try / Finally</h4>
<p>The problem with the <code>try</code> / <code>finally</code> construct is that it only applies with synchronous code, they don't work for asynchronous code. ZIO gives us a method called <code>ensuring</code> that works with either synchronous or asynchronous actions. So we have a functional try/finally but across the async region of our code, also our finalizer could have async regions.</p>
<p>Like <code>try</code> / <code>finally</code>, the <code>ensuring</code> operation guarantees that if an effect begins executing and then terminates (for whatever reason), then the finalizer will begin executing:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> finalizer = 
  <span class="hljs-type">UIO</span>.effectTotal(println(<span class="hljs-string">"Finalizing!"</span>))
<span class="hljs-comment">// finalizer: UIO[Unit] = zio.ZIO$EffectTotal@1f2b14ae</span>

<span class="hljs-keyword">val</span> finalized: <span class="hljs-type">IO</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Unit</span>] = 
  <span class="hljs-type">IO</span>.fail(<span class="hljs-string">"Failed!"</span>).ensuring(finalizer)
<span class="hljs-comment">// finalized: IO[String, Unit] = zio.ZIO$CheckInterrupt@99c49e9</span>
</code></pre>
<p>The finalizer is not allowed to fail, which means that it must handle any errors internally.</p>
<p>Like <code>try</code> / <code>finally</code>, finalizers can be nested, and the failure of any inner finalizer will not affect outer finalizers. Nested finalizers will be executed in reverse order, and linearly (not in parallel).</p>
<p>Unlike <code>try</code> / <code>finally</code>, <code>ensuring</code> works across all types of effects, including asynchronous and concurrent effects.</p>
<p>Here is another example of ensuring that our clean-up action called before our effect is done:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.<span class="hljs-type">Task</span>
<span class="hljs-keyword">var</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>
<span class="hljs-keyword">val</span> action: <span class="hljs-type">Task</span>[<span class="hljs-type">String</span>] =
  <span class="hljs-type">Task</span>.effectTotal(i += <span class="hljs-number">1</span>) *&gt;
    <span class="hljs-type">Task</span>.fail(<span class="hljs-keyword">new</span> <span class="hljs-type">Throwable</span>(<span class="hljs-string">"Boom!"</span>))
<span class="hljs-keyword">val</span> cleanupAction: <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">UIO</span>.effectTotal(i -= <span class="hljs-number">1</span>)
<span class="hljs-keyword">val</span> composite = action.ensuring(cleanupAction)
</code></pre>
<blockquote>
<p>_<strong>Note:</strong>
Finalizers offer very powerful guarantees, but they are low-level, and should generally not be used for releasing resources. For higher-level logic built on <code>ensuring</code>, see <code>ZIO#bracket</code> on the bracket section.</p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="unstoppable-finalizers"></a><a href="#unstoppable-finalizers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unstoppable Finalizers</h4>
<p>In Scala when we nest <code>try</code> / <code>finally</code> finalizers, they cannot be stopped. If we have nested finalizers and one of them fails for some sort of catastrophic reason the ones on the outside will still be run and in the correct order.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">try</span> {
      ...
    } <span class="hljs-keyword">finally</span> f1
  } <span class="hljs-keyword">finally</span> f2
} <span class="hljs-keyword">finally</span> f3
</code></pre>
<p>Also in ZIO like <code>try</code> / <code>finally</code>, the finalizers are unstoppable. This means if we have a buggy finalizer, and it is going to leak some resources that unfortunately happens, we will leak the minimum amount of resources because all other finalizers will be run in the correct order.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> io = ???
io.ensuring(f1)
 .ensuring(f2)
 .ensuring(f3)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="brackets"></a><a href="#brackets" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Brackets</h3>
<p>In Scala the <code>try</code> / <code>finally</code> is often used to manage resources. A common use for <code>try</code> / <code>finally</code> is safely acquiring and releasing resources, such as new socket connections or opened files:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> handle = openFile(name)

<span class="hljs-keyword">try</span> {
  processFile(handle)
} <span class="hljs-keyword">finally</span> closeFile(handle)
</code></pre>
<p>ZIO encapsulates this common pattern with <code>ZIO#bracket</code>, which allows us to specify an <em>acquire</em> effect, which acquires a resource; a <em>release</em> effect, which releases it; and a <em>use</em> effect, which uses the resource. Bracket lets us open a file and close the file and no matter what happens when we are using that resource.</p>
<p>The release action is guaranteed to be executed by the runtime system, even if the utilize action throws an exception or the executing fiber is interrupted.</p>
<p>Brackets are a built-in primitive that let us safely acquire and release resources. They are used for a similar purpose as <code>try/catch/finally</code>, only brackets work with synchronous and asynchronous actions, work seamlessly with fiber interruption, and are built on a different error model that ensures no errors are ever swallowed.</p>
<p>Brackets consist of an <em>acquire</em> action, a <em>utilize</em> action (which uses the acquired resource), and a <em>release</em> action.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.{ <span class="hljs-type">UIO</span>, <span class="hljs-type">IO</span> }
</code></pre>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> groupedFileData: <span class="hljs-type">IO</span>[<span class="hljs-type">IOException</span>, <span class="hljs-type">Unit</span>] = openFile(<span class="hljs-string">"data.json"</span>).bracket(closeFile(_)) { file =&gt;
  <span class="hljs-keyword">for</span> {
    data    &lt;- decodeData(file)
    grouped &lt;- groupData(data)
  } <span class="hljs-keyword">yield</span> grouped
}
</code></pre>
<p>Brackets have compositional semantics, so if a bracket is nested inside another bracket, and the outer bracket acquires a resource, then the outer bracket's release will always be called, even if, for example, the inner bracket's release fails.</p>
<p>Let's look at a full working example on using brackets:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.{ <span class="hljs-type">ExitCode</span>, <span class="hljs-type">Task</span>, <span class="hljs-type">UIO</span> }
<span class="hljs-keyword">import</span> java.io.{ <span class="hljs-type">File</span>, <span class="hljs-type">FileInputStream</span> }
<span class="hljs-keyword">import</span> java.nio.charset.<span class="hljs-type">StandardCharsets</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{

  <span class="hljs-comment">// run my bracket</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]) =
    mybracket.orDie.as(<span class="hljs-type">ExitCode</span>.success)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">closeStream</span></span>(is: <span class="hljs-type">FileInputStream</span>) =
    <span class="hljs-type">UIO</span>(is.close())

  <span class="hljs-comment">// helper method to work around in Java 8</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readAll</span></span>(fis: <span class="hljs-type">FileInputStream</span>, len: <span class="hljs-type">Long</span>): <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>] = {
    <span class="hljs-keyword">val</span> content: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>] = <span class="hljs-type">Array</span>.ofDim(len.toInt)
    fis.read(content)
    content
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convertBytes</span></span>(is: <span class="hljs-type">FileInputStream</span>, len: <span class="hljs-type">Long</span>) =
    <span class="hljs-type">Task</span>.effect(println(<span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(readAll(is, len), <span class="hljs-type">StandardCharsets</span>.<span class="hljs-type">UTF_8</span>))) <span class="hljs-comment">// Java 8</span>
  <span class="hljs-comment">//Task.effect(println(new String(is.readAllBytes(), StandardCharsets.UTF_8))) // Java 11+</span>

  <span class="hljs-comment">// mybracket is just a value. Won't execute anything here until interpreted</span>
  <span class="hljs-keyword">val</span> mybracket: <span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
    file   &lt;- <span class="hljs-type">Task</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">File</span>(<span class="hljs-string">"/tmp/hello"</span>))
    len    = file.length
    string &lt;- <span class="hljs-type">Task</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileInputStream</span>(file)).bracket(closeStream)(convertBytes(_, len))
  } <span class="hljs-keyword">yield</span> string
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="unswallowed-exceptions"></a><a href="#unswallowed-exceptions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unswallowed Exceptions</h2>
<p>The Java and Scala error models are broken. Because if we have the right combinations of <code>try</code>/<code>finally</code>/<code>catch</code>es we can actually throw many exceptions, and then we are only able to catch one of them. All the other ones are lost. They are swallowed into a black hole, and also the one that we catch is the wrong one. It is not the primary cause of the failure.</p>
<p>In the following example, we are going to show this behavior:</p>
<pre><code class="hljs css language-scala"> <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">try</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">"e1"</span>)
    <span class="hljs-keyword">finally</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">"e2"</span>)
 } <span class="hljs-keyword">catch</span> {
   <span class="hljs-keyword">case</span> e: <span class="hljs-type">Error</span> =&gt; println(e) 
 }
</code></pre>
<p>The above program just prints the <code>e2</code>, which is lossy and, also is not the primary cause of failure.</p>
<p>But in the ZIO version, all the errors will still be reported. So even though we are only able to catch one error, the other ones will be reported which we have full control over them. They don't get lost.</p>
<p>Let's write a ZIO version:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.fail(<span class="hljs-string">"e1"</span>)
  .ensuring(<span class="hljs-type">IO</span>.effectTotal(<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"e2"</span>)))
  .catchAll {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"e1"</span> =&gt; putStrLn(<span class="hljs-string">"e1"</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-string">"e2"</span> =&gt; putStrLn(<span class="hljs-string">"e2"</span>)
  }
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/datatypes/core/index"><span class="arrow-prev">← </span><span>Summary</span></a><a class="docs-next button" href="/docs/datatypes/core/uio"><span>UIO</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#table-of-content">Table of Content</a></li><li><a href="#creation">Creation</a><ul class="toc-headings"><li><a href="#success-values">Success Values</a></li><li><a href="#failure-values">Failure Values</a></li><li><a href="#from-values">From Values</a></li><li><a href="#from-side-effects">From Side-Effects</a></li><li><a href="#creating-suspended-effects">Creating Suspended Effects</a></li></ul></li><li><a href="#mapping">Mapping</a><ul class="toc-headings"><li><a href="#map">map</a></li><li><a href="#maperror">mapError</a></li><li><a href="#mapeffect">mapEffect</a></li></ul></li><li><a href="#chaining">Chaining</a></li><li><a href="#zipping">Zipping</a><ul class="toc-headings"><li><a href="#zipleft-and-zipright">zipLeft and zipRight</a></li></ul></li><li><a href="#parallelism">Parallelism</a><ul class="toc-headings"><li><a href="#racing">Racing</a></li></ul></li><li><a href="#timeout">Timeout</a></li><li><a href="#error-management">Error Management</a><ul class="toc-headings"><li><a href="#either-1">Either</a></li><li><a href="#catching">Catching</a></li><li><a href="#fallback">Fallback</a></li><li><a href="#folding">Folding</a></li><li><a href="#retrying">Retrying</a></li></ul></li><li><a href="#resource-management">Resource Management</a><ul class="toc-headings"><li><a href="#finalizing">Finalizing</a></li><li><a href="#brackets">Brackets</a></li></ul></li><li><a href="#unswallowed-exceptions">Unswallowed Exceptions</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/navbar_brand.png" alt="ZIO"/></a><div><h5>GitHub</h5><a href="https://github.com/zio/zio"><img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github"/></a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="https://img.shields.io/discord/629491597070827530?logo=discord&amp;style=social" alt="discord"/></a></div><div><h5>Follow us on Twitter</h5><a href="https://twitter.com/zioscala"><img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&amp;style=social" alt="twitter"/></a></div><div><h5>Additional resources</h5><a href="https://javadoc.io/doc/dev.zio/zio_2.12/">Scaladoc of zio</a></div><div><a href="https://www.netlify.com"><img src="https://www.netlify.com/img/global/badges/netlify-color-accent.svg" alt="Deploys by Netlify"/></a></div></section><section class="copyright">Copyright © 2021 ZIO Maintainers</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0c94b59071da7001757d08ab43d9e033',
                indexName: 'zio',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>