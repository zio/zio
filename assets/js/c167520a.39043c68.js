"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[71628],{95788:(e,n,a)=>{a.d(n,{Iu:()=>d,yg:()=>u});var t=a(11504);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=t.createContext({}),g=function(e){var n=t.useContext(p),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},d=function(e){var n=g(e.components);return t.createElement(p.Provider,{value:n},e.children)},y="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),y=g(a),m=r,u=y["".concat(p,".").concat(m)]||y[m]||s[m]||l;return a?t.createElement(u,i(i({ref:n},d),{},{components:a})):t.createElement(u,i({ref:n},d))}));function u(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=m;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[y]="string"==typeof e?e:r,i[1]=o;for(var g=2;g<l;g++)i[g]=a[g];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},96236:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>s,frontMatter:()=>l,metadata:()=>o,toc:()=>g});var t=a(45072),r=(a(11504),a(95788));const l={id:"zio",title:"ZIO"},i=void 0,o={unversionedId:"reference/core/zio/zio",id:"reference/core/zio/zio",title:"ZIO",description:"A ZIO[R, E, A] value is an immutable value that lazily describes a workflow or job. The workflow requires some environment R, and may fail with an error of type E, or succeed with a value of type A.",source:"@site/docs/reference/core/zio/zio.md",sourceDirName:"reference/core/zio",slug:"/reference/core/zio/",permalink:"/reference/core/zio/",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/core/zio/zio.md",tags:[],version:"current",frontMatter:{id:"zio",title:"ZIO"},sidebar:"reference-sidebar",previous:{title:"Introduction",permalink:"/reference/"},next:{title:"UIO",permalink:"/reference/core/zio/uio"}},p={},g=[{value:"Creation",id:"creation",level:2},{value:"Success Values",id:"success-values",level:3},{value:"Failure Values",id:"failure-values",level:3},{value:"From Values",id:"from-values",level:3},{value:"Option",id:"option",level:4},{value:"Either",id:"either",level:4},{value:"Try",id:"try",level:4},{value:"Future",id:"future",level:4},{value:"Promise",id:"promise",level:4},{value:"Fiber",id:"fiber",level:4},{value:"From Side-Effects",id:"from-side-effects",level:3},{value:"Synchronous",id:"synchronous",level:4},{value:"Blocking Synchronous Side-Effects",id:"blocking-synchronous-side-effects",level:5},{value:"Asynchronous",id:"asynchronous",level:4},{value:"Creating Suspended Effects",id:"creating-suspended-effects",level:3},{value:"Mapping",id:"mapping",level:2},{value:"map",id:"map",level:3},{value:"Tapping",id:"tapping",level:2},{value:"Chaining",id:"chaining",level:2},{value:"Zipping",id:"zipping",level:2},{value:"zipLeft and zipRight",id:"zipleft-and-zipright",level:3},{value:"Parallelism",id:"parallelism",level:2},{value:"Racing",id:"racing",level:3},{value:"Timeout",id:"timeout",level:2},{value:"Error Management",id:"error-management",level:2},{value:"Either",id:"either-1",level:3},{value:"Catching",id:"catching",level:3},{value:"Catching All Errors",id:"catching-all-errors",level:4},{value:"Catching Some Errors",id:"catching-some-errors",level:4},{value:"Fallback",id:"fallback",level:3},{value:"Folding",id:"folding",level:3},{value:"Retrying",id:"retrying",level:3},{value:"Resource Management",id:"resource-management",level:2},{value:"Finalizing",id:"finalizing",level:3},{value:"Asynchronous Try / Finally",id:"asynchronous-try--finally",level:4},{value:"Unstoppable Finalizers",id:"unstoppable-finalizers",level:4},{value:"Acquire Release",id:"acquire-release",level:3},{value:"ZIO Aspect",id:"zio-aspect",level:2}],d={toc:g},y="wrapper";function s(e){let{components:n,...a}=e;return(0,r.yg)(y,(0,t.c)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"A ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, A]")," value is an immutable value that lazily describes a workflow or job. The workflow requires some environment ",(0,r.yg)("inlineCode",{parentName:"p"},"R"),", and may fail with an error of type ",(0,r.yg)("inlineCode",{parentName:"p"},"E"),", or succeed with a value of type ",(0,r.yg)("inlineCode",{parentName:"p"},"A"),"."),(0,r.yg)("p",null,"A value of type ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, A]")," is like an effectful version of the following function type:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"R => Either[E, A]\n")),(0,r.yg)("p",null,"This function, which requires an ",(0,r.yg)("inlineCode",{parentName:"p"},"R"),", might produce either an ",(0,r.yg)("inlineCode",{parentName:"p"},"E"),", representing failure, or an ",(0,r.yg)("inlineCode",{parentName:"p"},"A"),", representing success. ZIO effects are not actually functions, of course, they can model synchronous, asynchronous, concurrent, parallel, and resourceful computations."),(0,r.yg)("p",null,"ZIO effects use a fiber-based concurrency model, with built-in support for\nscheduling, fine-grained interruption, structured concurrency, and high scalability."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, A]")," data type has three type parameters:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"R")," - Environment Type"),". The effect requires an environment of type ",(0,r.yg)("inlineCode",{parentName:"li"},"R"),". If this type parameter is ",(0,r.yg)("inlineCode",{parentName:"li"},"Any"),", it means the effect has no requirements, because we can run the effect with any value (for example, the unit value ",(0,r.yg)("inlineCode",{parentName:"li"},"()"),")."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"E")," - Failure Type"),". The effect may fail with a value of type ",(0,r.yg)("inlineCode",{parentName:"li"},"E"),". Some applications will use ",(0,r.yg)("inlineCode",{parentName:"li"},"Throwable"),". If this type parameter is ",(0,r.yg)("inlineCode",{parentName:"li"},"Nothing"),", it means the effect cannot fail, because there are no values of type ",(0,r.yg)("inlineCode",{parentName:"li"},"Nothing"),"."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"A")," - Success Type"),". The effect may succeed with a value of type ",(0,r.yg)("inlineCode",{parentName:"li"},"A"),". If this type parameter is ",(0,r.yg)("inlineCode",{parentName:"li"},"Unit"),", it means the effect produces no useful information, while if it is ",(0,r.yg)("inlineCode",{parentName:"li"},"Nothing"),", it means the effect runs forever (or until failure).")),(0,r.yg)("p",null,"In the following example, the ",(0,r.yg)("inlineCode",{parentName:"p"},"readLine")," function does not require any services, it may fail with value of type ",(0,r.yg)("inlineCode",{parentName:"p"},"IOException"),", or may succeed with a value of type ",(0,r.yg)("inlineCode",{parentName:"p"},"String"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport java.io.IOException\n\nval readLine: ZIO[Any, IOException, String] =\n  Console.readLine\n")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," values are immutable, and all ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," functions produce new ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," values, enabling ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," to be reasoned about and used like any ordinary Scala immutable data structure."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," values do not actually ",(0,r.yg)("em",{parentName:"p"},"do")," anything; they are just values that ",(0,r.yg)("em",{parentName:"p"},"model")," or ",(0,r.yg)("em",{parentName:"p"},"describe")," effectful interactions."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," can be ",(0,r.yg)("em",{parentName:"p"},"interpreted")," by the ZIO runtime system into effectful interactions with the external world. Ideally, this occurs at a single time, in our application's ",(0,r.yg)("inlineCode",{parentName:"p"},"main")," function. The ",(0,r.yg)("inlineCode",{parentName:"p"},"App")," class provides this functionality automatically."),(0,r.yg)("h2",{id:"creation"},"Creation"),(0,r.yg)("p",null,"In this section we explore some of the common ways to create ZIO effects from values, from common Scala types, and from both synchronous and asynchronous side-effects. Here is the summary list of them:"),(0,r.yg)("h3",{id:"success-values"},"Success Values"),(0,r.yg)("p",null,"Using the ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.succeed")," method, we can create an effect that succeeds with the specified value:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval s1 = ZIO.succeed(42)\n")),(0,r.yg)("h3",{id:"failure-values"},"Failure Values"),(0,r.yg)("p",null,"Using the ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.fail")," method, we can create an effect that models failure:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval f1 = ZIO.fail("Uh oh!")\n')),(0,r.yg)("p",null,"For the ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," data type, there is no restriction on the error type. We may use strings, exceptions, or custom data types appropriate for our application."),(0,r.yg)("p",null,"Many applications will model failures with classes that extend ",(0,r.yg)("inlineCode",{parentName:"p"},"Throwable")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"Exception"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval f2 = ZIO.fail(new Exception("Uh oh!"))\n')),(0,r.yg)("h3",{id:"from-values"},"From Values"),(0,r.yg)("p",null,"ZIO contains several constructors which help us to convert various data types into ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effects."),(0,r.yg)("h4",{id:"option"},"Option"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"ZIO.fromOption")),"\u2014 An ",(0,r.yg)("inlineCode",{parentName:"li"},"Option")," can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"li"},"ZIO.fromOption"),":")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval zoption: IO[Option[Nothing], Int] = ZIO.fromOption(Some(2))\n")),(0,r.yg)("p",null,"The error type of the resulting effect is ",(0,r.yg)("inlineCode",{parentName:"p"},"Option[Nothing]"),", which provides no information on why the value is not there. We can change the ",(0,r.yg)("inlineCode",{parentName:"p"},"Option[Nothing]")," into a more specific error type using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#mapError"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval zoption2: IO[String, Int] = zoption.mapError(_ => "It wasn\'t there!")\n')),(0,r.yg)("p",null,"We can also readily compose it with other operators while preserving the optional nature of the result (similar to an ",(0,r.yg)("inlineCode",{parentName:"p"},"OptionT"),"):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval maybeId: IO[Option[Nothing], String] = ZIO.fromOption(Some("abc123"))\ndef getUser(userId: String): IO[Throwable, Option[User]] = ???\ndef getTeam(teamId: String): IO[Throwable, Team] = ???\n\n\nval result: IO[Throwable, Option[(User, Team)]] = (for {\n  id   <- maybeId\n  user <- getUser(id).some\n  team <- getTeam(user.teamId).asSomeError\n} yield (user, team)).unsome\n')),(0,r.yg)("ol",{start:2},(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"ZIO.some")),"/",(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"ZIO.none")),"\u2014 These constructors can be used to directly create ZIO of optional values:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval someInt: ZIO[Any, Nothing, Option[Int]]     = ZIO.some(3)\nval noneInt: ZIO[Any, Nothing, Option[Nothing]] = ZIO.none\n")),(0,r.yg)("ol",{start:3},(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"ZIO.getOrFail")),"\u2014 We can lift an ",(0,r.yg)("inlineCode",{parentName:"li"},"Option")," into a ",(0,r.yg)("inlineCode",{parentName:"li"},"ZIO")," and if the option is not defined we can fail the ZIO with the proper error type:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ZIO.getOrFail")," fails with ",(0,r.yg)("inlineCode",{parentName:"li"},"Throwable")," error type."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ZIO.getOrFailUnit")," fails with ",(0,r.yg)("inlineCode",{parentName:"li"},"Unit")," error type."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ZIO.getOrFailWith")," fails with custom error type.")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef parseInt(input: String): Option[Int] = input.toIntOption\n\n// If the optional value is not defined it fails with Throwable error type:\nval r1: ZIO[Any, Throwable, Int] =\n  ZIO.getOrFail(parseInt("1.2"))\n\n// If the optional value is not defined it fails with Unit error type:\nval r2: ZIO[Any, Unit, Int] =\n  ZIO.getOrFailUnit(parseInt("1.2"))\n\n// If the optional value is not defined it fail with given error type:\nval r3: ZIO[Any, NumberFormatException, Int] =\n  ZIO.getOrFailWith(new NumberFormatException("invalid input"))(parseInt("1.2"))\n')),(0,r.yg)("ol",{start:4},(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"ZIO.nonOrFail")),"\u2014 It lifts an option into a ZIO value. If the option is empty it succeeds with ",(0,r.yg)("inlineCode",{parentName:"li"},"Unit")," and if the option is defined it fails with a proper error type:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ZIO.noneOrFail")," fails with the content of the optional value."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ZIO.noneOrFailUnit")," fails with the ",(0,r.yg)("inlineCode",{parentName:"li"},"Unit")," error type."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ZIO.noneOrFailWith")," fails with custom error type.")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval optionalValue: Option[String] = ???\n\n// If the optional value is empty it succeeds with Unit\n// If the optional value is defined it will fail with the content of the optional value\nval r1: ZIO[Any, String, Unit] =\n  ZIO.noneOrFail(optionalValue)\n\n// If the optional value is empty it succeeds with Unit\n// If the optional value is defined, it will fail by applying the error function to it:\nval r2: ZIO[Any, NumberFormatException, Unit] =\n  ZIO.noneOrFailWith(optionalValue)(e => new NumberFormatException(e))\n")),(0,r.yg)("h4",{id:"either"},"Either"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromEither")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Either[E, A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"IO[E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"left")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"A")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"UIO[Either[A, Nothing]]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"right")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"A")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"UIO[Either[Nothing, A]]"))))),(0,r.yg)("p",null,"An ",(0,r.yg)("inlineCode",{parentName:"p"},"Either")," can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.fromEither"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval zeither = ZIO.fromEither(Right("Success!"))\n')),(0,r.yg)("p",null,"The error type of the resulting effect will be whatever type the ",(0,r.yg)("inlineCode",{parentName:"p"},"Left")," case has, while the success type will be whatever type the ",(0,r.yg)("inlineCode",{parentName:"p"},"Right")," case has."),(0,r.yg)("h4",{id:"try"},"Try"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromTry")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"scala.util.Try[A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task[A]"))))),(0,r.yg)("p",null,"A ",(0,r.yg)("inlineCode",{parentName:"p"},"Try")," value can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.fromTry"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport scala.util.Try\n\nval ztry = ZIO.fromTry(Try(42 / 0))\n")),(0,r.yg)("p",null,"The error type of the resulting effect will always be ",(0,r.yg)("inlineCode",{parentName:"p"},"Throwable"),", because ",(0,r.yg)("inlineCode",{parentName:"p"},"Try")," can only fail with values of type ",(0,r.yg)("inlineCode",{parentName:"p"},"Throwable"),"."),(0,r.yg)("h4",{id:"future"},"Future"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromFuture")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ExecutionContext => scala.concurrent.Future[A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task[A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromFutureJava")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"java.util.concurrent.Future[A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"RIO[Blocking, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromFunctionFuture")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"R => scala.concurrent.Future[A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"RIO[R, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromFutureInterrupt")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ExecutionContext => scala.concurrent.Future[A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task[A]"))))),(0,r.yg)("p",null,"A ",(0,r.yg)("inlineCode",{parentName:"p"},"Future")," can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.fromFuture"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport scala.concurrent.Future\n\nlazy val future = Future.successful("Hello!")\n\nval zfuture: Task[String] =\n  ZIO.fromFuture { implicit ec =>\n    future.map(_ => "Goodbye!")\n  }\n')),(0,r.yg)("p",null,"The function passed to ",(0,r.yg)("inlineCode",{parentName:"p"},"fromFuture")," is passed an ",(0,r.yg)("inlineCode",{parentName:"p"},"ExecutionContext"),", which allows ZIO to manage where the ",(0,r.yg)("inlineCode",{parentName:"p"},"Future")," runs (of course, we can ignore this ",(0,r.yg)("inlineCode",{parentName:"p"},"ExecutionContext"),")."),(0,r.yg)("p",null,"The error type of the resulting effect will always be ",(0,r.yg)("inlineCode",{parentName:"p"},"Throwable"),", because ",(0,r.yg)("inlineCode",{parentName:"p"},"Future")," can only fail with values of type ",(0,r.yg)("inlineCode",{parentName:"p"},"Throwable"),"."),(0,r.yg)("h4",{id:"promise"},"Promise"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromPromiseScala")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"scala.concurrent.Promise[A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Task[A]"))))),(0,r.yg)("p",null,"A ",(0,r.yg)("inlineCode",{parentName:"p"},"Promise")," can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.fromPromiseScala"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport scala.util._\n\nval func: String => String = s => s.toUpperCase\nfor {\n  promise <- ZIO.succeed(scala.concurrent.Promise[String]())\n  _ <- ZIO.attempt {\n    Try(func("hello world from future")) match {\n      case Success(value) => promise.success(value)\n      case Failure(exception) => promise.failure(exception)\n    }\n  }.fork\n  value <- ZIO.fromPromiseScala(promise)\n  _ <- Console.printLine(s"Hello World in UpperCase: $value")\n} yield ()\n')),(0,r.yg)("h4",{id:"fiber"},"Fiber"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromFiber")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Fiber[E, A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"IO[E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fromFiberZIO")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"IO[E, Fiber[E, A]]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"IO[E, A]"))))),(0,r.yg)("p",null,"A ",(0,r.yg)("inlineCode",{parentName:"p"},"Fiber")," can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.fromFiber"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval io: IO[Nothing, String] = ZIO.fromFiber(Fiber.succeed("Hello from Fiber!"))\n')),(0,r.yg)("h3",{id:"from-side-effects"},"From Side-Effects"),(0,r.yg)("p",null,"ZIO can convert both synchronous and asynchronous side-effects into ZIO effects (pure values)."),(0,r.yg)("p",null,"These functions can be used to wrap procedural code, allowing us to seamlessly use all features of ZIO with legacy Scala and Java code, as well as third-party libraries."),(0,r.yg)("h4",{id:"synchronous"},"Synchronous"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Note"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"succeed")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"A")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"UIO[A]")),(0,r.yg)("td",{parentName:"tr",align:null},"Imports a total synchronous effect")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"attempt")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"A")),(0,r.yg)("td",{parentName:"tr",align:null},"Task","[A]"),(0,r.yg)("td",{parentName:"tr",align:null},"Imports a (partial) synchronous side-effect")))),(0,r.yg)("p",null,"A synchronous side-effect can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.attempt"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport scala.io.StdIn\n\nval getLine: Task[String] =\n  ZIO.attempt(StdIn.readLine())\n")),(0,r.yg)("p",null,"The error type of the resulting effect will always be ",(0,r.yg)("inlineCode",{parentName:"p"},"Throwable"),", because side-effects may throw exceptions with any value of type ",(0,r.yg)("inlineCode",{parentName:"p"},"Throwable"),"."),(0,r.yg)("p",null,"If a given side-effect is known to not throw any exceptions, then the side-effect can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.succeed"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ndef printLine(line: String): UIO[Unit] =\n  ZIO.succeed(println(line))\n\nval succeedTask: UIO[Long] =\n  ZIO.succeed(java.lang.System.nanoTime())\n")),(0,r.yg)("p",null,"We should be careful when using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.succeed"),"\u2014when in doubt about whether or not a side-effect is total, prefer ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.attempt")," to convert the effect."),(0,r.yg)("p",null,"If this is too broad, the ",(0,r.yg)("inlineCode",{parentName:"p"},"refineOrDie")," method of ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," may be used to retain only certain types of exceptions, and to die on any other types of exceptions:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport java.io.IOException\n\nval printLine2: IO[IOException, String] =\n  ZIO.attempt(scala.io.StdIn.readLine()).refineToOrDie[IOException]\n")),(0,r.yg)("h5",{id:"blocking-synchronous-side-effects"},"Blocking Synchronous Side-Effects"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"blocking")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"attemptBlocking")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"A")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"RIO[Blocking, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"attemptBlockingCancelable")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"effect: => A"),", ",(0,r.yg)("inlineCode",{parentName:"td"},"cancel: UIO[Unit]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"RIO[Blocking, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"attemptBlockingInterrupt")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"A")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"RIO[Blocking, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"attemptBlockingIO")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"A")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[Blocking, IOException, A]"))))),(0,r.yg)("p",null,"By default, ZIO is asynchronous and all effects will be executed on a default primary thread pool which is optimized for asynchronous operations. As ZIO uses a fiber-based concurrency model, if we run ",(0,r.yg)("strong",{parentName:"p"},"Blocking I/O")," or ",(0,r.yg)("strong",{parentName:"p"},"CPU Work")," workloads on a primary thread pool, they are going to monopolize all threads of ",(0,r.yg)("strong",{parentName:"p"},"primary thread pool"),"."),(0,r.yg)("p",null,"ZIO has a separate ",(0,r.yg)("strong",{parentName:"p"},"blocking thread pool")," specially designed for ",(0,r.yg)("strong",{parentName:"p"},"Blocking I/O")," and, also ",(0,r.yg)("strong",{parentName:"p"},"CPU Work")," workloads. We should run blocking workloads on this thread pool by using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.blocking")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.attemptBlocking*")," constructors to prevent interfering with the primary thread pool."),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"ZIO has an auto-blocking mechanism that detects blocking operations and runs them on a separate blocking thread pool. However, if you know that some code is blocking you can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.blocking"),' constructor to give a "hint" of this to the ZIO runtime.')),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"blocking")," operator takes a ZIO effect and returns another effect that is going to run on a blocking thread pool:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"val program = ZIO.foreachPar((1 to 100).toArray)(t => ZIO.blocking(blockingTask(t)))\n")),(0,r.yg)("p",null,"A blocking side-effect can be converted directly into a ZIO effect using the ",(0,r.yg)("inlineCode",{parentName:"p"},"attemptBlocking")," method:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef blockingTask(n: Int) = ZIO.attemptBlocking {\n  do {\n    println(s"Running blocking task number $n on dedicated blocking thread pool")\n    Thread.sleep(3000)\n  } while (true)\n}\n')),(0,r.yg)("p",null,"The resulting effect will be executed on a separate thread pool designed specifically for blocking effects."),(0,r.yg)("p",null,"Blocking side-effects can be interrupted by invoking ",(0,r.yg)("inlineCode",{parentName:"p"},"Thread.interrupt")," using the ",(0,r.yg)("inlineCode",{parentName:"p"},"attemptBlockingInterrupt")," method."),(0,r.yg)("p",null,"Some blocking side-effects can only be interrupted by invoking a cancellation effect. We can convert these side-effects using the ",(0,r.yg)("inlineCode",{parentName:"p"},"attemptBlockingCancelable")," method:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport java.net.ServerSocket\n\ndef accept(l: ServerSocket) =\n  ZIO.attemptBlockingCancelable(l.accept())(ZIO.succeed(l.close()))\n")),(0,r.yg)("p",null,"If a side-effect has already been converted into a ZIO effect, then instead of ",(0,r.yg)("inlineCode",{parentName:"p"},"attemptBlocking"),", the ",(0,r.yg)("inlineCode",{parentName:"p"},"blocking")," method can be used to ensure the effect will be executed on the blocking thread pool:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport scala.io.{ Codec, Source }\n\ndef download(url: String) =\n  ZIO.attempt {\n    Source.fromURL(url)(Codec.UTF8).mkString\n  }\n\ndef safeDownload(url: String) =\n  ZIO.blocking(download(url))\n")),(0,r.yg)("h4",{id:"asynchronous"},"Asynchronous"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"async")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"(ZIO[R, E, A] => Unit) => Any")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"asyncZIO")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"(ZIO[R, E, A] => Unit) => ZIO[R, E, Any]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"asyncMaybe")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"(ZIO[R, E, A] => Unit) => Option[ZIO[R, E, A]]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"asyncInterrupt")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"(ZIO[R, E, A] => Unit) => Either[URIO[R, Any], ZIO[R, E, A]]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))))),(0,r.yg)("p",null,"An asynchronous side-effect with a callback-based API can be converted into a ZIO effect using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.async"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject legacy {\n  def login(\n    onSuccess: User => Unit,\n    onFailure: AuthError => Unit): Unit = ???\n}\n\nval login: IO[AuthError, User] =\n  ZIO.async[Any, AuthError, User] { callback =>\n    legacy.login(\n      user => callback(ZIO.succeed(user)),\n      err  => callback(ZIO.fail(err))\n    )\n  }\n")),(0,r.yg)("p",null,"Asynchronous ZIO effects are much easier to use than callback-based APIs, and they benefit from ZIO features like interruption, resource-safety, and superior error handling."),(0,r.yg)("h3",{id:"creating-suspended-effects"},"Creating Suspended Effects"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"suspend")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"RIO[R, A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"RIO[R, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"suspendSucceed")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))))),(0,r.yg)("p",null,"A ",(0,r.yg)("inlineCode",{parentName:"p"},"RIO[R, A]")," effect can be suspended using ",(0,r.yg)("inlineCode",{parentName:"p"},"suspend")," function:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.io.IOException\n\nval suspendedEffect: RIO[Any, ZIO[Any, IOException, Unit]] =\n  ZIO.suspend(ZIO.attempt(Console.printLine("Suspended Hello World!")))\n')),(0,r.yg)("h2",{id:"mapping"},"Mapping"),(0,r.yg)("h3",{id:"map"},"map"),(0,r.yg)("p",null,"We can change an ",(0,r.yg)("inlineCode",{parentName:"p"},"IO[E, A]")," to an ",(0,r.yg)("inlineCode",{parentName:"p"},"IO[E, B]")," by calling the ",(0,r.yg)("inlineCode",{parentName:"p"},"map")," method with a function ",(0,r.yg)("inlineCode",{parentName:"p"},"A => B"),". This lets us transform values produced by actions into other values."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval mappedValue: UIO[Int] = ZIO.succeed(21).map(_ * 2)\n")),(0,r.yg)("h2",{id:"tapping"},"Tapping"),(0,r.yg)("p",null,"Using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.tap")," we can peek into a success value and perform any effectful operation, without changing the returning value of the original effect:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def tap[R1 <: R, E1 >: E](f: A => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapSome[R1 <: R, E1 >: E](f: PartialFunction[A, ZIO[R1, E1, Any]]): ZIO[R1, E1, A]\n}\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def isPrime(n: Int): Boolean =\n    if (n <= 1) false else (2 until n).forall(i => n % i != 0)\n\n  val myApp: ZIO[Any, IOException, Unit] =\n    for {\n      ref <- Ref.make(List.empty[Int])\n      prime <-\n        Random\n          .nextIntBetween(0, Int.MaxValue)\n          .tap(random => ref.update(_ :+ random))\n          .repeatUntil(isPrime)\n      _ <- Console.printLine(s"found a prime number: $prime")\n      tested <- ref.get\n      _ <- Console.printLine(\n        s"list of tested numbers: ${tested.mkString(", ")}"\n      )\n    } yield ()\n\n  def run = myApp\n}\n')),(0,r.yg)("h2",{id:"chaining"},"Chaining"),(0,r.yg)("p",null,"We can execute two actions in sequence with the ",(0,r.yg)("inlineCode",{parentName:"p"},"flatMap")," method. The second action may depend on the value produced by the first action."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval chainedActionsValue: UIO[List[Int]] = ZIO.succeed(List(1, 2, 3)).flatMap { list =>\n  ZIO.succeed(list.map(_ + 1))\n}\n")),(0,r.yg)("p",null,"If the first effect fails, the callback passed to ",(0,r.yg)("inlineCode",{parentName:"p"},"flatMap")," will never be invoked, and the composed effect returned by ",(0,r.yg)("inlineCode",{parentName:"p"},"flatMap")," will also fail."),(0,r.yg)("p",null,"In ",(0,r.yg)("em",{parentName:"p"},"any")," chain of effects, the first failure will short-circuit the whole chain, just like throwing an exception will prematurely exit a sequence of statements."),(0,r.yg)("p",null,"Because the ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," data type supports both ",(0,r.yg)("inlineCode",{parentName:"p"},"flatMap")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"map"),", we can use Scala's ",(0,r.yg)("em",{parentName:"p"},"for comprehensions")," to build sequential effects:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval program =\n  for {\n    _    <- Console.printLine("Hello! What is your name?")\n    name <- Console.readLine\n    _    <- Console.printLine(s"Hello, ${name}, welcome to ZIO!")\n  } yield ()\n')),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"For comprehensions")," provide a more procedural syntax for composing chains of effects."),(0,r.yg)("h2",{id:"zipping"},"Zipping"),(0,r.yg)("p",null,"We can combine two effects into a single effect with the ",(0,r.yg)("inlineCode",{parentName:"p"},"zip")," method. The resulting effect succeeds with a tuple that contains the success values of both effects:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval zipped: UIO[(String, Int)] =\n  ZIO.succeed("4").zip(ZIO.succeed(2))\n')),(0,r.yg)("p",null,"Note that ",(0,r.yg)("inlineCode",{parentName:"p"},"zip")," operates sequentially: the effect on the left side is executed before the effect on the right side."),(0,r.yg)("p",null,"In any ",(0,r.yg)("inlineCode",{parentName:"p"},"zip")," operation, if either the left or right-hand sides fail, then the composed effect will fail, because ",(0,r.yg)("em",{parentName:"p"},"both")," values are required to construct the tuple."),(0,r.yg)("h3",{id:"zipleft-and-zipright"},"zipLeft and zipRight"),(0,r.yg)("p",null,"Sometimes, when the success value of an effect is not useful (for example, it is ",(0,r.yg)("inlineCode",{parentName:"p"},"Unit"),"), it can be more convenient to use the ",(0,r.yg)("inlineCode",{parentName:"p"},"zipLeft")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"zipRight")," functions, which first perform a ",(0,r.yg)("inlineCode",{parentName:"p"},"zip"),", and then map over the tuple to discard one side or the other:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval zipRight1 =\n  Console.printLine("What is your name?").zipRight(Console.readLine)\n')),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"zipRight")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"zipLeft")," functions have symbolic aliases, known as ",(0,r.yg)("inlineCode",{parentName:"p"},"*>")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"<*"),", respectively. Some developers find these operators easier to read:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval zipRight2 =\n  Console.printLine("What is your name?") *>\n  Console.readLine\n')),(0,r.yg)("h2",{id:"parallelism"},"Parallelism"),(0,r.yg)("p",null,"ZIO provides many operations for performing effects in parallel. These methods are all named with a ",(0,r.yg)("inlineCode",{parentName:"p"},"Par")," suffix that helps us identify opportunities to parallelize our code."),(0,r.yg)("p",null,"For example, the ordinary ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#zip")," method zips two effects together, sequentially. But there is also a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#zipPar")," method, which zips two effects together in parallel."),(0,r.yg)("p",null,"The following table summarizes some of the sequential operations and their corresponding parallel versions:"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"right"},(0,r.yg)("strong",{parentName:"th"},"Description")),(0,r.yg)("th",{parentName:"tr",align:"center"},(0,r.yg)("strong",{parentName:"th"},"Sequential")),(0,r.yg)("th",{parentName:"tr",align:"center"},(0,r.yg)("strong",{parentName:"th"},"Parallel")))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"right"},"Zip two effects into one"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#zip")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#zipPar"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"right"},"Zip two effects into one"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#zipWith")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#zipWithPar"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"right"},"Collect from many effects"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.collectAll")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.collectAllPar"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"right"},"Effectfully loop over values"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.foreach")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.foreachPar"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"right"},"Reduce many values"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.reduceAll")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.reduceAllPar"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"right"},"Merge many values"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.mergeAll")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.mergeAllPar"))))),(0,r.yg)("p",null,"For all the parallel operations, if one effect fails, then others will be interrupted, to minimize unnecessary computation."),(0,r.yg)("p",null,"If the fail-fast behavior is not desired, potentially failing effects can be first converted into infallible effects using the ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#either")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#option")," methods."),(0,r.yg)("h3",{id:"racing"},"Racing"),(0,r.yg)("p",null,"ZIO lets us race multiple effects in parallel, returning the first successful result:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nfor {\n  winner <- ZIO.succeed("Hello").race(ZIO.succeed("Goodbye"))\n} yield winner\n')),(0,r.yg)("p",null,"If we want the first success or failure, rather than the first success, then we can use ",(0,r.yg)("inlineCode",{parentName:"p"},"left.either race right.either"),", for any effects ",(0,r.yg)("inlineCode",{parentName:"p"},"left")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"right"),"."),(0,r.yg)("h2",{id:"timeout"},"Timeout"),(0,r.yg)("p",null,"ZIO lets us timeout any effect using the ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#timeout")," method, which returns a new effect that succeeds with an ",(0,r.yg)("inlineCode",{parentName:"p"},"Option"),". A value of ",(0,r.yg)("inlineCode",{parentName:"p"},"None")," indicates the timeout elapsed before the effect completed."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.succeed("Hello").timeout(10.seconds)\n')),(0,r.yg)("p",null,"If an effect times out, then instead of continuing to execute in the background, it will be interrupted so no resources will be wasted."),(0,r.yg)("h2",{id:"error-management"},"Error Management"),(0,r.yg)("h3",{id:"either-1"},"Either"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#either")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"URIO[R, Either[E, A]]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO.absolve")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, Either[E, A]]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))))),(0,r.yg)("p",null,"We can surface failures with ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#either"),", which takes a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, A]")," and produces a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, Nothing, Either[E, A]]"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val zeither: UIO[Either[String, Int]] =\n  ZIO.fail("Uh oh!").either\n')),(0,r.yg)("p",null,"We can submerge failures with ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.absolve"),", which is the opposite of ",(0,r.yg)("inlineCode",{parentName:"p"},"either")," and turns a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, Nothing, Either[E, A]]")," into a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, A]"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'def sqrt(io: UIO[Double]): IO[String, Double] =\n  ZIO.absolve(\n    io.map(value =>\n      if (value < 0.0) Left("Value must be >= 0.0")\n      else Right(Math.sqrt(value))\n    )\n  )\n')),(0,r.yg)("h3",{id:"catching"},"Catching"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#catchAll")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"E => ZIO[R1, E2, A1]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#catchAllCause")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Cause[E] => ZIO[R1, E2, A1]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#catchAllDefect")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Throwable => ZIO[R1, E1, A1]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E1, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#catchAllTrace")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"((E, Option[StackTrace])) => ZIO[R1, E2, A1]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#catchSome")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"PartialFunction[E, ZIO[R1, E1, A1]]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E1, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#catchSomeCause")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"PartialFunction[Cause[E], ZIO[R1, E1, A1]]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E1, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#catchSomeDefect")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"PartialFunction[Throwable, ZIO[R1, E1, A1]]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E1, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO#catchSomeTrace")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"PartialFunction[(E, Option[StackTrace]), ZIO[R1, E1, A1]]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E1, A1]"))))),(0,r.yg)("h4",{id:"catching-all-errors"},"Catching All Errors"),(0,r.yg)("p",null,"If we want to catch and recover from all types of errors and effectfully attempt recovery, we can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"catchAll")," method:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val z: IO[IOException, Array[Byte]] =\n  readFile("primary.json").catchAll(_ =>\n    readFile("backup.json"))\n')),(0,r.yg)("p",null,"In the callback passed to ",(0,r.yg)("inlineCode",{parentName:"p"},"catchAll"),", we may return an effect with a different error type (or perhaps ",(0,r.yg)("inlineCode",{parentName:"p"},"Nothing"),"), which will be reflected in the type of effect returned by ",(0,r.yg)("inlineCode",{parentName:"p"},"catchAll"),"."),(0,r.yg)("h4",{id:"catching-some-errors"},"Catching Some Errors"),(0,r.yg)("p",null,"If we want to catch and recover from only some types of exceptions and effectfully attempt recovery, we can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"catchSome")," method:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val data: IO[IOException, Array[Byte]] =\n  readFile("primary.data").catchSome {\n    case _ : FileNotFoundException =>\n      readFile("backup.data")\n  }\n')),(0,r.yg)("p",null,"Unlike ",(0,r.yg)("inlineCode",{parentName:"p"},"catchAll"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"catchSome")," cannot reduce or eliminate the error type, although it can widen the error type to a broader class of errors."),(0,r.yg)("h3",{id:"fallback"},"Fallback"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"orElse")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, A1]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"orElseEither")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, B]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, Either[A, B]]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"orElseFail")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"E1")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E1, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"orElseOptional")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, Option[E1], A1]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, Option[E1], A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"orElseSucceed")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"A1")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"URIO[R, A1]"))))),(0,r.yg)("p",null,"We can try one effect, or, if it fails, try another effect, with the ",(0,r.yg)("inlineCode",{parentName:"p"},"orElse")," combinator:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val primaryOrBackupData: IO[IOException, Array[Byte]] =\n  readFile("primary.data").orElse(readFile("backup.data"))\n')),(0,r.yg)("h3",{id:"folding"},"Folding"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"fold")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"failure: E => B, success: A => B")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"URIO[R, B]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"foldCause")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"failure: Cause[E] => B, success: A => B")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"URIO[R, B]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"foldZIO")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"failure: E => ZIO[R1, E2, B], success: A => ZIO[R1, E2, B]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, B]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"foldCauseZIO")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"failure: Cause[E] => ZIO[R1, E2, B], success: A => ZIO[R1, E2, B]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, B]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"foldTraceZIO")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"failure: ((E, Option[StackTrace])) => ZIO[R1, E2, B], success: A => ZIO[R1, E2, B]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E2, B]"))))),(0,r.yg)("p",null,"Scala's ",(0,r.yg)("inlineCode",{parentName:"p"},"Option")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"Either")," data types have ",(0,r.yg)("inlineCode",{parentName:"p"},"fold"),", which lets us handle both failure and success at the same time. In a similar fashion, ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effects also have several methods that allow us to handle both failure and success."),(0,r.yg)("p",null,"The first fold method, ",(0,r.yg)("inlineCode",{parentName:"p"},"fold"),", lets us non-effectfully handle both failure and success by supplying a non-effectful handler for each case:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'lazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: UIO[Array[Byte]] =\n  readFile("primary.data").fold(\n    _    => DefaultData,\n    data => data)\n')),(0,r.yg)("p",null,"The second fold method, ",(0,r.yg)("inlineCode",{parentName:"p"},"foldZIO"),", lets us effectfully handle both failure and success by supplying an effectful (but still pure) handler for each case:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val primaryOrSecondaryData: IO[IOException, Array[Byte]] =\n  readFile("primary.data").foldZIO(\n    _    => readFile("secondary.data"),\n    data => ZIO.succeed(data))\n')),(0,r.yg)("p",null,"Nearly all error handling methods are defined in terms of ",(0,r.yg)("inlineCode",{parentName:"p"},"foldZIO"),", because it is both powerful and fast."),(0,r.yg)("p",null,"In the following example, ",(0,r.yg)("inlineCode",{parentName:"p"},"foldZIO")," is used to handle both failure and success of the ",(0,r.yg)("inlineCode",{parentName:"p"},"readUrls")," method:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val urls: UIO[Content] =\n  readUrls("urls.json").foldZIO(\n    error   => ZIO.succeed(NoContent(error)),\n    success => fetchContent(success)\n  )\n')),(0,r.yg)("h3",{id:"retrying"},"Retrying"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Function"),(0,r.yg)("th",{parentName:"tr",align:null},"Input Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Output Type"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retry")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Schedule[R1, E, S]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryN")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"n: Int")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryOrElse")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"policy: Schedule[R1, E, S], orElse: (E, S) => ZIO[R1, E1, A1]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E1, A1]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryOrElseEither")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"schedule: Schedule[R1, E, Out], orElse: (E, Out) => ZIO[R1, E1, B]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E1, Either[B, A]]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryUntil")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"E => Boolean")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryUntilEquals")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"E1")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E1, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryUntilZIO")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"E => URIO[R1, Boolean]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryWhile")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"E => Boolean")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryWhileEquals")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"E1")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R, E1, A]"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"retryWhileZIO")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"E => URIO[R1, Boolean]")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ZIO[R1, E, A]"))))),(0,r.yg)("p",null,"When we are building applications we want to be resilient in the face of a transient failure. This is where we need to retry to overcome these failures."),(0,r.yg)("p",null,"There are a number of useful methods on the ZIO data type for retrying failed effects."),(0,r.yg)("p",null,"The most basic of these is ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#retry"),", which takes a ",(0,r.yg)("inlineCode",{parentName:"p"},"Schedule")," and returns a new effect that will retry the first effect if it fails according to the specified policy:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val retriedOpenFile: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.data").retry(Schedule.recurs(5))\n')),(0,r.yg)("p",null,"The next most powerful function is ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#retryOrElse"),", which allows specification of a fallback to use if the effect does not succeed with the specified policy:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'readFile("primary.data").retryOrElse(\n  Schedule.recurs(5),\n  (_, _:Long) => ZIO.succeed(DefaultData)\n)\n')),(0,r.yg)("p",null,"The final method, ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#retryOrElseEither"),", allows returning a different type for the fallback."),(0,r.yg)("h2",{id:"resource-management"},"Resource Management"),(0,r.yg)("p",null,"ZIO's resource management features work across synchronous, asynchronous, concurrent, and other effect types, and provide strong guarantees even in the presence of failure, interruption, or defects in the application."),(0,r.yg)("h3",{id:"finalizing"},"Finalizing"),(0,r.yg)("p",null,"Scala has a ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," construct which helps us to make sure we don't leak resources because no matter what happens in the ",(0,r.yg)("inlineCode",{parentName:"p"},"try"),", the ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," block will be executed. So we can open files in the ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," block, and then we can close them in the ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," block, and that gives us the guarantee that we will not leak resources."),(0,r.yg)("h4",{id:"asynchronous-try--finally"},"Asynchronous Try / Finally"),(0,r.yg)("p",null,"The problem with the ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," construct is that it only applies to synchronous code, meaning it doesn't work for asynchronous code. ZIO gives us a method called ",(0,r.yg)("inlineCode",{parentName:"p"},"ensuring")," that works with either synchronous or asynchronous actions. So we have a functional ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," even for asynchronous regions of our code."),(0,r.yg)("p",null,"Like ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally"),", the ",(0,r.yg)("inlineCode",{parentName:"p"},"ensuring")," operation guarantees that if an effect begins executing and then terminates (for whatever reason), then the finalizer will begin executing:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval finalizer =\n  ZIO.succeed(println("Finalizing!"))\n\nval finalized: IO[String, Unit] =\n  ZIO.fail("Failed!").ensuring(finalizer)\n')),(0,r.yg)("p",null,"The finalizer is not allowed to fail, which means that it must handle any errors internally."),(0,r.yg)("p",null,"Like ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally"),", finalizers can be nested, and the failure of any inner finalizer will not affect outer finalizers. Nested finalizers will be executed in reverse order, and linearly (not in parallel)."),(0,r.yg)("p",null,"Unlike ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"ensuring")," works across all types of effects, including asynchronous and concurrent effects."),(0,r.yg)("p",null,"Here is another example of ensuring that our clean-up action is called before our effect is done:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport zio.Task\nvar i: Int = 0\nval action: Task[String] =\n  ZIO.succeed(i += 1) *>\n    ZIO.fail(new Throwable("Boom!"))\nval cleanupAction: UIO[Unit] = ZIO.succeed(i -= 1)\nval composite = action.ensuring(cleanupAction)\n')),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"Finalizers offer very powerful guarantees, but they are low-level, and should generally not be used for releasing resources. For higher-level logic built on ",(0,r.yg)("inlineCode",{parentName:"p"},"ensuring"),", see ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#acquireReleaseWith")," in the acquire release section.")),(0,r.yg)("h4",{id:"unstoppable-finalizers"},"Unstoppable Finalizers"),(0,r.yg)("p",null,"In Scala when we nest ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," finalizers, they cannot be stopped. If we have nested finalizers and one of them fails for some sort of catastrophic reason the ones on the outside will still be run and in the correct order."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"try {\n  try {\n    try {\n      ...\n    } finally f1\n  } finally f2\n} finally f3\n")),(0,r.yg)("p",null,"Also in ZIO like ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally"),", the finalizers are unstoppable. This means if we have a buggy finalizer that is going to leak some resources, we will leak the minimum amount of resources because all other finalizers will still be run in the correct order."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"val io = ???\nio.ensuring(f1)\n .ensuring(f2)\n .ensuring(f3)\n")),(0,r.yg)("h3",{id:"acquire-release"},"Acquire Release"),(0,r.yg)("p",null,"In Scala ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," is often used to manage resources. A common use for ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," is safely acquiring and releasing resources, such as new socket connections or opened files:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"val handle = openFile(name)\n\ntry {\n  processFile(handle)\n} finally closeFile(handle)\n")),(0,r.yg)("p",null,"ZIO encapsulates this common pattern with ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#acquireRelease"),", which allows us to specify an ",(0,r.yg)("em",{parentName:"p"},"acquire")," effect, which acquires a resource; a ",(0,r.yg)("em",{parentName:"p"},"release")," effect, which releases it; and a ",(0,r.yg)("em",{parentName:"p"},"use")," effect, which uses the resource. Acquire release lets us open a file and close the file and no matter what happens when we are using that resource."),(0,r.yg)("p",null,"The release action is guaranteed to be executed by the runtime system, even if the utilize action throws an exception or the executing fiber is interrupted."),(0,r.yg)("p",null,"Acquire release is a built-in primitive that let us safely acquire and release resources. It is used for a similar purpose as ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"catch")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"finally"),", only acquire release work with synchronous and asynchronous actions, work seamlessly with fiber interruption, and is built on a different error model that ensures no errors are ever swallowed."),(0,r.yg)("p",null,"Acquire release consist of an ",(0,r.yg)("em",{parentName:"p"},"acquire")," action, a ",(0,r.yg)("em",{parentName:"p"},"utilize")," action (which uses the acquired resource), and a ",(0,r.yg)("em",{parentName:"p"},"release")," action."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval groupedFileData: IO[IOException, Unit] = ZIO.acquireReleaseWith(openFile("data.json"))(closeFile(_)) { file =>\n  for {\n    data    <- decodeData(file)\n    grouped <- groupData(data)\n  } yield grouped\n}\n')),(0,r.yg)("p",null,"Acquire releases have compositional semantics, so if an acquire release is nested inside another acquire release, and the outer resource is acquired, then the outer release will always be called, even if, for example, the inner release fails."),(0,r.yg)("p",null,"Let's look at a full working example on using acquire release:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.io.{ File, FileInputStream }\nimport java.nio.charset.StandardCharsets\n\nobject Main extends ZIOAppDefault {\n\n  // run my acquire release\n  def run = myAcquireRelease\n\n  def closeStream(is: FileInputStream) =\n    ZIO.succeed(is.close())\n\n  def convertBytes(is: FileInputStream, len: Long) =\n    ZIO.attempt {\n      val buffer = new Array[Byte](len.toInt)\n      is.read(buffer)\n      println(new String(buffer, StandardCharsets.UTF_8))\n    }\n\n  // myAcquireRelease is just a value. Won\'t execute anything here until interpreted\n  val myAcquireRelease: Task[Unit] = for {\n    file   <- ZIO.attempt(new File("/tmp/hello"))\n    len    = file.length\n    string <- ZIO.acquireReleaseWith(ZIO.attempt(new FileInputStream(file)))(closeStream)(convertBytes(_, len))\n  } yield string\n}\n')),(0,r.yg)("h2",{id:"zio-aspect"},"ZIO Aspect"),(0,r.yg)("p",null,"There are two types of concerns in an application, ",(0,r.yg)("em",{parentName:"p"},"core concerns"),", and ",(0,r.yg)("em",{parentName:"p"},"cross-cutting concerns"),". Cross-cutting concerns are shared among different parts of our application. We usually find them scattered and duplicated across our application, or they are tangled up with our primary concerns. This reduces the level of modularity of our programs."),(0,r.yg)("p",null,"A cross-cutting concern is more about ",(0,r.yg)("em",{parentName:"p"},"how")," we do something than ",(0,r.yg)("em",{parentName:"p"},"what")," we are doing. For example, when we are downloading a bunch of files, creating a socket to download each one is the core concern because it is a question of ",(0,r.yg)("em",{parentName:"p"},"what")," rather than the ",(0,r.yg)("em",{parentName:"p"},"how"),", but the following concerns are cross-cutting ones:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Downloading files ",(0,r.yg)("em",{parentName:"li"},"sequentially")," or in ",(0,r.yg)("em",{parentName:"li"},"parallel")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("em",{parentName:"li"},"Retrying")," and ",(0,r.yg)("em",{parentName:"li"},"timing out")," the download process"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("em",{parentName:"li"},"Logging")," and ",(0,r.yg)("em",{parentName:"li"},"monitoring")," the download process")),(0,r.yg)("p",null,"So they don't affect the return type of our workflows, but they add some new aspects or change their behavior."),(0,r.yg)("p",null,"To increase the modularity of our applications, we can separate cross-cutting concerns from the main logic of our programs. ZIO supports this programming paradigm, which is called ",(0,r.yg)("em",{parentName:"p"}," aspect-oriented programming"),"."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effect has a data type called ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIOAspect"),", which allows modifying a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effect and converting it into a specialized ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effect. We can add a new aspect to a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effect with ",(0,r.yg)("inlineCode",{parentName:"p"},"@@")," syntax like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval myApp: ZIO[Any, Throwable, String] =\n  ZIO.attempt("Hello!") @@ ZIOAspect.debug\n')),(0,r.yg)("p",null,"As we see, the ",(0,r.yg)("inlineCode",{parentName:"p"},"debug")," aspect doesn't change the return type of our effect, but it adds a new debugging aspect to our effect."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"ZIOAspect")," is like a transformer of the ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effect, which takes a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effect and converts it to another ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," effect. We can think of a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIOAspect")," as a function of type ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, A] => ZIO[R, E, A]"),"."),(0,r.yg)("p",null,"To compose multiple aspects, we can use ",(0,r.yg)("inlineCode",{parentName:"p"},"@@")," operator:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef download(url: String): ZIO[Any, Throwable, Chunk[Byte]] = ZIO.succeed(???)\n\nZIO.foreachPar(List("zio.dev", "google.com")) { url =>\n  download(url) @@\n    ZIOAspect.retry(Schedule.fibonacci(1.seconds)) @@\n    ZIOAspect.loggedWith[Chunk[Byte]](file => s"Downloaded $url file with size of ${file.length} bytes")\n}\n')),(0,r.yg)("p",null,"The order of aspect composition matters. Therefore, if we change the order, the behavior may change."))}s.isMDXComponent=!0}}]);