"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[40113],{15680:(e,n,a)=>{a.d(n,{xA:()=>d,yg:()=>g});var o=a(96540);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function t(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?t(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):t(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function c(e,n){if(null==e)return{};var a,o,r=function(e,n){if(null==e)return{};var a,o,r={},t=Object.keys(e);for(o=0;o<t.length;o++)a=t[o],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(o=0;o<t.length;o++)a=t[o],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=o.createContext({}),l=function(e){var n=o.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},d=function(e){var n=l(e.components);return o.createElement(s.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var a=e.components,r=e.mdxType,t=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),m=l(a),h=r,g=m["".concat(s,".").concat(h)]||m[h]||p[h]||t;return a?o.createElement(g,i(i({ref:n},d),{},{components:a})):o.createElement(g,i({ref:n},d))}));function g(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var t=a.length,i=new Array(t);i[0]=h;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[m]="string"==typeof e?e:r,i[1]=c;for(var l=2;l<t;l++)i[l]=a[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}h.displayName="MDXCreateElement"},41472:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>t,metadata:()=>c,toc:()=>l});var o=a(58168),r=(a(96540),a(15680));const t={id:"avro",title:"Apache Avro Codecs",sidebar_label:"Apache Avro"},i=void 0,c={unversionedId:"zio-schema/derivations/codecs/avro",id:"zio-schema/derivations/codecs/avro",title:"Apache Avro Codecs",description:"Introduction",source:"@site/docs/zio-schema/derivations/codecs/avro.md",sourceDirName:"zio-schema/derivations/codecs",slug:"/zio-schema/derivations/codecs/avro",permalink:"/zio-schema/derivations/codecs/avro",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/derivations/codecs/avro.md",tags:[],version:"current",frontMatter:{id:"avro",title:"Apache Avro Codecs",sidebar_label:"Apache Avro"},sidebar:"ecosystem-sidebar",previous:{title:"Codecs",permalink:"/zio-schema/derivations/codecs/"},next:{title:"Apache Thrift",permalink:"/zio-schema/derivations/codecs/thrift"}},s={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Codecs",id:"codecs",level:2},{value:"AvroSchemaCodec",id:"avroschemacodec",level:3},{value:"AvroCodec",id:"avrocodec",level:3},{value:"Annotations",id:"annotations",level:2}],d={toc:l},m="wrapper";function p(e){let{components:n,...a}=e;return(0,r.yg)(m,(0,o.A)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"introduction"},"Introduction"),(0,r.yg)("p",null,"Apache Avro is a popular data serialization format used in distributed systems, particularly in the Apache Hadoop ecosystem. In this article, we will explore how to work with Apache Avro codecs in Scala using the ZIO Schema. Avro codecs allow us to easily serialize and deserialize data in Avro's binary and JSON formats."),(0,r.yg)("h2",{id:"installation"},"Installation"),(0,r.yg)("p",null,"To use the Avro codecs, we need to add the following dependency to our ",(0,r.yg)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-schema-avro" % "1.3.0"\n')),(0,r.yg)("h2",{id:"codecs"},"Codecs"),(0,r.yg)("p",null,"It has two codecs:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"An ",(0,r.yg)("strong",{parentName:"li"},"AvroSchemaCodec")," to serialize a ",(0,r.yg)("inlineCode",{parentName:"li"},"Schema[A]")," to Avro JSON schema and deserialize an Avro JSON schema to a ",(0,r.yg)("inlineCode",{parentName:"li"},"Schema.GenericRecord"),"."),(0,r.yg)("li",{parentName:"ul"},"An ",(0,r.yg)("strong",{parentName:"li"},"AvroCodec")," to serialize/deserialize the Avro binary serialization format.")),(0,r.yg)("h3",{id:"avroschemacodec"},"AvroSchemaCodec"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"AvroSchemaCodec")," provides methods to encode a ",(0,r.yg)("inlineCode",{parentName:"p"},"Schema[_]")," to Avro JSON schema and decode an Avro JSON schema to a ",(0,r.yg)("inlineCode",{parentName:"p"},"Schema[_]")," (",(0,r.yg)("a",{parentName:"p",href:"/zio-schema/operations/dynamic-data-representation"},(0,r.yg)("inlineCode",{parentName:"a"},"Schema.GenericRecord")),"):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"trait AvroSchemaCodec {\n  def encode(schema: Schema[_]): scala.util.Either[String, String]\n  def decode(bytes: Chunk[Byte]): scala.util.Either[String, Schema[_]]\n}\n")),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"encode")," method takes a ",(0,r.yg)("inlineCode",{parentName:"p"},"Schema[_]")," and returns an ",(0,r.yg)("inlineCode",{parentName:"p"},"Either[String, String]")," where the ",(0,r.yg)("inlineCode",{parentName:"p"},"Right")," side contains the Avro schema in JSON\u200c format."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"decode")," method takes a ",(0,r.yg)("inlineCode",{parentName:"p"},"Chunk[Byte]")," which contains the Avro JSON Schema in binary format and returns an ",(0,r.yg)("inlineCode",{parentName:"p"},"Either[String, Schema[_]]")," where the ",(0,r.yg)("inlineCode",{parentName:"p"},"Right")," side contains the ZIO Schema in ",(0,r.yg)("inlineCode",{parentName:"p"},"GenericRecord")," format."),(0,r.yg)("p",null,"Here is an example of how to use it:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.schema.Schema\nimport zio.schema.DeriveSchema\nimport zio.schema.codec.AvroSchemaCodec\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen\n}\n\nobject Main extends ZIOAppDefault {\n  def run =\n    for {\n      _          <- ZIO.debug("AvroSchemaCodec Example:")\n      avroSchema <- ZIO.fromEither(AvroSchemaCodec.encode(Person.schema))\n      _ <- ZIO.debug(s"The person schema in Avro Schema JSON format: $avroSchema")\n      avroSchemaBinary = Chunk.fromArray(avroSchema.getBytes)\n      zioSchema <- ZIO.fromEither(AvroSchemaCodec.decode(avroSchemaBinary))\n      _ <- ZIO.debug(s"The person schema in ZIO Schema GenericRecord format: $zioSchema")\n    } yield ()\n}\n')),(0,r.yg)("p",null,"The output:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'AvroSchemaCodec Example:\nThe person schema in Avro Schema JSON format: {"type":"record","name":"Person","fields":[{"name":"name","type":"string"},{"name":"age","type":"int"}]}\nThe person schema in ZIO Schema GenericRecord format: GenericRecord(Nominal(Chunk(),Chunk(),Person),Field(name,Primitive(string,Chunk())) :*: Field(age,Primitive(int,Chunk())) :*: Empty,Chunk(name(Person)))\n')),(0,r.yg)("p",null,"As we can see, we converted the ",(0,r.yg)("inlineCode",{parentName:"p"},"Schema[Person]")," to Avro schema JSON format, and then we converted it back to the ZIO Schema ",(0,r.yg)("inlineCode",{parentName:"p"},"GenericRecord")," format."),(0,r.yg)("h3",{id:"avrocodec"},"AvroCodec"),(0,r.yg)("p",null,"We can create a ",(0,r.yg)("inlineCode",{parentName:"p"},"BinaryCodec[A]")," for any type ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," that has a ",(0,r.yg)("inlineCode",{parentName:"p"},"Schema[A]")," instance using ",(0,r.yg)("inlineCode",{parentName:"p"},"AvroCodec.schemaBasedBinaryCodec"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"object AvroCodec {\n  implicit def schemaBasedBinaryCodec[A](implicit schema: Schema[A]): BinaryCodec[A] = ???\n}\n")),(0,r.yg)("p",null,"Now, let's write an example and see how it works:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.schema.Schema\nimport zio.schema.DeriveSchema\nimport zio.schema.codec.{AvroCodec, BinaryCodec}\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen\n  implicit val binaryCodec: BinaryCodec[Person] =\n    AvroCodec.schemaBasedBinaryCodec[Person]\n}\n\nobject Main extends ZIOAppDefault {\n  def run =\n    for {\n      _ <- ZIO.debug("AvroCodec Example:")\n      encodedPerson = Person.binaryCodec.encode(Person("John", 42))\n      _ <- ZIO.debug(s"encoded person object: ${toHex(encodedPerson)}")\n      decodedPerson <- ZIO.fromEither(\n        Person.binaryCodec.decode(encodedPerson)\n      )\n      _ <- ZIO.debug(s"decoded person object: $decodedPerson")\n    } yield ()\n\n  def toHex(bytes: Chunk[Byte]): String =\n    bytes.map("%02x".format(_)).mkString(" ")\n}\n')),(0,r.yg)("p",null,"The output:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"AvroCodec Example:\nencoded person object: 08 4a 6f 68 6e 54\ndecoded person object: Person(John,42)\n")),(0,r.yg)("h2",{id:"annotations"},"Annotations"),(0,r.yg)("p",null,"The Apache Avro specification supports some attributes for describing the data which are not part of the default ZIO Schema. To support these extra metadata, we can use annotations defined in the ",(0,r.yg)("inlineCode",{parentName:"p"},"zio.schema.codec.AvroAnnotations")," object."),(0,r.yg)("p",null,"There tons of annotations that we can use. Let's introduce some of them:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.name(name: String)"),": To change the name of a field or a record."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.namespace(namespace: String)"),": To add the namespace for a field or a record."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.doc(doc: String)"),": To add documentation to a field or a record."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.aliases(aliases: Set[String])"),": To add aliases to a field or a record."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.avroEnum"),": To treat a sealed trait as an Avro enum."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.scale(scale: Int = 24)")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.precision(precision: Int = 48)"),": To describe the scale and precision of a decimal field."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.decimal(decimalType: DecimalType)"),": Used to annotate a ",(0,r.yg)("inlineCode",{parentName:"li"},"BigInteger")," or ",(0,r.yg)("inlineCode",{parentName:"li"},"BigDecimal")," type to indicate the logical type encoding (avro bytes or avro fixed)."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.bytes(bytesType: BytesType)"),": Used to annotate a Byte type to indicate the avro type encoding (avro bytes or avro fixed)."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.formatToString"),": Used to annotate fields of type ",(0,r.yg)("inlineCode",{parentName:"li"},"LocalDate"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"LocalTime"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"LocalDateTime")," or ",(0,r.yg)("inlineCode",{parentName:"li"},"Instant")," in order to render them as a string using the given formatter instead of rendering them as avro logical types."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.timeprecision(timeprecisionType: TimePrecisionType)"),": Used to indicate the precision (millisecond precision or microsecond precision) of avro logical types ",(0,r.yg)("inlineCode",{parentName:"li"},"Time"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"Timestamp")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"Local timestamp")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.error"),": Used to annotate a record in order to render it as a avro error record"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"@AvroAnnotations.fieldOrder(fieldOrderType: FieldOrderType)"),": Used to indicate the avro field order of a record")),(0,r.yg)("p",null,"For example, to change the name of a field in the Avro schema, we can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"AvroAnnotations.name")," annotation:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.schema.Schema\nimport zio.schema.DeriveSchema\nimport zio.schema.codec.AvroAnnotations\n\n@AvroAnnotations.name("User")\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen\n}\n')),(0,r.yg)("p",null,"Now, if we generate the Avro schema for the ",(0,r.yg)("inlineCode",{parentName:"p"},"Person")," class, we will see that the name of the record is ",(0,r.yg)("inlineCode",{parentName:"p"},"User")," instead of ",(0,r.yg)("inlineCode",{parentName:"p"},"Person"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.schema.Schema\nimport zio.schema.DeriveSchema\nimport zio.schema.codec.AvroSchemaCodec\n\nobject Main extends ZIOAppDefault {\n  def run =\n    for {\n      _          <- ZIO.debug("AvroSchemaCodec Example with annotations:")\n      avroSchema <- ZIO.fromEither(AvroSchemaCodec.encode(Person.schema))\n      _ <- ZIO.debug(s"The person schema in Avro Schema JSON format: $avroSchema")\n    } yield ()\n}\n')),(0,r.yg)("p",null,"The output:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'The person schema in Avro Schema JSON format: {"type":"record","name":"User","fields":[{"name":"name","type":"string"},{"name":"age","type":{"type":"bytes","logicalType":"decimal","precision":48,"scale":24}}]}\n')))}p.isMDXComponent=!0}}]);