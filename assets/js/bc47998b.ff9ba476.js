"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[35937],{15680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>d});var a=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),g=r,d=u["".concat(l,".").concat(g)]||u[g]||m[g]||o;return n?a.createElement(d,s(s({ref:t},p),{},{components:n})):a.createElement(d,s({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},89443:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(58168),r=(n(96540),n(15680));const o={id:"recursion",title:"State Management Using Recursion",sidebar_label:"Recursion"},s=void 0,i={unversionedId:"reference/state-management/recursion",id:"reference/state-management/recursion",title:"State Management Using Recursion",description:"This is a very common pattern to use variables to keep track of the state. For example, to calculate the length of a list, we can store intermediate results inside the count variable:",source:"@site/docs/reference/state-management/state-management-using-recursion.md",sourceDirName:"reference/state-management",slug:"/reference/state-management/recursion",permalink:"/reference/state-management/recursion",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/state-management/state-management-using-recursion.md",tags:[],version:"current",frontMatter:{id:"recursion",title:"State Management Using Recursion",sidebar_label:"Recursion"},sidebar:"reference-sidebar",previous:{title:"Introduction to State Management in ZIO",permalink:"/reference/state-management/"},next:{title:"Global Shared State",permalink:"/reference/state-management/global-shared-state"}},l={},c=[],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.yg)(u,(0,a.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"This is a very common pattern to use variables to keep track of the state. For example, to calculate the length of a list, we can store intermediate results inside the ",(0,r.yg)("inlineCode",{parentName:"p"},"count")," variable:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"def length[T](list: List[T]): Int = {\n  var count = 0\n  for (_ <- list) count += 1\n  count\n}\n")),(0,r.yg)("p",null,"But in functional programming, we avoid using variables to keep track of the state. Instead, we use other techniques."),(0,r.yg)("p",null,"One common technique is to pass the new state as an argument to the next function. After we created a new version of the state, we pass it to the next function. We do this until we have reached the final state."),(0,r.yg)("p",null,"Assume we have the following code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"var state = 5\nstate = state + 1\nstate = state * 2\nstate = state * state\n\nprintln(state)\n// Output: 144\n")),(0,r.yg)("p",null,"We can rewrite it as a series of transformations, in which new states are passed to the next function:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"def foo(state: Int): Int = bar(state + 1)\ndef bar(state: Int): Int = baz(state * 2)\ndef baz(state: Int): Int = state * state\n\nprintln(foo(5)) \n// 144\n// Output: 144\n")),(0,r.yg)("p",null,"Now, what if we wanted to apply the transformation multiple times to a given state? We can combine this technique with recursive functions and call the function multiple times."),(0,r.yg)("p",null,"For example, we use function arguments to pass the state to the next function, using recursive calls. Assume we have a ",(0,r.yg)("inlineCode",{parentName:"p"},"length")," function that returns the length of a list as below:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"def length[T](list: List[T]): Int = {\n  var count = 0\n  for (_ <- list) count += 1\n  count\n}\n")),(0,r.yg)("p",null,"If we want to convert the above function to a series of state transformations, first, we need to diagnose what is the state?"),(0,r.yg)("p",null,"One obvious answer is the ",(0,r.yg)("inlineCode",{parentName:"p"},"count")," variable. The ",(0,r.yg)("inlineCode",{parentName:"p"},"count")," variable is the state of the above function that keeps track of the length of the list. Another non-obvious state is the remainder of the list that is not yet processed during the list traversal."),(0,r.yg)("p",null,"So we can model the state composed of the ",(0,r.yg)("inlineCode",{parentName:"p"},"count")," and the ",(0,r.yg)("inlineCode",{parentName:"p"},"remainder")," of the list:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"case class State[T](count: Int, remainder: List[T])\n")),(0,r.yg)("p",null,"Now we are ready to write the state transformation function called ",(0,r.yg)("inlineCode",{parentName:"p"},"loop")," as below:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"case class State[T](count: Int, remainder: List[T])\n\ndef loop[T](state: State[T]): State[T] = {\n  state.remainder match {\n    case Nil => state\n    case _ :: tail => loop(State(state.count + 1, tail))\n  }\n}\n")),(0,r.yg)("p",null,"Here are series of ",(0,r.yg)("inlineCode",{parentName:"p"},"loop")," calls, when we call it with the ",(0,r.yg)("inlineCode",{parentName:"p"},'State(0, List("a", "b", "c", "d"))')," state:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'loop(State(0, List("a", "b", "c", "d")))\nloop(State(1, List("b", "c", "d")))\nloop(State(2, List("c", "d")))\nloop(State(3, List("d")))\nloop(State(4, List()))\n// Output:\n// State(4, List())\n')),(0,r.yg)("p",null,"Let's do some small modification to the ",(0,r.yg)("inlineCode",{parentName:"p"},"loop")," function and use it inside the ",(0,r.yg)("inlineCode",{parentName:"p"},"length")," function:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"def length[T](list: List[T]): Int = {\n  def loop(list: List[T], count: Int): Int = {\n    list match {\n      case Nil => count\n      case _ :: tail => loop(tail, count + 1)\n    }\n  }\n\n  loop(list, 0)\n}\n")),(0,r.yg)("p",null,'The same pattern can be used when we have side effects. Assume we have a function that tries to read names from the input, until the user enters the "q" command indicating the end of the input. We can write the function like this:'),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import scala.io.StdIn._\n\ndef getNames: List[String] = {\n  def getName() = readLine("Please enter a name or \'q\' to exit: ")\n  var names = List.empty[String]\n  var input = getName()\n  while (input != "q") {\n    names = names appended input\n    input = getName()\n  }\n  names\n}\n')),(0,r.yg)("p",null,"Using the previous pattern, we can eliminate the need to use variables:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import scala.io.StdIn._\n\ndef getNames: Seq[String] = {\n  def loop(names: List[String]): List[String] = {\n    val name = readLine("Please enter a name or \'q\' to exit: ")\n    if (name == "q") names else loop(names appended name)\n  }\n  loop(List.empty[String])\n}\n')),(0,r.yg)("p",null,"But, there is also a problem with the previous solution. The ",(0,r.yg)("inlineCode",{parentName:"p"},"getName")," is not referentially transparent. In order to make it free of side effects, we can use ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," to describe any effectual operation:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef inputNames: ZIO[Any, String, List[String]] = {\n  def loop(names: List[String]): ZIO[Any, String, List[String]] = {\n    Console.readLine("Please enter a name or `q` to exit: ").orDie.flatMap {\n      case "q" =>\n        ZIO.succeed(names)\n      case name =>\n        loop(names appended name)\n    }\n  }\n\n  loop(List.empty[String])\n}\n')),(0,r.yg)("p",null,"On this page, we have learned how to have stateful computations in our programs using recursion. However, this approach is not suitable for concurrent programs, where multiple fibers want to change the state of the program concurrently. Let's move on to the next page, where we will discuss stateful computation over concurrent programs."))}m.isMDXComponent=!0}}]);