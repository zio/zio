"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[6387],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=l(n),d=a,g=u["".concat(s,".").concat(d)]||u[d]||m[d]||i;return n?r.createElement(g,o(o({ref:t},c),{},{components:n})):r.createElement(g,o({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},53721:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const i={id:"zio-telemetry",title:"ZIO Telemetry"},o=void 0,p={unversionedId:"resources/ecosystem/officials/zio-telemetry",id:"resources/ecosystem/officials/zio-telemetry",title:"ZIO Telemetry",description:"ZIO telemetry is purely-functional and type-safe. It provides clients for OpenTracing and OpenTelemetry.",source:"@site/docs/resources/ecosystem/officials/zio-telemetry.md",sourceDirName:"resources/ecosystem/officials",slug:"/resources/ecosystem/officials/zio-telemetry",permalink:"/resources/ecosystem/officials/zio-telemetry",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/resources/ecosystem/officials/zio-telemetry.md",tags:[],version:"current",frontMatter:{id:"zio-telemetry",title:"ZIO Telemetry"},sidebar:"resources-sidebar",previous:{title:"ZIO SQS",permalink:"/resources/ecosystem/officials/zio-sqs"},next:{title:"ZIO ZMX",permalink:"/resources/ecosystem/officials/zio-zmx"}},s={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Example",id:"example",level:2},{value:"Articles",id:"articles",level:2}],c={toc:l};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/zio/zio-telemetry"},"ZIO telemetry")," is purely-functional and type-safe. It provides clients for OpenTracing and OpenTelemetry."),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"In monolithic architecture, everything is in one place, and we know when a request starts and then how it goes through the components and when it finishes. We can obviously see what is happening with our request and where is it going. But, in distributed systems like microservice architecture, we cannot find out the story of a request through various services easily. This is where distributed tracing comes into play."),(0,a.kt)("p",null,"ZIO Telemetry is a purely functional client which helps up propagate context between services in a distributed environment."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,a.kt)("inlineCode",{parentName:"p"},"build.sbt")," file if we want to use ",(0,a.kt)("a",{parentName:"p",href:"https://opentelemetry.io/"},"OpenTelemetry")," client:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-telemetry" % "0.8.1"\n')),(0,a.kt)("p",null,"And for using ",(0,a.kt)("a",{parentName:"p",href:"https://opentracing.io/"},"OpenTracing")," client we should add the following line in our ",(0,a.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-opentracing" % "0.8.1"\n')),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"In this example, we create two services, ",(0,a.kt)("inlineCode",{parentName:"p"},"ProxyServer")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"BackendServer"),". When we call ProxyServer, the BackendServer will be called."),(0,a.kt)("p",null,"Note that we are going to use ",(0,a.kt)("em",{parentName:"p"},"OpenTracing")," client for this example."),(0,a.kt)("p",null,"Here is a simplified diagram of our services:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"                               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                               \u2502                \u2502\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 Jaeger Backend \u2502\u25c4\u2500\u2500\u2500\u2500\u2510\n                        \u2502      \u2502                \u2502     \u2502\n           Tracing Data \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502 Tracing Data\n                        \u2502                             \u2502\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u2502                  \u2502         \u2502                  \u2502\nUser Request\u2500\u2500\u25ba\u2502   Proxy Server   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba|  Backend Server  \u2502\n               \u2502                  \u2502         \u2502                  \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,a.kt)("p",null,"First of all we should add following dependencies to our ",(0,a.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'object Versions {\n  val http4s         = "0.21.24"\n  val jaeger         = "1.6.0"\n  val sttp           = "2.2.9"\n  val opentracing    = "0.33.0"\n  val opentelemetry  = "1.4.1"\n  val opencensus     = "0.28.3"\n  val zipkin         = "2.16.3"\n  val zio            = "1.0.9"\n  val zioInteropCats = "2.5.1.0"\n}\n\nlazy val openTracingExample = Seq(\n  "org.typelevel"                %% "cats-core"                     % "2.6.1",\n  "io.circe"                     %% "circe-generic"                 % "0.14.1",\n  "org.http4s"                   %% "http4s-core"                   % Versions.http4s,\n  "org.http4s"                   %% "http4s-blaze-server"           % Versions.http4s,\n  "org.http4s"                   %% "http4s-dsl"                    % Versions.http4s,\n  "org.http4s"                   %% "http4s-circe"                  % Versions.http4s,\n  "io.jaegertracing"              % "jaeger-core"                   % Versions.jaeger,\n  "io.jaegertracing"              % "jaeger-client"                 % Versions.jaeger,\n  "io.jaegertracing"              % "jaeger-zipkin"                 % Versions.jaeger,\n  "com.github.pureconfig"        %% "pureconfig"                    % "0.16.0",\n  "com.softwaremill.sttp.client" %% "async-http-client-backend-zio" % Versions.sttp,\n  "com.softwaremill.sttp.client" %% "circe"                         % Versions.sttp,\n  "dev.zio"                      %% "zio-interop-cats"              % Versions.zioInteropCats,\n  "io.zipkin.reporter2"           % "zipkin-reporter"               % Versions.zipkin,\n  "io.zipkin.reporter2"           % "zipkin-sender-okhttp3"         % Versions.zipkin\n)\n')),(0,a.kt)("p",null,"Let's create a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZLayer")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"OpenTracing")," which provides us Jaeger tracer. Each microservice uses this dependency to send its tracing data to the ",(0,a.kt)("em",{parentName:"p"},"Jaeger Backend"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import io.jaegertracing.Configuration\nimport io.jaegertracing.internal.samplers.ConstSampler\nimport io.jaegertracing.zipkin.ZipkinV2Reporter\nimport org.apache.http.client.utils.URIBuilder\nimport zio.ZLayer\nimport zio.clock.Clock\nimport zio.telemetry.opentracing.OpenTracing\nimport zipkin2.reporter.AsyncReporter\nimport zipkin2.reporter.okhttp3.OkHttpSender\n\nobject JaegerTracer {\n  def makeJaegerTracer(host: String, serviceName: String): ZLayer[Clock, Throwable, Clock with OpenTracing] =\n    OpenTracing.live(new Configuration(serviceName)\n      .getTracerBuilder\n      .withSampler(new ConstSampler(true))\n      .withReporter(\n        new ZipkinV2Reporter(\n          AsyncReporter.create(\n            OkHttpSender.newBuilder\n              .compressionEnabled(true)\n              .endpoint(\n                new URIBuilder()\n                  .setScheme("http")\n                  .setHost(host)\n                  .setPath("/api/v2/spans")\n                  .build.toString\n              )\n              .build\n          )\n        )\n      )\n      .build\n    ) ++ Clock.live\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"BackendServer"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import io.opentracing.propagation.Format.Builtin.{HTTP_HEADERS => HttpHeadersFormat}\nimport io.opentracing.propagation.TextMapAdapter\nimport org.http4s._\nimport org.http4s.dsl.Http4sDsl\nimport org.http4s.server.Router\nimport org.http4s.server.blaze.BlazeServerBuilder\nimport org.http4s.syntax.kleisli._\nimport zio.clock.Clock\nimport zio.interop.catz._\nimport zio.telemetry.opentracing._\nimport JaegerTracer.makeJaegerTracer\nimport zio.{ExitCode, ZEnv, ZIO}\n\nimport scala.jdk.CollectionConverters._\n\nobject BackendServer extends CatsApp {\n  type AppTask[A] = ZIO[Clock, Throwable, A]\n\n  val dsl: Http4sDsl[AppTask] = Http4sDsl[AppTask]\n  import dsl._\n\n  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] =\n    ZIO.runtime[Clock].flatMap { implicit runtime =>\n      BlazeServerBuilder[AppTask](runtime.platform.executor.asEC)\n        .bindHttp(port = 9000, host = "0.0.0.0")\n        .withHttpApp(\n          Router[AppTask](mappings = "/" ->\n            HttpRoutes.of[AppTask] { case request@GET -> Root =>\n              ZIO.unit\n                .spanFrom(\n                  format = HttpHeadersFormat,\n                  carrier = new TextMapAdapter(request.headers.toList.map(h => h.name.value -> h.value).toMap.asJava),\n                  operation = "GET /"\n                )\n                .provide(makeJaegerTracer(host = "0.0.0.0:9411", serviceName = "backend-service")) *> Ok("Ok!")\n            }\n          ).orNotFound\n        )\n        .serve\n        .compile\n        .drain\n    }.exitCode\n}\n')),(0,a.kt)("p",null,"And the ",(0,a.kt)("em",{parentName:"p"},"ProxyServer")," which calls the ",(0,a.kt)("em",{parentName:"p"},"BackendServer"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.{ExitCode => catsExitCode}\nimport io.opentracing.propagation.Format.Builtin.{HTTP_HEADERS => HttpHeadersFormat}\nimport io.opentracing.propagation.TextMapAdapter\nimport io.opentracing.tag.Tags\nimport org.http4s.HttpRoutes\nimport org.http4s.dsl.Http4sDsl\nimport org.http4s.server.Router\nimport org.http4s.server.blaze.BlazeServerBuilder\nimport org.http4s.syntax.kleisli._\nimport sttp.client.asynchttpclient.zio.AsyncHttpClientZioBackend\nimport sttp.client.basicRequest\nimport sttp.model.Uri\nimport zio.clock.Clock\nimport zio.interop.catz._\nimport zio.telemetry.opentracing.OpenTracing\nimport JaegerTracer.makeJaegerTracer\nimport zio.{ExitCode, UIO, ZEnv, ZIO}\n\nimport scala.collection.mutable\nimport scala.jdk.CollectionConverters._\n\nobject ProxyServer extends CatsApp {\n\n  type AppTask[A] = ZIO[Clock, Throwable, A]\n\n  private val backend = AsyncHttpClientZioBackend()\n\n  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] =\n    ZIO.runtime[Clock].flatMap { implicit runtime =>\n      implicit val ec = runtime.platform.executor.asEC\n      BlazeServerBuilder[AppTask](ec)\n        .bindHttp(port = 8080, host = "0.0.0.0")\n        .withHttpApp(\n          Router[AppTask](mappings = "/" -> {\n            val dsl: Http4sDsl[AppTask] = Http4sDsl[AppTask]\n            import dsl._\n\n            HttpRoutes.of[AppTask] { case GET -> Root =>\n              (for {\n                _ <- OpenTracing.tag(Tags.SPAN_KIND.getKey, Tags.SPAN_KIND_CLIENT)\n                _ <- OpenTracing.tag(Tags.HTTP_METHOD.getKey, GET.name)\n                _ <- OpenTracing.setBaggageItem("proxy-baggage-item-key", "proxy-baggage-item-value")\n                buffer = new TextMapAdapter(mutable.Map.empty[String, String].asJava)\n                _ <- OpenTracing.provide(HttpHeadersFormat, buffer)\n                headers <- extractHeaders(buffer)\n                res <-\n                  backend.flatMap { implicit backend =>\n                    basicRequest.get(Uri("0.0.0.0", 9000).path("/")).headers(headers).send()\n                  }.map(_.body)\n                    .flatMap {\n                      case Right(_) => Ok("Ok!")\n                      case Left(_) => Ok("Oops!")\n                    }\n              } yield res)\n                .root(operation = "GET /")\n                .provide(\n                  makeJaegerTracer(host = "0.0.0.0:9411", serviceName = "proxy-server")\n                )\n            }\n          }).orNotFound\n        )\n        .serve\n        .compile[AppTask, AppTask, catsExitCode]\n        .drain\n        .as(ExitCode.success)\n    }.exitCode\n\n  private def extractHeaders(adapter: TextMapAdapter): UIO[Map[String, String]] = {\n    val m = mutable.Map.empty[String, String]\n    UIO(adapter.forEach { entry =>\n      m.put(entry.getKey, entry.getValue)\n      ()\n    }).as(m.toMap)\n  }\n\n}\n')),(0,a.kt)("p",null,"First, we run the following command to start Jaeger backend:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -d --name jaeger \\\n  -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\\n  -p 5775:5775/udp \\\n  -p 6831:6831/udp \\\n  -p 6832:6832/udp \\\n  -p 5778:5778 \\\n  -p 16686:16686 \\\n  -p 14268:14268 \\\n  -p 9411:9411 \\\n  jaegertracing/all-in-one:1.6\n")),(0,a.kt)("p",null,"It's time to run Backend and Proxy servers. After starting these two, we can start calling ",(0,a.kt)("inlineCode",{parentName:"p"},"ProxyServer"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"curl -X GET http://0.0.0.0:8080/\n")),(0,a.kt)("p",null,"Now we can check the Jaeger service (http://localhost:16686/) to see the result."),(0,a.kt)("h2",{id:"articles"},"Articles"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://kadek-marek.medium.com/trace-your-microservices-with-zio-telemetry-5f88d69cb26b"},"Trace your microservices with ZIO")," by Marek Kadek (September 2021)")))}m.isMDXComponent=!0}}]);