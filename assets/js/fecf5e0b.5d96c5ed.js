"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[39059],{15680:(e,n,a)=>{a.d(n,{xA:()=>p,yg:()=>g});var r=a(96540);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var c=r.createContext({}),s=function(e){var n=r.useContext(c),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},p=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var a=e.components,t=e.mdxType,l=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=s(a),f=t,g=u["".concat(c,".").concat(f)]||u[f]||d[f]||l;return a?r.createElement(g,o(o({ref:n},p),{},{components:a})):r.createElement(g,o({ref:n},p))}));function g(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var l=a.length,o=new Array(l);o[0]=f;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[u]="string"==typeof e?e:t,o[1]=i;for(var s=2;s<l;s++)o[s]=a[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}f.displayName="MDXCreateElement"},54633:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var r=a(58168),t=(a(96540),a(15680));const l={id:"folding",title:"Folding",sidebar_label:"3. Folding"},o=void 0,i={unversionedId:"reference/error-management/recovering/folding",id:"reference/error-management/recovering/folding",title:"Folding",description:"Scala's Option and Either data types have fold, which let us handle both failure and success at the same time. In a similar fashion, ZIO effects also have several methods that allow us to handle both failure and success.",source:"@site/docs/reference/error-management/recovering/folding.md",sourceDirName:"reference/error-management/recovering",slug:"/reference/error-management/recovering/folding",permalink:"/reference/error-management/recovering/folding",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/recovering/folding.md",tags:[],version:"current",frontMatter:{id:"folding",title:"Folding",sidebar_label:"3. Folding"},sidebar:"reference-sidebar",previous:{title:"2. Fallback",permalink:"/reference/error-management/recovering/fallback"},next:{title:"4. Retrying",permalink:"/reference/error-management/recovering/retrying"}},c={},s=[{value:"<code>ZIO#fold</code>/<code>ZIO#foldZIO</code>",id:"ziofoldziofoldzio",level:2},{value:"<code>ZIO#foldCause</code>/<code>ZIO#foldCauseZIO</code>",id:"ziofoldcauseziofoldcausezio",level:2},{value:"<code>ZIO#foldTraceZIO</code>",id:"ziofoldtracezio",level:2}],p={toc:s},u="wrapper";function d(e){let{components:n,...a}=e;return(0,t.yg)(u,(0,r.A)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("p",null,"Scala's ",(0,t.yg)("inlineCode",{parentName:"p"},"Option")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"Either")," data types have ",(0,t.yg)("inlineCode",{parentName:"p"},"fold"),", which let us handle both failure and success at the same time. In a similar fashion, ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO")," effects also have several methods that allow us to handle both failure and success."),(0,t.yg)("h2",{id:"ziofoldziofoldzio"},(0,t.yg)("inlineCode",{parentName:"h2"},"ZIO#fold"),"/",(0,t.yg)("inlineCode",{parentName:"h2"},"ZIO#foldZIO")),(0,t.yg)("p",null,"The first fold method, ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO#fold"),", lets us non-effectfully handle both failure and success, by supplying a non-effectful handler for each case. The second fold method, ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO#foldZIO"),", lets us effectfully handle both failure and success, by supplying an effectful (but still pure) handler for each case:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def fold[B](\n    failure: E => B,\n    success: A => B\n  ): ZIO[R, Nothing, B]\n\n  def foldZIO[R1 <: R, E2, B](\n    failure: E => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  ): ZIO[R1, E2, B]\n}\n")),(0,t.yg)("p",null,"Let's try an example:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nlazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: UIO[Array[Byte]] =\n  readFile("primary.data").fold(_ => DefaultData, data => data)\n')),(0,t.yg)("p",null,"We can ignore any failure and success values:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: ZIO[Any, Nothing, Unit] =\n  ZIO\n    .fail("Uh oh!")         // ZIO[Any, String, Int]\n    .as(5)                  // ZIO[Any, String, Int]\n    .fold(_ => (), _ => ()) // ZIO[Any, Nothing, Unit]\n')),(0,t.yg)("p",null,"It is equivalent to use the ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO#ignore")," operator instead:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: ZIO[Any, Nothing, Unit] = ZIO.fail("Uh oh!").as(5).ignore\n')),(0,t.yg)("p",null,"Now let's try the effectful version of the fold operation. In this example, in case of failure on reading from the primary file, we will fallback to another effectful operation which will read data from the secondary file:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'val primaryOrSecondaryData: IO[IOException, Array[Byte]] =\n  readFile("primary.data").foldZIO(\n    failure = _    => readFile("secondary.data"),\n    success = data => ZIO.succeed(data)\n  )\n')),(0,t.yg)("p",null,"Nearly all error handling methods are defined in terms of ",(0,t.yg)("inlineCode",{parentName:"p"},"foldZIO"),", because it is both powerful and fast."),(0,t.yg)("p",null,"In the following example, ",(0,t.yg)("inlineCode",{parentName:"p"},"foldZIO")," is used to handle both failure and success of the ",(0,t.yg)("inlineCode",{parentName:"p"},"readUrls")," method:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'val urls: UIO[Content] =\n  readUrls("urls.json").foldZIO(\n    error   => ZIO.succeed(NoContent(error)),\n    success => fetchContent(success)\n  )\n')),(0,t.yg)("p",null,"It's important to note that both ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO#fold")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO#foldZIO")," operators cannot catch fiber interruptions. So the following application will crash due to ",(0,t.yg)("inlineCode",{parentName:"p"},"InterruptedException"),":"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = (ZIO.interrupt *> ZIO.fail("Uh oh!")).fold(_ => (), _ => ())\n}\n')),(0,t.yg)("p",null,"And here is the output:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-02-24T13:41:01.696273024Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.InterruptedException: Interrupted by thread "zio-fiber-"\n   at <empty>.MainApp.run(MainApp.scala:4)"\n')),(0,t.yg)("h2",{id:"ziofoldcauseziofoldcausezio"},(0,t.yg)("inlineCode",{parentName:"h2"},"ZIO#foldCause"),"/",(0,t.yg)("inlineCode",{parentName:"h2"},"ZIO#foldCauseZIO")),(0,t.yg)("p",null,"This cause version of the ",(0,t.yg)("inlineCode",{parentName:"p"},"fold")," operator is useful to access the full cause of the underlying fiber. So in case of failure, based on the exact cause, we can determine what to do:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def foldCause[B](\n    failure: Cause[E] => B,\n    success: A => B\n  ): ZIO[R, Nothing, B]\n\n  def foldCauseZIO[R1 <: R, E2, B](\n    failure: Cause[E] => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  ): ZIO[R1, E2, B]\n}\n")),(0,t.yg)("p",null,"Among the fold operators, these are the most powerful combinators. They can recover from any error, even fiber interruptions."),(0,t.yg)("p",null,"In the following example, we are printing the proper message according to what cause occurred due to failure:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval exceptionalEffect: ZIO[Any, Throwable, Unit] = ???\n\nval myApp: ZIO[Any, IOException, Unit] =\n  exceptionalEffect.foldCauseZIO(\n    failure = {\n      case Cause.Fail(value, _)        => Console.printLine(s"failure: $value")\n      case Cause.Die(value, _)         => Console.printLine(s"cause: $value")\n      case Cause.Interrupt(failure, _) => Console.printLine(s"${failure.threadName} interrupted!")\n      case _                           => Console.printLine("failed due to other causes")\n    },\n    success = succeed => Console.printLine(s"succeeded with $succeed value")\n  )\n')),(0,t.yg)("p",null,"When catching errors using this operator, if our cases were not exhaustive, we may receive a defect of the type ",(0,t.yg)("inlineCode",{parentName:"p"},"scala.MatchError")," :"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val exceptionalEffect: ZIO[Any, Throwable, Unit] = ZIO.interrupt\n\n  val myApp: ZIO[Any, IOException, Unit] =\n    exceptionalEffect.foldCauseZIO(\n      failure = {\n        case Cause.Fail(value, _) => ZIO.debug(s"failure: $value")\n        case Cause.Die(value, _) => ZIO.debug(s"cause: ${value.toString}")\n        // case Cause.Interrupt(failure, _) => ZIO.debug(s"${failure.threadName} interrupted!")\n      },\n      success = succeed => ZIO.debug(s"succeeded with $succeed value")\n    )\n\n  def run = myApp\n}\n')),(0,t.yg)("p",null,"The output:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-02-24T11:05:40.241436257Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" scala.MatchError: Interrupt(Runtime(2,1645700739),Trace(Runtime(2,1645700739),Chunk(<empty>.MainApp.exceptionalEffect(MainApp.scala:6),<empty>.MainApp.myApp(MainApp.scala:9)))) (of class zio.Cause$Interrupt)\n    at MainApp$.$anonfun$myApp$1(MainApp.scala:10)\n    at zio.ZIO$TracedCont$$anon$33.apply(ZIO.scala:6167)\n    at zio.ZIO$TracedCont$$anon$33.apply(ZIO.scala:6165)\n    at zio.internal.FiberContext.runUntil(FiberContext.scala:885)\n    at zio.internal.FiberContext.run(FiberContext.scala:115)\n    at zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\n    at zio.internal.FiberContext.runUntil(FiberContext.scala:538)"\n')),(0,t.yg)("h2",{id:"ziofoldtracezio"},(0,t.yg)("inlineCode",{parentName:"h2"},"ZIO#foldTraceZIO")),(0,t.yg)("p",null,"This version of fold, provide us the facility to access the trace info of the failure:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def foldTraceZIO[R1 <: R, E2, B](\n    failure: ((E, Trace)) => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  )(implicit ev: CanFail[E]): ZIO[R1, E2, B]\n}\n")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: ZIO[Any, Nothing, Int] =\n  validate(5).foldTraceZIO(\n    failure = {\n      case (_: NegativeAgeException, trace) =>\n        ZIO.succeed(0).debug(\n          "The entered age is negative\\n" +\n            s"trace info: ${trace.stackTrace.mkString("\\n")}"\n        )\n      case (_: IllegalAgeException, trace) =>\n        ZIO.succeed(0).debug(\n          "The entered age in not legal\\n" +\n            s"trace info: ${trace.stackTrace.mkString("\\n")}"\n        )\n    },\n    success = s => ZIO.succeed(s)\n  )\n')),(0,t.yg)("p",null,"Note that similar to ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO#fold")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO#foldZIO")," this operator cannot recover from fiber interruptions."))}d.isMDXComponent=!0}}]);