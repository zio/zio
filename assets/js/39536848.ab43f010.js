"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[44525],{15680:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>h});var a=t(96540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(t),g=r,h=c["".concat(l,".").concat(g)]||c[g]||u[g]||i;return t?a.createElement(h,s(s({ref:n},d),{},{components:t})):a.createElement(h,s({ref:n},d))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=g;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[c]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},85082:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(58168),r=(t(96540),t(15680));const i={id:"handler_aspect",title:"HandlerAspect"},s=void 0,o={unversionedId:"zio-http/reference/aop/handler_aspect",id:"zio-http/reference/aop/handler_aspect",title:"HandlerAspect",description:"A HandlerAspect is a wrapper around ProtocolStack with the two following features:",source:"@site/docs/zio-http/reference/aop/handler_aspect.md",sourceDirName:"zio-http/reference/aop",slug:"/zio-http/reference/aop/handler_aspect",permalink:"/zio-http/reference/aop/handler_aspect",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/aop/handler_aspect.md",tags:[],version:"current",frontMatter:{id:"handler_aspect",title:"HandlerAspect"},sidebar:"ecosystem-sidebar",previous:{title:"Middleware",permalink:"/zio-http/reference/aop/middleware"},next:{title:"Socket",permalink:"/zio-http/reference/socket/"}},l={},p=[{value:"Creating a HandlerAspect",id:"creating-a-handleraspect",level:2},{value:"Built-in Handler Aspects",id:"built-in-handler-aspects",level:2},{value:"Intercepting",id:"intercepting",level:2},{value:"Intercepting the Incoming Requests",id:"intercepting-the-incoming-requests",level:3},{value:"Intercepting the Outgoing Responses",id:"intercepting-the-outgoing-responses",level:3},{value:"Intercepting Both Incoming Requests and Outgoing Responses",id:"intercepting-both-incoming-requests-and-outgoing-responses",level:3},{value:"Intercepting Statefully",id:"intercepting-statefully",level:3},{value:"Intercepting Statefully (Patching Responses)",id:"intercepting-statefully-patching-responses",level:3},{value:"Leveraging Output Context",id:"leveraging-output-context",level:2},{value:"Session Example",id:"session-example",level:3},{value:"Custom Authentication Example",id:"custom-authentication-example",level:3},{value:"Authentication Handler Aspects",id:"authentication-handler-aspects",level:2},{value:"Basic Authentication Example",id:"basic-authentication-example",level:3},{value:"Failing HandlerAspects",id:"failing-handleraspects",level:2},{value:"Updating Requests and Responses",id:"updating-requests-and-responses",level:2},{value:"Access Control HandlerAspects",id:"access-control-handleraspects",level:2},{value:"Cookie Operations",id:"cookie-operations",level:2},{value:"Conditional Application of HandlerAspects",id:"conditional-application-of-handleraspects",level:2},{value:"Request Logging Handler Aspect",id:"request-logging-handler-aspect",level:2},{value:"Running Effect Before/After Every Request",id:"running-effect-beforeafter-every-request",level:2},{value:"Redirect Handler Aspect",id:"redirect-handler-aspect",level:2},{value:"Trailing Slash Handler Aspect",id:"trailing-slash-handler-aspect",level:2},{value:"Patching Response Handler Aspect",id:"patching-response-handler-aspect",level:2},{value:"Beautify Errors Handler Aspect",id:"beautify-errors-handler-aspect",level:2},{value:"Debug Handler Aspect",id:"debug-handler-aspect",level:2},{value:"Examples",id:"examples",level:2},{value:"A Simple Middleware Example",id:"a-simple-middleware-example",level:3},{value:"Endpoint Middleware Example",id:"endpoint-middleware-example",level:3}],d={toc:p},c="wrapper";function u(e){let{components:n,...i}=e;return(0,r.yg)(c,(0,a.A)({},d,i,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"A ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," is a wrapper around ",(0,r.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," with the two following features:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"It is a ",(0,r.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," that only works with ",(0,r.yg)("inlineCode",{parentName:"p"},"Request")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"Response")," types. So it is suitable for writing middleware in the context of HTTP protocol. So it can almost be thought of (not the same) as a ",(0,r.yg)("inlineCode",{parentName:"p"},"ProtocolStack[Env, Request, Request, Response, Response]]"),".")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"It is specialized to work with an output context ",(0,r.yg)("inlineCode",{parentName:"p"},"CtxOut")," that can be passed through the middleware stack. This allows each layer to add its output context to the transformation process. So the ",(0,r.yg)("inlineCode",{parentName:"p"},"CtxOut")," will be a tuple of all the output contexts that each layer in the stack has added. These output contexts are useful when we are writing middleware that needs to pass some information, which is the result of some computation based on the input request, to the handler that is at the end of the middleware stack."))),(0,r.yg)("p",null,"The diagram below illustrates how ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," works:"),(0,r.yg)("div",{style:{textAlign:"center",margin:"10px"}},(0,r.yg)("p",null,(0,r.yg)("img",{alt:"HandlerAspect Diagram",src:t(48677).A}))),(0,r.yg)("p",null,"Now, we are ready to see the definition of ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"final case class HandlerAspect[-Env, +CtxOut](\n  protocol: ProtocolStack[Env, Request, (Request, CtxOut), Response, Response]\n) extends Middleware[Env] {\n    def apply[Env1 <: Env, Err](routes: Routes[Env1, Err]): Routes[Env1, Err] = ???\n}\n")),(0,r.yg)("p",null,"Like the ",(0,r.yg)("inlineCode",{parentName:"p"},"ProtocolStack"),", the ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," is a stack of layers. When we compose two ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," using the ",(0,r.yg)("inlineCode",{parentName:"p"},"++")," operator, we are composing handler aspects sequentially. So each layer in the stack corresponds to a separate transformation."),(0,r.yg)("p",null,"Similar to the ",(0,r.yg)("inlineCode",{parentName:"p"},"ProtocolStack"),", each layer in the ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," may also be stateful at the level of each transformation. So, for example, a layer that is timing request durations may capture the start time of the request in the incoming interceptor, and pass this state to the outgoing interceptor, which can then compute the duration."),(0,r.yg)("h2",{id:"creating-a-handleraspect"},"Creating a HandlerAspect"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),"'s companion object provides many methods to create a ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),". But in this section, we are going to introduce the most basic ones that are used as a building block to create a more complex ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),"."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.identity")," is the simplest ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," that does nothing. It is useful when you want to create a ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," that does not modify the request or response."),(0,r.yg)("p",null,"After this simple ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),", let's dive into the ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.intercept*")," constructors. Using these, we can create a ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," that can intercept the incoming request, outgoing response, or both."),(0,r.yg)("h2",{id:"built-in-handler-aspects"},"Built-in Handler Aspects"),(0,r.yg)("p",null,"ZIO HTTP offers a versatile set of built-in handler aspects, designed to enhance and customize the handling of HTTP requests and responses. These aspects can be easily integrated into our application to provide various functionalities. For the rest of this page, we will explore how to use them in our applications."),(0,r.yg)("h2",{id:"intercepting"},"Intercepting"),(0,r.yg)("h3",{id:"intercepting-the-incoming-requests"},"Intercepting the Incoming Requests"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.interceptIncomingHandler")," constructor takes a handler function and applies it to the incoming request. It is useful when we want to modify or access the request before it reaches the handler or the next layer in the stack."),(0,r.yg)("p",null,"Let's see an example of how to use this constructor to create a handler aspect that checks the IP address of the incoming request and allows only the whitelisted IP addresses to access the server:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\n\nval whitelistMiddleware: HandlerAspect[Any, Unit] =\n  HandlerAspect.interceptIncomingHandler {\n    val whitelist = Set("127.0.0.1", "0.0.0.0")\n    Handler.fromFunctionZIO[Request] { request =>\n      request.headers.get("X-Real-IP") match {\n        case Some(host) if whitelist.contains(host) =>\n          ZIO.succeed((request, ()))\n        case _ =>\n          ZIO.fail(Response.forbidden("Your IP is banned from accessing the server."))\n      }\n    }\n  }\n')),(0,r.yg)("h3",{id:"intercepting-the-outgoing-responses"},"Intercepting the Outgoing Responses"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.interceptOutgoingHandler")," constructor takes a handler function and applies it to the outgoing response. It is useful when we want to modify or access the response before it reaches the client or the next layer in the stack."),(0,r.yg)("p",null,"Let's work on creating a handler aspect that adds a custom header to the response:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\n\nval addCustomHeader: HandlerAspect[Any, Unit] =\n  HandlerAspect.interceptOutgoingHandler(\n    Handler.fromFunction[Response](_.addHeader("X-Custom-Header", "Hello from Custom Middleware!")),\n  )\n')),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"interceptOutgoingHandler")," takes a handler function that receives a ",(0,r.yg)("inlineCode",{parentName:"p"},"Response")," and returns a ",(0,r.yg)("inlineCode",{parentName:"p"},"Response"),". This is simpler than the ",(0,r.yg)("inlineCode",{parentName:"p"},"interceptIncomingHandler")," as it does not necessitate the output context to be passed along with the response."),(0,r.yg)("h3",{id:"intercepting-both-incoming-requests-and-outgoing-responses"},"Intercepting Both Incoming Requests and Outgoing Responses"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.interceptHandler")," takes two handler functions, one for the incoming request and one for the outgoing response."),(0,r.yg)("p",null,"In the following example, we are going to create a handler aspect that counts the number of incoming requests and outgoing responses and stores them in a ",(0,r.yg)("inlineCode",{parentName:"p"},"Ref")," inside the ZIO environment:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\n\ndef inc(label: String) =\n  for {\n    counter <- ZIO.service[Ref[Map[String, Long]]]\n    _ <- counter.update(_.updatedWith(label) {\n      case Some(current) => Some(current + 1)\n      case None => Some(1)\n    })\n  } yield ()\n\nval countRequests: Handler[Ref[Map[String, Long]], Nothing, Request, (Request, Unit)] =\n  Handler.fromFunctionZIO[Request](request => inc("requests").as((request, ())))\n\nval countResponses: Handler[Ref[Map[String, Long]], Nothing, Response, Response] =\n  Handler.fromFunctionZIO[Response](response => inc("responses").as(response))\n\nval counterMiddleware: HandlerAspect[Ref[Map[String, Long]], Unit] =\n  HandlerAspect.interceptHandler(countRequests)(countResponses)\n')),(0,r.yg)("p",null,"Then, we can write another handler aspect that is responsible for adding a route to get the statistics of the incoming requests and outgoing responses:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.schema.codec.JsonCodec.zioJsonBinaryCodec\n\nval statsMiddleware: Middleware[Ref[Map[String, Long]]] =\n  new Middleware[Ref[Map[String, Long]]] {\n    override def apply[Env1 <: Ref[Map[String, Long]], Err](routes: Routes[Env1, Err]): Routes[Env1, Err] =\n      routes ++ Routes(\n        Method.GET / "stats" -> Handler.fromFunctionZIO[Request] { _ =>\n          ZIO.serviceWithZIO[Ref[Map[String, Long]]](_.get).map(stats => Response(body = Body.from(stats)))\n        },\n      )\n  }\n')),(0,r.yg)("p",null,"After attaching these two handler aspects to our ",(0,r.yg)("inlineCode",{parentName:"p"},"Routes"),", we have to provide the initial state for the ",(0,r.yg)("inlineCode",{parentName:"p"},"Ref[Map[String, Long]]")," to the whole application's environment:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"Server.serve(routes @@ counterMiddleware @@ statsMiddleware)\n  .provide(\n    Server.default,\n    ZLayer.fromZIO(Ref.make(Map.empty[String, Long]))\n  )\n")),(0,r.yg)("h3",{id:"intercepting-statefully"},"Intercepting Statefully"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.interceptHandlerStateful")," constructor is like the ",(0,r.yg)("inlineCode",{parentName:"p"},"interceptHandler"),", but it allows the incoming handler to have a state that can be passed to the next layer in the stack, and finally, that state can be accessed by the outgoing handler."),(0,r.yg)("p",null,"Here is how it works:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"The incoming handler receives a ",(0,r.yg)("inlineCode",{parentName:"li"},"Request")," and produces a tuple of ",(0,r.yg)("inlineCode",{parentName:"li"},"State")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"(Request, CtxOut)"),"."),(0,r.yg)("li",{parentName:"ol"},"The state produced by the incoming handler is passed to the next layer in the stack."),(0,r.yg)("li",{parentName:"ol"},"The outgoing handler receives the ",(0,r.yg)("inlineCode",{parentName:"li"},"State")," along with the ",(0,r.yg)("inlineCode",{parentName:"li"},"Response")," as a tuple, i.e. ",(0,r.yg)("inlineCode",{parentName:"li"},"(State, Response)"),", and produces a ",(0,r.yg)("inlineCode",{parentName:"li"},"Response"),".")),(0,r.yg)("p",null,"So, we can pass some state from the incoming handler to the outgoing handler."),(0,r.yg)("p",null,"In the following example, we are going to write an handler aspect that calculates the response time and includes it in the ",(0,r.yg)("inlineCode",{parentName:"p"},"X-Response-Time")," header:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport java.util.concurrent.TimeUnit\n\nval incomingTime: Handler[Any, Nothing, Request, (Long, (Request, Unit))] =\n  Handler.fromFunctionZIO(request => ZIO.clockWith(_.currentTime(TimeUnit.MILLISECONDS)).map(t => (t, (request, ()))))\n\nval outgoingTime: Handler[Any, Nothing, (Long, Response), Response] =\n  Handler.fromFunctionZIO { case (incomingTime, response) =>\n    ZIO\n      .clockWith(_.currentTime(TimeUnit.MILLISECONDS).map(t => t - incomingTime))\n      .map(responseTime => response.addHeader("X-Response-Time", s"${responseTime}ms"))\n  }\n\nval responseTime: HandlerAspect[Any, Unit] =\n  HandlerAspect.interceptHandlerStateful(incomingTime)(outgoingTime)\n')),(0,r.yg)("p",null,"By attaching this handler aspect to any route, we can see the response time in the ",(0,r.yg)("inlineCode",{parentName:"p"},"X-Response-Time")," header:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"$ curl -X GET 'http://127.0.0.1:8080/hello' -i\nHTTP/1.1 200 OK\ncontent-type: text/plain\nX-Response-Time: 100ms\ncontent-length: 12\n\nHello World!\u23ce\n")),(0,r.yg)("h3",{id:"intercepting-statefully-patching-responses"},"Intercepting Statefully (Patching Responses)"),(0,r.yg)("p",null,"Sometimes we want to apply a series of transformations to the outgoing response. We can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.interceptPatch")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.interceptPatchZIO")," to achieve this."),(0,r.yg)("p",null,"A ",(0,r.yg)("inlineCode",{parentName:"p"},"Response.Patch")," is a data type that represents a function (or series of functions) that can be applied to a response and return a new response. The ",(0,r.yg)("inlineCode",{parentName:"p"},"HanlderAspect.interceptPatch*")," uses this data type to transform the response."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerApect.interceptPatch")," takes two groups of arguments:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Intercepting the Incoming Request"),": The first one is a function that takes the incoming ",(0,r.yg)("inlineCode",{parentName:"li"},"Request")," and produces a ",(0,r.yg)("inlineCode",{parentName:"li"},"State"),". This state is passed through the handler aspect stack and then can be accessed through the interception phase of the outgoing response."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Intercepting the Outgoing Response"),": The second one is a function that takes a tuple of ",(0,r.yg)("inlineCode",{parentName:"li"},"Response")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"State")," and returns a ",(0,r.yg)("inlineCode",{parentName:"li"},"Response.Patch")," that will be applied to the outgoing response.")),(0,r.yg)("p",null,"Let's try to rewrite the previous example using the ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.interceptPatch"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport java.util.concurrent.TimeUnit\n\nval incomingTime: Request => ZIO[Any, Nothing, Long] =\n  (_: Request) => ZIO.clockWith(_.currentTime(TimeUnit.MILLISECONDS))\n\nval outgoingTime: (Response, Long) => ZIO[Any, Nothing, Response.Patch] =\n  (_: Response, incomingTime: Long) =>\n    ZIO\n      .clockWith(_.currentTime(TimeUnit.MILLISECONDS).map(t => t - incomingTime))\n      .map(responseTime => Response.Patch.addHeader("X-Response-Time", s"${responseTime}ms"))\n\nval responseTime: HandlerAspect[Any, Unit] =\n  HandlerAspect.interceptPatchZIO(incomingTime)(outgoingTime)\n')),(0,r.yg)("h2",{id:"leveraging-output-context"},"Leveraging Output Context"),(0,r.yg)("p",null,"Ordinary Middlewares are intended to bracket a request's execution by intercepting the request, possibly modifying it or short-circuiting its execution, and then performing some post-processing on the response."),(0,r.yg)("p",null,"However, we sometimes want to gather some contextual information about a request and pass it alongside to the request's handler. This can be achieved with the ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect[Env, CtxOut]")," type, which extends ",(0,r.yg)("inlineCode",{parentName:"p"},"Middleware[Env]"),"."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," middleware produces a value of type ",(0,r.yg)("inlineCode",{parentName:"p"},"CtxOut")," on each request, which the routing DSL will accept just like a path component."),(0,r.yg)("p",null,"If we take a look at the definition of ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),", we can see that it has two type parameters, ",(0,r.yg)("inlineCode",{parentName:"p"},"Env")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"CtxOut"),". The ",(0,r.yg)("inlineCode",{parentName:"p"},"CtxOut")," is the output context. When we don't need to pass any context to the output, we use ",(0,r.yg)("inlineCode",{parentName:"p"},"Unit")," as the output context, otherwise, we can utilize any type as the output context."),(0,r.yg)("p",null,"Before diving into a real-world example, let's try to understand the output context with simple examples. First, assume that we have an identity ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," that does nothing but passes an integer value to the output context:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.http._\n\nval intAspect: HandlerAspect[Any, Int] = HandlerAspect.identity.as(42)\n")),(0,r.yg)("p",null,"To access this integer value in the handler, we need to define a handler that receives a tuple of ",(0,r.yg)("inlineCode",{parentName:"p"},"(Int, Request)"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val intRequestHandler: Handler[Int, Nothing, Request, Response] =\n  Handler.fromFunctionZIO[Request] { (_: Request) =>\n    ZIO.serviceWith[Int] { n =>\n      Response.text(s"Received the $n value from the output context!")\n    }\n  }\n')),(0,r.yg)("p",null,"If we attach the ",(0,r.yg)("inlineCode",{parentName:"p"},"intAspect")," to this handler, we get back a handler that receives a ",(0,r.yg)("inlineCode",{parentName:"p"},"Request")," and produces a ",(0,r.yg)("inlineCode",{parentName:"p"},"Response"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"val handler: Handler[Any, Response, Request, Response] = \n  intRequestHandler @@ intAspect\n")),(0,r.yg)("p",null,"Another thing to note is that when we compose multiple ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),"s with output context of non-",(0,r.yg)("inlineCode",{parentName:"p"},"Unit")," type, the output context of composed ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," will be a tuple of all the output contexts:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val stringAspect: HandlerAspect[Any, String] = \n  HandlerAspect.identity.as("Hello, World!")\n\nval intStringAspect: HandlerAspect[Any, (Int, String)] = \n  intAspect ++ stringAspect\n')),(0,r.yg)("p",null,"Correspondingly, to access the output context of this ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),", we need to have a handler that receives a tuple of ",(0,r.yg)("inlineCode",{parentName:"p"},"(Int, String, Request)"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val intStringRequestHandler: Handler[(Int, String), Nothing, Request, Response] =\n  Handler.fromFunctionZIO[Request] { (req: Request) => ZIO.serviceWith[(Int, String)] { case (n, s) =>\n      Response.text(s"Received the $n and $s values from the output context!")\n    }\n  }\n')),(0,r.yg)("p",null,"Finally, we can attach the ",(0,r.yg)("inlineCode",{parentName:"p"},"intStringAspect")," to this handler:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"val handler: Handler[Any, Response, Request, Response] = \n  intStringRequestHandler @@ (intAspect ++ stringAspect)\n")),(0,r.yg)("h3",{id:"session-example"},"Session Example"),(0,r.yg)("p",null,"To look up a ",(0,r.yg)("inlineCode",{parentName:"p"},"Session"),", we might use a ",(0,r.yg)("inlineCode",{parentName:"p"},"sessionMiddleware")," with type ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect[Env, Session]"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'Routes(\n  Method.GET / "user" / int("userId") -> sessionMiddleware -> handler { \n    (userId: Int, session: Session, request: Request) =>\n      UserRepository.getUser(session.organizationId, userId)\n  }\n)\n')),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," companion object provides a number of helpful constructors for these middlewares.\nFor this example, we would probably use ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.interceptHandler"),", which wraps an incoming-request handler as well as one which performs any necessary post-processing on the outgoing response:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"val incomingHandler: Handler[Env, Response, Request, (Request, Session)] = ???\nval outgoingHandler: Handler[Env, Nothing, Response, Response] = ???\nHandlerAspect.interceptHandler(incomingHandler)(outgoingHandler)\n")),(0,r.yg)("p",null,"Note the asymmetry in the type parameters of these two handlers:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"In the incoming case, the handler emits a ",(0,r.yg)("inlineCode",{parentName:"li"},"Response")," on the error-channel whenever the service cannot produce a ",(0,r.yg)("inlineCode",{parentName:"li"},"Session"),", effectively short-circuiting the processing of this request."),(0,r.yg)("li",{parentName:"ul"},"The outgoing handler, by contrast, has ",(0,r.yg)("inlineCode",{parentName:"li"},"Nothing")," as its ",(0,r.yg)("inlineCode",{parentName:"li"},"Err")," type, meaning that it ",(0,r.yg)("strong",{parentName:"li"},"cannot")," fail and must always produce a ",(0,r.yg)("inlineCode",{parentName:"li"},"Response")," on the success channel.")),(0,r.yg)("h3",{id:"custom-authentication-example"},"Custom Authentication Example"),(0,r.yg)("p",null,"Now, let's see a real-world example where we can leverage the output context."),(0,r.yg)("p",null,"In the following example, we are going to write an authentication handler aspect that checks the JWT token in the incoming request and passes the user information to the handler:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport scala.util.Try\nimport pdi.jwt.{Jwt, JwtAlgorithm, JwtClaim}\n\n// Secret Authentication key\nval SECRET_KEY = "secretKey"\n\ndef jwtDecode(token: String, key: String): Try[JwtClaim] =\n  Jwt.decode(token, key, Seq(JwtAlgorithm.HS512))\n\nval bearerAuthWithContext: HandlerAspect[Any, String] =\n  HandlerAspect.interceptIncomingHandler(Handler.fromFunctionZIO[Request] { request =>\n    request.header(Header.Authorization) match {\n      case Some(Header.Authorization.Bearer(token)) =>\n        ZIO\n          .fromTry(jwtDecode(token.value.asString, SECRET_KEY))\n          .orElseFail(Response.badRequest("Invalid or expired token!"))\n          .flatMap(claim => ZIO.fromOption(claim.subject).orElseFail(Response.badRequest("Missing subject claim!")))\n          .map(u => (request, u))\n\n      case _ => ZIO.fail(Response.unauthorized.addHeaders(Headers(Header.WWWAuthenticate.Bearer(realm = "Access"))))\n    }\n  })\n')),(0,r.yg)("p",null,"Now, let's define the ",(0,r.yg)("inlineCode",{parentName:"p"},"/profile/me")," route that requires authentication output context:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val profileRoute: Route[Any, Response] =\n  Method.GET / "profile" / "me" -> \n    Handler.fromFunctionZIO[Request] { (_: Request) => \n     ZIO.serviceWith[String](name => Response.text(s"Welcome $name!"))\n  } @@ bearerAuthWithContext\n')),(0,r.yg)("p",null,"That's it! Now, in the handler of the ",(0,r.yg)("inlineCode",{parentName:"p"},"/profile/me")," route, we have the username that is extracted from the JWT token inside the authentication handler aspect and passed to it."),(0,r.yg)("p",null,"The following code snippet is the complete example. Using the login route, we can get the JWT token and use it to access the protected ",(0,r.yg)("inlineCode",{parentName:"p"},"/profile/me")," route:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/AuthenticationServer.scala"',title:'"zio-http-example/src/main/scala/example/AuthenticationServer.scala"'},'package example\n\nimport java.time.Clock\n\nimport scala.util.Try\n\nimport zio._\n\nimport zio.http._\n\nimport pdi.jwt.{Jwt, JwtAlgorithm, JwtClaim}\n\n/**\n * This is an example to demonstrate bearer Authentication middleware. The\n * Server has 2 routes. The first one is for login, Upon a successful login, it\n * will return a jwt token for accessing protected routes. The second route is a\n * protected route that is accessible only if the request has a valid jwt token.\n * AuthenticationClient example can be used to makes requests to this server.\n */\nobject AuthenticationServer extends ZIOAppDefault {\n  implicit val clock: Clock = Clock.systemUTC\n\n  // Secret Authentication key\n  val SECRET_KEY = "secretKey"\n\n  def jwtEncode(username: String, key: String): String =\n    Jwt.encode(JwtClaim(subject = Some(username)).issuedNow.expiresIn(300), key, JwtAlgorithm.HS512)\n\n  def jwtDecode(token: String, key: String): Try[JwtClaim] =\n    Jwt.decode(token, key, Seq(JwtAlgorithm.HS512))\n\n  val bearerAuthWithContext: HandlerAspect[Any, String] =\n    HandlerAspect.interceptIncomingHandler(Handler.fromFunctionZIO[Request] { request =>\n      request.header(Header.Authorization) match {\n        case Some(Header.Authorization.Bearer(token)) =>\n          ZIO\n            .fromTry(jwtDecode(token.value.asString, SECRET_KEY))\n            .orElseFail(Response.badRequest("Invalid or expired token!"))\n            .flatMap(claim => ZIO.fromOption(claim.subject).orElseFail(Response.badRequest("Missing subject claim!")))\n            .map(u => (request, u))\n\n        case _ => ZIO.fail(Response.unauthorized.addHeaders(Headers(Header.WWWAuthenticate.Bearer(realm = "Access"))))\n      }\n    })\n\n  def app: Routes[Any, Response] =\n    Routes(\n      // A route that is accessible only via a jwt token\n      Method.GET / "profile" / "me" -> handler { (_: Request) =>\n        ZIO.serviceWith[String](name => Response.text(s"Welcome $name!"))\n      } @@ bearerAuthWithContext,\n\n      // A login route that is successful only if the password is the reverse of the username\n      Method.GET / "login" ->\n        handler { (request: Request) =>\n          val form = request.body.asMultipartForm.orElseFail(Response.badRequest)\n          for {\n            username <- form\n              .map(_.get("username"))\n              .flatMap(ff => ZIO.fromOption(ff).orElseFail(Response.badRequest("Missing username field!")))\n              .flatMap(ff => ZIO.fromOption(ff.stringValue).orElseFail(Response.badRequest("Missing username value!")))\n            password <- form\n              .map(_.get("password"))\n              .flatMap(ff => ZIO.fromOption(ff).orElseFail(Response.badRequest("Missing password field!")))\n              .flatMap(ff => ZIO.fromOption(ff.stringValue).orElseFail(Response.badRequest("Missing password value!")))\n          } yield\n            if (password.reverse.hashCode == username.hashCode)\n              Response.text(jwtEncode(username, SECRET_KEY))\n            else\n              Response.unauthorized("Invalid username or password.")\n        },\n    ) @@ Middleware.debug\n\n  override val run = Server.serve(app).provide(Server.default)\n}\n')),(0,r.yg)("p",null,"After running the server, we can test it using the following client code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/AuthenticationClient.scala"',title:'"zio-http-example/src/main/scala/example/AuthenticationClient.scala"'},'package example\n\nimport zio._\n\nimport zio.http._\n\nobject AuthenticationClient extends ZIOAppDefault {\n\n  /**\n   * This example is trying to access a protected route in AuthenticationServer\n   * by first making a login request to obtain a jwt token and use it to access\n   * a protected route. Run AuthenticationServer before running this example.\n   */\n  val url = "http://localhost:8080"\n\n  val loginUrl = URL.decode(s"${url}/login").toOption.get\n  val greetUrl = URL.decode(s"${url}/profile/me").toOption.get\n\n  val program = for {\n    client   <- ZIO.service[Client]\n    // Making a login request to obtain the jwt token. In this example the password should be the reverse string of username.\n    token    <- client(\n      Request\n        .get(loginUrl)\n        .withBody(\n          Body.fromMultipartForm(\n            Form(\n              FormField.simpleField("username", "John"),\n              FormField.simpleField("password", "nhoJ"),\n            ),\n            Boundary("boundary123"),\n          ),\n        ),\n    ).flatMap(_.body.asString)\n    // Once the jwt token is procured, adding it as a Bearer token in Authorization header while accessing a protected route.\n    response <- client(Request.get(greetUrl).addHeader(Header.Authorization.Bearer(token)))\n    body     <- response.body.asString\n    _        <- Console.printLine(body)\n  } yield ()\n\n  override val run = program.provide(Client.default, Scope.default)\n\n}\n')),(0,r.yg)("h2",{id:"authentication-handler-aspects"},"Authentication Handler Aspects"),(0,r.yg)("p",null,"There are several built-in ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect"),"s that can be used to implement authentication in ZIO HTTP:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Basic Authentication"),": The ",(0,r.yg)("inlineCode",{parentName:"li"},"basicAuth")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"basicAuthZIO")," handler aspect can be used to implement basic authentication."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Bearer Authentication"),": The ",(0,r.yg)("inlineCode",{parentName:"li"},"bearerAuth")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"bearerAuthZIO")," handler aspect can be used to implement bearer authentication. We have to provide a function that validates the bearer token."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Custom Authentication"),": The ",(0,r.yg)("inlineCode",{parentName:"li"},"customAuth"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"customAuthZIO"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"customAuthProviding"),", and ",(0,r.yg)("inlineCode",{parentName:"li"},"customAuthProvidingZIO")," handler aspects can be used to implement custom authentication. We have to provide a function that validates the request.")),(0,r.yg)("h3",{id:"basic-authentication-example"},"Basic Authentication Example"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/BasicAuth.scala"',title:'"zio-http-example/src/main/scala/example/BasicAuth.scala"'},'package example\n\nimport zio._\n\nimport zio.http.Middleware.basicAuth\nimport zio.http._\nimport zio.http.codec.PathCodec.string\n\nobject BasicAuth extends ZIOAppDefault {\n\n  // Http app that requires a JWT claim\n  val user: Routes[Any, Response] = Routes(\n    Method.GET / "user" / string("name") / "greet" ->\n      handler { (name: String, _: Request) =>\n        Response.text(s"Welcome to the ZIO party! ${name}")\n      },\n  )\n\n  // Composing all the HttpApps together\n  val app: Routes[Any, Response] = user @@ basicAuth("admin", "admin")\n\n  // Run it like any simple app\n  val run = Server.serve(app).provide(Server.default)\n}\n')),(0,r.yg)("p",null,"To the example, start the server and fire a curl request with an incorrect user/password combination:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"curl -i --user admin:wrong http://localhost:8080/user/admin/greet\n\nHTTP/1.1 401 Unauthorized\nwww-authenticate: Basic\ncontent-length: 0\n")),(0,r.yg)("p",null,"We notice in the response that first ",(0,r.yg)("inlineCode",{parentName:"p"},"basicAuth")," handler aspect responded ",(0,r.yg)("inlineCode",{parentName:"p"},"HTTP/1.1 401 Unauthorized")," and then patch handler aspect attached a ",(0,r.yg)("inlineCode",{parentName:"p"},"X-Environment: Dev")," header."),(0,r.yg)("h2",{id:"failing-handleraspects"},"Failing HandlerAspects"),(0,r.yg)("p",null,"We can abort the requests by specific response using ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.fail")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.failWith")," aspects, so the downstream handlers will not be executed:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\n\nmyHandler @@ HandlerAspect.fail(Response.forbidden("Access Denied!"))\n\nmyHandler @@ HandlerAspect\n  .fail(Response.forbidden("Access Denied!"))\n  .when(req => req.method == Method.DELETE)\n')),(0,r.yg)("h2",{id:"updating-requests-and-responses"},"Updating Requests and Responses"),(0,r.yg)("p",null,"Several aspects are useful for updating the requests and responses:"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Description"),(0,r.yg)("th",{parentName:"tr",align:null},"HandlerAspect"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Update Request"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.updateRequest"),", ",(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.updateRequestZIO"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Update Request's Method"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.updateMethod"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Update Request's Path"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.updatePath"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Update Request's URL"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.updateURL"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Update Response"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.updateResponse"),", ",(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.updateResponseZIO"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Update Response Headers"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.updateHeaders"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Update Response Status"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"HandlerAspect.status"))))),(0,r.yg)("p",null,"These aspects can be used to modify the request and response before they reach the handler or the client. They take a function that transforms the request or response and returns the updated request or response. Let's see an example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"val dropTrailingSlash = HandlerAspect.updateURL(_.dropTrailingSlash)\n")),(0,r.yg)("h2",{id:"access-control-handleraspects"},"Access Control HandlerAspects"),(0,r.yg)("p",null,"To allow and disallow access to an HTTP based on some conditions, we can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.allow")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.allowZIO")," aspects."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val disallow: HandlerAspect[Any, Unit] = HandlerAspect.allow(_ => false)\nval allow: HandlerAspect[Any, Unit]    = HandlerAspect.allow(_ => true)\n\nval whitelistAspect: HandlerAspect[Any, Unit] = {\n  val whitelist = Set("127.0.0.1", "0.0.0.0")\n  HandlerAspect.allow(r =>\n    r.headers.get("X-Real-IP") match {\n      case Some(host) => whitelist.contains(host)\n      case None       => false\n    },\n  )\n}\n')),(0,r.yg)("h2",{id:"cookie-operations"},"Cookie Operations"),(0,r.yg)("p",null,"Several aspects are useful for adding, signing, and managing cookies:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("inlineCode",{parentName:"li"},"HandlerAspect.addCookie")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"HandlerAspect.addCookieZIO")," to add cookies"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("inlineCode",{parentName:"li"},"HandlerAspect.signCookies")," to sign cookies"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("inlineCode",{parentName:"li"},"HandlerAspect.flashScopeHandling")," to manage the flash scope")),(0,r.yg)("h2",{id:"conditional-application-of-handleraspects"},"Conditional Application of HandlerAspects"),(0,r.yg)("p",null,"We can attach a handler aspect conditionally using ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect#when"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect#whenZIO"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect#whenHeader")," methods. Wen also uses the following constructors to have conditional handler aspects: ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.when"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.whenZIO"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.whenHeader"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.whenResponse"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.whenResponseZIO"),"."),(0,r.yg)("p",null,"We have also some ",(0,r.yg)("inlineCode",{parentName:"p"},"if-then-else")," style constructors to create conditional aspects like ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.ifHeaderThenElse"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.ifMethodThenElse"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.ifRequestThenElse"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.ifRequestThenElseZIO"),"."),(0,r.yg)("h2",{id:"request-logging-handler-aspect"},"Request Logging Handler Aspect"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"requestLogging")," handler aspect is a common aspect that logs incoming requests. It is useful for debugging and monitoring purposes. This aspect logs information such as request method, URL, status code, duration, response and request size by default. We can also configure it to log request and response bodies, request and response headers which are disabled by default:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"object HandlerAspect {\n  def requestLogging(\n    level: Status => LogLevel = (_: Status) => LogLevel.Info,\n    loggedRequestHeaders: Set[Header.HeaderType] = Set.empty,\n    loggedResponseHeaders: Set[Header.HeaderType] = Set.empty,\n    logRequestBody: Boolean = false,\n    logResponseBody: Boolean = false,\n    requestCharset: Charset = StandardCharsets.UTF_8,\n    responseCharset: Charset = StandardCharsets.UTF_8,\n  ): HandlerAspect[Any, Unit] = ???\n}\n")),(0,r.yg)("h2",{id:"running-effect-beforeafter-every-request"},"Running Effect Before/After Every Request"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"runBefore")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"runAfter")," aspects are useful for running an effect before and after every request. These aspects can be used to perform some side effects like logging, metrics and debugging, before and after every request."),(0,r.yg)("h2",{id:"redirect-handler-aspect"},"Redirect Handler Aspect"),(0,r.yg)("p",null,"There is another handler aspect called ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.redirect")," which takes a ",(0,r.yg)("inlineCode",{parentName:"p"},"URL")," and redirects requests to that URL."),(0,r.yg)("h2",{id:"trailing-slash-handler-aspect"},"Trailing Slash Handler Aspect"),(0,r.yg)("p",null,"A trailing slash is the last forward-slash character at the end of some URLs. ZIO HTTP have two built-in aspect to handle trailing slashes:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"HandlerAspect.redirectTrailingSlash")," aspect is useful for redirecting requests with trailing slashes to the same URL without a trailing slash. This aspect is useful for SEO purposes and to avoid duplicate content issues."),(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"HandlerAspect.dropTrailingSlash")," aspect just drops the trailing slash from the request URL.")),(0,r.yg)("h2",{id:"patching-response-handler-aspect"},"Patching Response Handler Aspect"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.patch")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"HandlerAspect.patchZIO")," take a function from ",(0,r.yg)("inlineCode",{parentName:"p"},"Request")," to ",(0,r.yg)("inlineCode",{parentName:"p"},"Response.Patch")," and apply the patch to the response."),(0,r.yg)("p",null,"Here is an example of a handler aspect that adds a custom header to the response if the request has a specific header:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'HandlerAspect.patch(request =>\n  if (request.hasHeader("X-Foo"))\n    Response.Patch.addHeader("X-Bar", "Bar Value")\n  else \n    Response.Patch.empty\n)\n')),(0,r.yg)("h2",{id:"beautify-errors-handler-aspect"},"Beautify Errors Handler Aspect"),(0,r.yg)("p",null,"To make the error responses more user-friendly, we have a built-in handler aspect called ",(0,r.yg)("inlineCode",{parentName:"p"},"beautifyErrors"),". This aspect beautifies the error responses based on the requested content type. If the client requests an HTML response, it returns a formatted HTML response, otherwise, it returns a plain text response:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'val route = \n  Method.GET / "internal-error" -> Handler.fromResponse(Response.forbidden) @@ HandlerAspect.beautifyErrors\n')),(0,r.yg)("p",null,"If we deploy this route and send a GET request to the ",(0,r.yg)("inlineCode",{parentName:"p"},"/internal-error")," route with the ",(0,r.yg)("inlineCode",{parentName:"p"},"Accept: text/html")," header, we will get the following response body:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html><html><head><title>ZIO HTTP - Forbidden</title><style>\n body {\n   font-family: monospace;\n   font-size: 16px;\n   background-color: #edede0;\n }\n</style></head><body><div style="margin: auto; padding: 2em 4em; max-width: 80%"><h1>Forbidden</h1><div><div style="text-align: center"><div style="font-size: 20em">403</div><div>403</div></div></div></div></body></html>\u23ce\n')),(0,r.yg)("h2",{id:"debug-handler-aspect"},"Debug Handler Aspect"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"debug")," handler aspect is a useful aspect for debugging requests and responses. It prints the response status code, request method and url, and the response time of each request to the console."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'  val helloRoute =\n    Method.GET / "hello" -> Handler.fromResponse(Response.text("Hello World!")) @@ HandlerAspect.debug\n')),(0,r.yg)("p",null,"When we send a GET request to the ",(0,r.yg)("inlineCode",{parentName:"p"},"/hello")," route, we can see the following output in the console:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-shell"},"200 GET /hello 14ms\n")),(0,r.yg)("h2",{id:"examples"},"Examples"),(0,r.yg)("h3",{id:"a-simple-middleware-example"},"A Simple Middleware Example"),(0,r.yg)("p",null,"Let us consider a simple example using an out-of-the-box handler aspect called ",(0,r.yg)("inlineCode",{parentName:"p"},"addHeader"),". We will write an aspect that will attach a custom header to the response."),(0,r.yg)("p",null,"We create an aspect that appends an additional header to the response indicating whether it is a Dev/Prod/Staging environment:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/HelloWorldWithMiddlewares.scala"',title:'"zio-http-example/src/main/scala/example/HelloWorldWithMiddlewares.scala"'},'package example\n\nimport java.util.concurrent.TimeUnit\n\nimport zio._\n\nimport zio.http._\n\nobject HelloWorldWithMiddlewares extends ZIOAppDefault {\n\n  val app: Routes[Any, Response] = Routes(\n    // this will return result instantly\n    Method.GET / "text"         -> handler(ZIO.succeed(Response.text("Hello World!"))),\n    // this will return result after 5 seconds, so with 3 seconds timeout it will fail\n    Method.GET / "long-running" -> handler(ZIO.succeed(Response.text("Hello World!")).delay(5 seconds)),\n  )\n\n  val serverTime = Middleware.patchZIO(_ =>\n    for {\n      currentMilliseconds <- Clock.currentTime(TimeUnit.MILLISECONDS)\n      header = Response.Patch.addHeader("X-Time", currentMilliseconds.toString)\n    } yield header,\n  )\n  val middlewares =\n    // print debug info about request and response\n    Middleware.debug ++\n      // close connection if request takes more than 3 seconds\n      Middleware.timeout(3 seconds) ++\n      // add static header\n      Middleware.addHeader("X-Environment", "Dev") ++\n      // add dynamic header\n      serverTime\n\n  // Run it like any simple app\n  val run = Server.serve(app @@ middlewares).provide(Server.default)\n}\n')),(0,r.yg)("p",null,'Fire a curl request, and we see an additional header added to the response indicating the "Dev" environment:'),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"curl -i http://localhost:8080/Bob\n\nHTTP/1.1 200 OK\ncontent-type: text/plain\nX-Environment: Dev\ncontent-length: 12\n\nHello Bob\n")),(0,r.yg)("h3",{id:"endpoint-middleware-example"},"Endpoint Middleware Example"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/EndpointExamples.scala"',title:'"zio-http-example/src/main/scala/example/EndpointExamples.scala"'},'package example\n\nimport zio._\n\nimport zio.http.Header.Authorization\nimport zio.http._\nimport zio.http.codec.{HttpCodec, PathCodec}\nimport zio.http.endpoint.openapi.{OpenAPIGen, SwaggerUI}\nimport zio.http.endpoint.{Endpoint, EndpointExecutor, EndpointLocator, EndpointMiddleware}\n\nobject EndpointExamples extends ZIOAppDefault {\n  import HttpCodec.query\n  import PathCodec._\n\n  val auth = EndpointMiddleware.auth\n\n  // MiddlewareSpec can be added at the service level as well\n  val getUser =\n    Endpoint(Method.GET / "users" / int("userId")).out[Int] @@ auth\n\n  val getUserRoute =\n    getUser.implement {\n      Handler.fromFunction[Int] { id =>\n        id\n      }\n    }\n\n  val getUserPosts =\n    Endpoint(Method.GET / "users" / int("userId") / "posts" / int("postId"))\n      .query(query("name"))\n      .out[List[String]] @@ auth\n\n  val getUserPostsRoute =\n    getUserPosts.implement[Any] {\n      Handler.fromFunctionZIO[(Int, Int, String)] { case (id1: Int, id2: Int, query: String) =>\n        ZIO.succeed(List(s"API2 RESULT parsed: users/$id1/posts/$id2?name=$query"))\n      }\n    }\n\n  val openAPI = OpenAPIGen.fromEndpoints(title = "Endpoint Example", version = "1.0", getUser, getUserPosts)\n\n  val routes = Routes(getUserRoute, getUserPostsRoute) ++ SwaggerUI.routes("docs" / "openapi", openAPI)\n\n  val app = routes // (auth.implement(_ => ZIO.unit)(_ => ZIO.unit))\n\n  val request = Request.get(url = URL.decode("/users/1").toOption.get)\n\n  val run = Server.serve(app).provide(Server.default)\n\n  object ClientExample {\n    def example(client: Client) = {\n      val locator =\n        EndpointLocator.fromURL(URL.decode("http://localhost:8080").toOption.get)\n\n      val executor: EndpointExecutor[Authorization] =\n        EndpointExecutor(client, locator, ZIO.succeed(Authorization.Basic("user", "pass")))\n\n      val x1 = getUser(42)\n      val x2 = getUserPosts(42, 200, "adam")\n\n      val result1: ZIO[Scope, Nothing, Int]          = executor(x1)\n      val result2: ZIO[Scope, Nothing, List[String]] = executor(x2)\n\n      result1.zip(result2).debug\n    }\n  }\n}\n')))}u.isMDXComponent=!0},48677:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/handler-aspect-b91f6f81d64103994a13207a5038d01e.svg"}}]);