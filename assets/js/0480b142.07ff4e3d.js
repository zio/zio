"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[8070],{15680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>m});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,m=u["".concat(s,".").concat(c)]||u[c]||h[c]||r;return n?a.createElement(m,o(o({ref:t},d),{},{components:n})):a.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},20842:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(58168),i=(n(96540),n(15680));const r={id:"faq",slug:"faq",title:"Frequently Answered Questions (FAQ)",sidebar_label:"FAQ"},o=void 0,l={unversionedId:"faq",id:"faq",title:"Frequently Answered Questions (FAQ)",description:"In this page we are going to answer general questions related to the ZIO project.",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/faq",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/faq.md",tags:[],version:"current",frontMatter:{id:"faq",slug:"faq",title:"Frequently Answered Questions (FAQ)",sidebar_label:"FAQ"}},s={},p=[{value:"Where should we encode contextual values like <code>UserId</code>, <code>CorrelationId</code> in my ZIO application?",id:"where-should-we-encode-contextual-values-like-userid-correlationid-in-my-zio-application",level:2},{value:"Solution 1: Explicit Parameters",id:"solution-1-explicit-parameters",level:3},{value:"Solution 2: Implicit Parameters",id:"solution-2-implicit-parameters",level:3},{value:"Solution 3 and 4: Environment and FiberRefs",id:"solution-3-and-4-environment-and-fiberrefs",level:3},{value:"In ZIO ecosystem, there are lots of data types which they have <code>Z</code> prefix in their names. What this prefix stands for? Does it mean, that data type is effectual?",id:"in-zio-ecosystem-there-are-lots-of-data-types-which-they-have-z-prefix-in-their-names-what-this-prefix-stands-for-does-it-mean-that-data-type-is-effectual",level:2}],d={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,i.yg)(u,(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"In this page we are going to answer general questions related to the ZIO project."),(0,i.yg)("h2",{id:"where-should-we-encode-contextual-values-like-userid-correlationid-in-my-zio-application"},"Where should we encode contextual values like ",(0,i.yg)("inlineCode",{parentName:"h2"},"UserId"),", ",(0,i.yg)("inlineCode",{parentName:"h2"},"CorrelationId")," in my ZIO application?"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Should we put ",(0,i.yg)("inlineCode",{parentName:"li"},"CorrelationId")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"UserId")," as well into a ",(0,i.yg)("inlineCode",{parentName:"li"},"FiberLocal"),"?"),(0,i.yg)("li",{parentName:"ol"},"Should our effects be something like ",(0,i.yg)("inlineCode",{parentName:"li"},"val someEffect: ZIO[CorrerlationId & UserId, ErrorType, A]"),"?"),(0,i.yg)("li",{parentName:"ol"},"Should we keep writing our effects with explicit params as ",(0,i.yg)("inlineCode",{parentName:"li"},"def someEffect(c: CorrelationId, u: UserId, params...): ZIO[Any, ErrorType, A]"),"?"),(0,i.yg)("li",{parentName:"ol"},"Should we put these context parameters as implicits, like ",(0,i.yg)("inlineCode",{parentName:"li"},"def someEffect(params..)(implicit c: CorrelationId, u: UserId): ZIO[Any, ErrorType, A]"),"?")),(0,i.yg)("p",null,"Before answering these question, make sure you have read the ",(0,i.yg)("a",{parentName:"p",href:"/reference/contextual/"},"ZIO Environment Use-cases")," section."),(0,i.yg)("p",null,"Now, let's go into this in a little more detail. We have some workflow, ",(0,i.yg)("inlineCode",{parentName:"p"},"someEffect")," that conceptually requires both a ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId")," and a ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId")," to be run. Let's consider any of these solutions in turn."),(0,i.yg)("h3",{id:"solution-1-explicit-parameters"},"Solution 1: Explicit Parameters"),(0,i.yg)("p",null,"The simplest way to model this dependency is just as function parameters:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"def someEffect(userId: UserId, correlationId: CorrelationId, ...): ZIO[Any, ErrorType, A] =\n  ???\n")),(0,i.yg)("p",null,"This is a fine starting point. Functions that take arguments are about as simple as you can get. However, there are two main issues with this."),(0,i.yg)("p",null,'First, it can just become a lot of boilerplate. The signature above looks potentially okay on its own, but if it is being called by some other function which in turn is being called by some other function it can become a lot of boilerplate very fast which is why people turn to all of these alternatives. I don\'t think there is a hard and fast rule for when it gets to be "too much" boilerplate but if you are unsure I think a good practice can be to use explicit parameters until you "feel the pain" and then you can refactor to one of the alternatives discussed below.'),(0,i.yg)("p",null,"The second problem with this approach is that someEffect is a method and not a first class value, which can limit our ability to work with it in some cases. But typically the boilerplate is the overwhelming problem that leads people to move away from this approach."),(0,i.yg)("h3",{id:"solution-2-implicit-parameters"},"Solution 2: Implicit Parameters"),(0,i.yg)("p",null,"The second alternative you highlight is to make these parameters implicit."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"def someEffect(...)(implicit userId: UserId, correlationId: CorrelationId): ZIO[Any, ErrorType, A] =\n  ???\n")),(0,i.yg)("p",null,"This addresses the boilerplate problem with explicit parameters by allowing us to pass them implicitly. We would basically never recommend this solution."),(0,i.yg)("p",null,'To reason about implicit values in a principled way we want them to be "coherent" which means there is only one implicit value corresponding to any type within our entire program. For example, there is only one Associative instance for String if we are using functional abstractions, or there is only one ',(0,i.yg)("inlineCode",{parentName:"p"},"JsonEncoder")," instance for Person."),(0,i.yg)("p",null,"If this requirement is not satisfied we get into anti-patterns like an ",(0,i.yg)("inlineCode",{parentName:"p"},"implicit ExecutionContext"),", where changing our imports or moving a block of code can change which thread pool we run on."),(0,i.yg)("p",null,"By definition, contextual values like this never satisfy this coherence requirement because there are lots of different ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId")," values in our program. We need to pass them around explicitly or implicitly precisely because there are different ones."),(0,i.yg)("p",null,"So while there are some cases where there might be different alternatives we want to consider this one I think we can rule out."),(0,i.yg)("h3",{id:"solution-3-and-4-environment-and-fiberrefs"},"Solution 3 and 4: Environment and FiberRefs"),(0,i.yg)("p",null,"The final two alternatives are modeling these contextual values as part of the ZIO Environment or as ",(0,i.yg)("inlineCode",{parentName:"p"},"FiberRef")," values."),(0,i.yg)("p",null,"If we model both of these requirements as part of the environment our method signature would look like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"def someEffect(...): ZIO[UserId & CorrelationId, ErrorType, A] =\n  ???\n")),(0,i.yg)("p",null,"If we model them as ",(0,i.yg)("inlineCode",{parentName:"p"},"FiberRef")," values we would define ",(0,i.yg)("inlineCode",{parentName:"p"},"FiberRef")," values that described both the ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId")," and the ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"val currentUserId: FiberRef[UserId] = ???\nval currentCorrelationId: FiberRef[CorrelationId] = ???\n\ndef someEffect(...): ZIO[Any, ErrorType, A] =\n  ???\n")),(0,i.yg)("p",null,"Both of these approaches are similar in that they allow us to avoid the boilerplate associated with passing around the ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId")," and the ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId"),", they allow us to treat ",(0,i.yg)("inlineCode",{parentName:"p"},"someEffect")," as a value, and they allow us to locally modify the current value of the ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId"),"."),(0,i.yg)("p",null,"The main difference between these two approaches is that with the ZIO Environment we reflect the fact that ",(0,i.yg)("inlineCode",{parentName:"p"},"someEffect")," needs a ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId")," and a ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId")," in the type signature, whereas when we use a ",(0,i.yg)("inlineCode",{parentName:"p"},"FiberRef")," this requirement is not reflected in the type signature."),(0,i.yg)("p",null,"Including these requirements in our type signature can be both an advantage and a disadvantage. The advantage is that we make explicit that ",(0,i.yg)("inlineCode",{parentName:"p"},"someEffect")," requires this contextual information, and we cannot even run ",(0,i.yg)("inlineCode",{parentName:"p"},"someEffect"),' without providing it. The disadvantage is that we have to include these requirements in the type signatures of all of our workflows, which can "bubble up" through many method signatures and arguably exposes an implementation detail.'),(0,i.yg)("p",null,'So the question I would ask here, going back to our original answer, is whether including these requirements in your type signature is helpful for you to reason about your program. Some related questions you might ask yourself are "Would it make sense to run the workflow if a requirement were not provided?" and "Is there a sensible default value of this requirement"?'),(0,i.yg)("p",null,"Applying these to the CorrelationId and UserId we would be tempted to not include the ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId")," in the environment. It may depend what we are doing with it but it seems like the ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId")," is a low level implementation detail associated with logging that we do not need cluttering up our method signatures. There seems to be a very sensible default ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId")," of None indicating that there is no ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId")," associated with whatever we are doing and we can still run our program without having a ",(0,i.yg)("inlineCode",{parentName:"p"},"CorrelationId"),", our logs will just not be as helpful as they otherwise would be which we can see and correct."),(0,i.yg)("p",null,"On the other hand for ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId")," we could easily see coming to the opposite conclusion. If ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId")," is supposed to tell us which user we are supposed to look up in a database or whether we are supposed to be able to look up certain information at all then we may not even be able to run ",(0,i.yg)("inlineCode",{parentName:"p"},"someEffect")," without having a ",(0,i.yg)("inlineCode",{parentName:"p"},"UserId"),". Of course we could just fail at runtime but failing at runtime is much more severe than just logging less precisely and normally we want to use the type system to convert runtime failures to compile time failures. So this seems like it might be a great case for using the ZIO environment."),(0,i.yg)("h2",{id:"in-zio-ecosystem-there-are-lots-of-data-types-which-they-have-z-prefix-in-their-names-what-this-prefix-stands-for-does-it-mean-that-data-type-is-effectual"},"In ZIO ecosystem, there are lots of data types which they have ",(0,i.yg)("inlineCode",{parentName:"h2"},"Z")," prefix in their names. What this prefix stands for? Does it mean, that data type is effectual?"),(0,i.yg)("p",null,"No, it doesn't denote that the data type is effectual. Instead, the ",(0,i.yg)("inlineCode",{parentName:"p"},"Z")," prefix is used for two purposes:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Polymorphic Version of Another Data Type")," \u2014 The ",(0,i.yg)("inlineCode",{parentName:"p"},"Z")," prefix indicates a more polymorphic version of another data type, not a data type that is effectual. So for example ",(0,i.yg)("inlineCode",{parentName:"p"},"IO")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," are equally effectual but ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," is more polymorphic because it has the additional type parameter ",(0,i.yg)("inlineCode",{parentName:"p"},"R"),".")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Term Disambiguation")," \u2014 There are some cases where the ",(0,i.yg)("inlineCode",{parentName:"p"},"Z")," prefix is used to disambiguate a term that might otherwise be too common and create risk of name conflicts (e.g. ",(0,i.yg)("inlineCode",{parentName:"p"},"ZPool"),")."))),(0,i.yg)("p",null,"This convention is true across all ZIO ecosystem. For example, in ZIO Prelude, the ",(0,i.yg)("inlineCode",{parentName:"p"},"ZValidation")," is a more general version of ",(0,i.yg)("inlineCode",{parentName:"p"},"Validation")," that is polymorphic in the log type. ",(0,i.yg)("inlineCode",{parentName:"p"},"ZSet")," is a more polymorphic version of a ",(0,i.yg)("em",{parentName:"p"},"Set")," that is polymorphic in the measure type. ",(0,i.yg)("inlineCode",{parentName:"p"},"ZPure")," is more polymorphic than its type aliases in several ways as represented by its different type parameters and also serves to disambiguate it as ",(0,i.yg)("em",{parentName:"p"},"Pure")," which is too general."))}h.isMDXComponent=!0}}]);