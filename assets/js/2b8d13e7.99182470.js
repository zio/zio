"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[61283],{15680:(e,n,a)=>{a.d(n,{xA:()=>c,yg:()=>y});var t=a(96540);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=t.createContext({}),s=function(e){var n=t.useContext(p),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},c=function(e){var n=s(e.components);return t.createElement(p.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(a),u=r,y=d["".concat(p,".").concat(u)]||d[u]||m[u]||i;return a?t.createElement(y,o(o({ref:n},c),{},{components:a})):t.createElement(y,o({ref:n},c))}));function y(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},83716:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var t=a(58168),r=(a(96540),a(15680));const i={id:"mvar",title:"MVar"},o=void 0,l={unversionedId:"reference/sync/mvar",id:"reference/sync/mvar",title:"MVar",description:"An MVar[A] is a mutable location that is either empty or contains a value of type A. So the MVar acts like a single-element buffer.",source:"@site/docs/reference/sync/mvar.md",sourceDirName:"reference/sync",slug:"/reference/sync/mvar",permalink:"/reference/sync/mvar",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/sync/mvar.md",tags:[],version:"current",frontMatter:{id:"mvar",title:"MVar"}},p={},s=[{value:"Creation",id:"creation",level:2},{value:"Operations",id:"operations",level:2},{value:"Blocking <code>put</code> and <code>take</code>",id:"blocking-put-and-take",level:3},{value:"Nonblocking <code>tryPut</code> and <code>tryTake</code>",id:"nonblocking-tryput-and-trytake",level:3},{value:"Blocking <code>update</code>, and <code>modify</code>",id:"blocking-update-and-modify",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Simple On/Off Latch",id:"simple-onoff-latch",level:3},{value:"Binary Semaphore",id:"binary-semaphore",level:3},{value:"Synchronized Mutable Variable",id:"synchronized-mutable-variable",level:3},{value:"Producer/Consumer Channel",id:"producerconsumer-channel",level:3}],c={toc:s},d="wrapper";function m(e){let{components:n,...a}=e;return(0,r.yg)(d,(0,t.A)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"An ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar[A]")," is a mutable location that is either empty or contains a value of type ",(0,r.yg)("inlineCode",{parentName:"p"},"A"),". So the ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," acts like a ",(0,r.yg)("em",{parentName:"p"},"single-element buffer"),"."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," can be used in multiple different ways:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"As a simple on/off latch"),(0,r.yg)("li",{parentName:"ul"},"As a binary semaphore ",(0,r.yg)("inlineCode",{parentName:"li"},"MVar[Unit]"),", with ",(0,r.yg)("inlineCode",{parentName:"li"},"take")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"put")," as ",(0,r.yg)("inlineCode",{parentName:"li"},"acquire")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"release")),(0,r.yg)("li",{parentName:"ul"},"As a synchronized mutable variable"),(0,r.yg)("li",{parentName:"ul"},"As a channel, with ",(0,r.yg)("inlineCode",{parentName:"li"},"take")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"put")," as ",(0,r.yg)("inlineCode",{parentName:"li"},"receive")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"send"))),(0,r.yg)("p",null,"They were introduced in the paper ",(0,r.yg)("a",{parentName:"p",href:"http://research.microsoft.com/~simonpj/papers/concurrent-haskell.ps.gz"},"Concurrent Haskell")," by Simon Peyton Jones, Andrew Gordon and, Sigbjorn Finne."),(0,r.yg)("h2",{id:"creation"},"Creation"),(0,r.yg)("p",null,"There are two ways to create an ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar"),":"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"MVar.empty[A]")),"\u2014 To create an ",(0,r.yg)("inlineCode",{parentName:"li"},"MVar")," of type ",(0,r.yg)("inlineCode",{parentName:"li"},"A")," that is ",(0,r.yg)("em",{parentName:"li"},"initially empty"),", for example:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.concurrent.MVar\n\nval empty = MVar.empty[Int]\n")),(0,r.yg)("ol",{start:2},(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"MVar.make[A]")),"\u2014 To create an ",(0,r.yg)("inlineCode",{parentName:"li"},"MVar")," of type ",(0,r.yg)("inlineCode",{parentName:"li"},"A")," that is ",(0,r.yg)("em",{parentName:"li"},"initially full"),", for example:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.concurrent.MVar\n\nval full = MVar.make(42)\n")),(0,r.yg)("h2",{id:"operations"},"Operations"),(0,r.yg)("h3",{id:"blocking-put-and-take"},"Blocking ",(0,r.yg)("inlineCode",{parentName:"h3"},"put")," and ",(0,r.yg)("inlineCode",{parentName:"h3"},"take")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," has two fundamental operations:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"MVar#put")," which fills an ",(0,r.yg)("inlineCode",{parentName:"li"},"MVar")," if it is empty and blocks otherwise."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"MVar#take")," which empties an ",(0,r.yg)("inlineCode",{parentName:"li"},"MVar")," if it is full and blocks otherwise.")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"class MVar[A] {\n  def put(a: A): UIO[Unit] = ???\n  def take: UIO[A] = ???\n}\n")),(0,r.yg)("p",null,"So we can put something into it, making it full, or take something out, making it empty, and in two cases, it will block the calling fiber:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"If it is full and the calling fiber tries to put something in it."),(0,r.yg)("li",{parentName:"ul"},"If it is empty and the calling fiber tries to take something out of it.")),(0,r.yg)("p",null,"These two features of ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," make it possible to synchronize multiple fibers."),(0,r.yg)("h3",{id:"nonblocking-tryput-and-trytake"},"Nonblocking ",(0,r.yg)("inlineCode",{parentName:"h3"},"tryPut")," and ",(0,r.yg)("inlineCode",{parentName:"h3"},"tryTake")),(0,r.yg)("p",null,"While ",(0,r.yg)("inlineCode",{parentName:"p"},"put")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"take")," are blocking operations, there are also non-blocking versions of these operations:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"MVar#tryPut")," which tries to fill an ",(0,r.yg)("inlineCode",{parentName:"li"},"MVar")," and returns ",(0,r.yg)("inlineCode",{parentName:"li"},"true")," if successful or ",(0,r.yg)("inlineCode",{parentName:"li"},"false")," if it is full."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"MVar#tryTake")," which tries to empty an ",(0,r.yg)("inlineCode",{parentName:"li"},"MVar")," and returns ",(0,r.yg)("inlineCode",{parentName:"li"},"Some(x)")," if it is full of ",(0,r.yg)("inlineCode",{parentName:"li"},"x")," or ",(0,r.yg)("inlineCode",{parentName:"li"},"None")," if it is empty.")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"class MVar[A] {\n  def tryPut(x: A): UIO[Boolean] = ???\n  def tryTake: UIO[Option[A]] = ???\n}\n")),(0,r.yg)("h3",{id:"blocking-update-and-modify"},"Blocking ",(0,r.yg)("inlineCode",{parentName:"h3"},"update"),", and ",(0,r.yg)("inlineCode",{parentName:"h3"},"modify")),(0,r.yg)("p",null,"Using ",(0,r.yg)("inlineCode",{parentName:"p"},"update")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"modify")," we can update the value of an ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar"),". The ",(0,r.yg)("inlineCode",{parentName:"p"},"update")," doesn't return the updated value, but the ",(0,r.yg)("inlineCode",{parentName:"p"},"modify")," does:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"class MVar[A] {\n  def update(f: A => A): UIO[Unit] = ???\n  def modify[B](f: A => (B, A)): UIO[B] = ???\n}\n")),(0,r.yg)("p",null,"Like the ",(0,r.yg)("inlineCode",{parentName:"p"},"put")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"take")," operations, the ",(0,r.yg)("inlineCode",{parentName:"p"},"update")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"modify")," operations are blocking, this means if the ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," is empty, they will block the calling fiber until the ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," becomes full."),(0,r.yg)("h2",{id:"use-cases"},"Use Cases"),(0,r.yg)("h3",{id:"simple-onoff-latch"},"Simple On/Off Latch"),(0,r.yg)("p",null,"We can use an ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," to implement a simple on/off latch:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.concurrent.MVar\n\nobject MainApp extends ZIOAppDefault {\n\n  def job1(latch: MVar[Unit]) =\n    for {\n      _ <- ZIO.debug("Job 1: I started my work")\n      _ <- ZIO.sleep(5.second)\n      _ <- ZIO.debug("Job 1: I finished my work")\n      _ <- latch.put(())\n    } yield ()\n\n  def job2(latch: MVar[Unit]) = for {\n    _ <- ZIO.debug("Job 2: I\'m waiting for job 1 to finish its work")\n    _ <- latch.take\n    _ <- ZIO.debug("Job 2: I\'m starting my work")\n    _ <- ZIO.sleep(4.second)\n    _ <- ZIO.debug("Job 2: I finished my work")\n  } yield ()\n\n  def run =\n    MVar.empty[Unit].flatMap { latch =>\n      job1(latch) <&> job2(latch)\n    }\n}\n')),(0,r.yg)("p",null,"In the above example, we created an empty ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar"),", and then we created two ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO")," workflows that will be executed concurrently. The first one will wait for the second one to finish its work. But the second one at some point in its execution will need to synchronize with the first one. It needs to make sure that the first one has finished its work before it continues its own work."),(0,r.yg)("h3",{id:"binary-semaphore"},"Binary Semaphore"),(0,r.yg)("p",null,"Assume we have a function ",(0,r.yg)("inlineCode",{parentName:"p"},"inc")," that takes a ",(0,r.yg)("inlineCode",{parentName:"p"},"Ref[Int]")," and increments its value by one as below:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.concurrent.MVar\n\nobject MainApp extends ZIOAppDefault {\n\n  def inc(ref: Ref[Int]) =\n    for {\n      v <- ref.get\n      result = v + 1\n      _ <- ref.set(result)\n    } yield ()\n    \n  def run =\n    for {\n      ref <- Ref.make(0)\n      _ <- ZIO.foreachParDiscard(1 to 100)(_ => inc(ref))\n      _ <- ref.get.debug("result")\n    } yield ()\n\n}\n')),(0,r.yg)("p",null,"When we perform the ",(0,r.yg)("inlineCode",{parentName:"p"},"inc")," function, 100 times, we expect the final value of the ",(0,r.yg)("inlineCode",{parentName:"p"},"ref")," to be 100. But if we run the program multiple times, we will get different results. This is because the ",(0,r.yg)("inlineCode",{parentName:"p"},"inc")," function is not atomic, and the ",(0,r.yg)("inlineCode",{parentName:"p"},"ref")," may be updated by another thread between the time we read it and the time we write it."),(0,r.yg)("p",null,"So we need a way to ensure that between the time we read the ref and the time we write to it, no other threads will be able to make changes to it."),(0,r.yg)("p",null,"We know that ",(0,r.yg)("inlineCode",{parentName:"p"},"Ref")," has the ",(0,r.yg)("inlineCode",{parentName:"p"},"update")," operation that is atomic. So if we rewrite the ",(0,r.yg)("inlineCode",{parentName:"p"},"inc")," as below, our program will work as expected:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"def inc(ref: Ref[Int]) =\n  ref.update(_ + 1)\n")),(0,r.yg)("p",null,"Although the solution to this problem is ",(0,r.yg)("inlineCode",{parentName:"p"},"Ref#update"),", we want to use ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," to implement the same functionality for pedagogical purposes. So let's see how we can do that using ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.concurrent.MVar\n\nobject MainApp extends ZIOAppDefault {\n\n  def inc(ref: Ref[Int]) =\n    for {\n      v <- ref.get\n      result = v + 1\n      _ <- ref.set(result)\n    } yield ()\n    \n  def run =\n    for {\n      semaphore <- MVar.make[Unit](())\n      ref <- Ref.make(0)\n      _ <- ZIO.foreachParDiscard(1 to 100) { _ =>\n          for {\n            _ <- semaphore.take     // acquire\n            _ <- inc(ref)\n            _ <- semaphore.put(())  // release\n          } yield ()\n      }\n      _ <- ref.get.debug("result")\n    } yield ()\n\n}\n')),(0,r.yg)("p",null,"So we used the ",(0,r.yg)("inlineCode",{parentName:"p"},"take")," as ",(0,r.yg)("inlineCode",{parentName:"p"},"acquire")," and the ",(0,r.yg)("inlineCode",{parentName:"p"},"put")," as the ",(0,r.yg)("inlineCode",{parentName:"p"},"release")," operation of the binary semaphore."),(0,r.yg)("p",null,"Note that, in the above solution, if any interruption occurs while we have acquired the semaphore (between ",(0,r.yg)("inlineCode",{parentName:"p"},"acquire")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"release")," operations), the semaphore will not be released. So to prevent such a situation, we need to make sure that we always release the semaphore whether the critical section runs successfully or not. Let's model the whole solution in a new data type called ",(0,r.yg)("inlineCode",{parentName:"p"},"BinarySemaphore"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.concurrent.MVar\n\nclass BinarySemaphore private (mvar: MVar[Unit]) {\n  def acquire: ZIO[Any, Nothing, Unit] = mvar.take\n\n  def release: ZIO[Any, Nothing, Unit] = mvar.put(())\n\n  def guard[R, E, A](\n      region: ZIO[R, E, A]\n  ): ZIO[R, E, A] =\n    ZIO.acquireReleaseWith(acquire)(_ => release)(_ => region)\n}\n\nobject BinarySemaphore {\n  def make(): ZIO[Any, Nothing, BinarySemaphore] =\n    MVar.make(()).map(new BinarySemaphore(_))\n}\n")),(0,r.yg)("p",null,"Now we can apply the ",(0,r.yg)("inlineCode",{parentName:"p"},"guard")," function to the ",(0,r.yg)("inlineCode",{parentName:"p"},"inc")," function of the previous example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.concurrent.MVar\n\nobject MainApp extends ZIOAppDefault {\n\n  def inc(ref: Ref[Int]) =\n    for {\n      v <- ref.get\n      result = v + 1\n      _ <- ref.set(result)\n    } yield ()\n\n  def run =\n    for {\n      semaphore <- BinarySemaphore.make()\n      ref <- Ref.make(0)\n      _ <- ZIO.foreachParDiscard(1 to 100) { _ =>\n        semaphore.guard(inc(ref))\n      }\n      _ <- ref.get.debug("result")\n    } yield ()\n\n}\n')),(0,r.yg)("h3",{id:"synchronized-mutable-variable"},"Synchronized Mutable Variable"),(0,r.yg)("p",null,"We can have synchronized mutable variables using the ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," data type:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.concurrent.MVar\n\nobject MainApp extends ZIOAppDefault {\n  def inc(state: MVar[Int]) =\n    state.update(_ + 1)\n\n  def run =\n    MVar\n      .make(0)\n      .flatMap(s => ZIO.foreachParDiscard(1 to 100)(_ => inc(s)) *> s.take)\n      .debug("result")\n}\n')),(0,r.yg)("p",null,"In this case, we executed the same ",(0,r.yg)("inlineCode",{parentName:"p"},"inc")," workflow 100 times concurrently. All the concurrent fibers access the same shared mutable variable called ",(0,r.yg)("inlineCode",{parentName:"p"},"state")," in a synchronized way. In this case, we used the ",(0,r.yg)("inlineCode",{parentName:"p"},"update"),", a safe operation that will atomically update the value of ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar"),"."),(0,r.yg)("p",null,"A question that may be raised is that can we compose ",(0,r.yg)("inlineCode",{parentName:"p"},"take")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"update")," to implement the same functionality for the ",(0,r.yg)("inlineCode",{parentName:"p"},"inc")," workflow as below?"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"def inc(state: MVar[Int]) =\n  state.take.flatMap(s => state.put(s + 1))\n")),(0,r.yg)("p",null,"Can we say this is the same as the previous ",(0,r.yg)("inlineCode",{parentName:"p"},"inc")," function? No, because although the ",(0,r.yg)("inlineCode",{parentName:"p"},"take")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"put")," are atomic by themselves, their composition is not. So in a real-world scenario, in a concurrent environment it is possible that in between the ",(0,r.yg)("inlineCode",{parentName:"p"},"take")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"put")," operations, the ",(0,r.yg)("inlineCode",{parentName:"p"},"state")," is modified by another fiber. So this is why we used the ",(0,r.yg)("inlineCode",{parentName:"p"},"update")," operation instead, which is an atomic operation."),(0,r.yg)("h3",{id:"producerconsumer-channel"},"Producer/Consumer Channel"),(0,r.yg)("p",null,"We can use an ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," to implement a producer/consumer channel:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.concurrent.MVar\n\nobject MainApp extends ZIOAppDefault {\n  def producer(state: MVar[Int]) =\n    Random.nextIntBounded(100)\n      .flatMap(state.put)\n      .forever\n \n  def consumer(state: MVar[Int]) =\n    state.take\n      .flatMap(i => ZIO.debug(s"$i consumed!"))\n      .delay(1.second)\n      .forever\n\n  def run =\n    MVar.empty[Int].flatMap { s =>\n      producer(s) <&> consumer(s)\n    }\n}\n')),(0,r.yg)("p",null,"In such a case we want to model a producer/consumer channel to make sure the producer doesn't produce any value unless the consumer is ready to consume it. So in this example, ",(0,r.yg)("inlineCode",{parentName:"p"},"MVar")," acts as one element size channel that handles backpressure. "),(0,r.yg)("p",null,"If we add more consumers, the speed of consuming elements will be increased. Note that, by having multiple consumers, the data will not be duplicated through the consumers. If we have three consumers, each piece of data will be consumed only by one of the consumers:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.concurrent.MVar\n\nobject MainApp extends ZIOAppDefault {\n  def producer(state: MVar[Int]) =\n    ZIO.foreachDiscard(1 to Int.MaxValue)(state.put)\n\n  def consumer(state: MVar[Int])(name: String) =\n    state.take\n      .flatMap(i => ZIO.debug(s"Consumer $name: $i consumed!"))\n      .delay(1.second)\n      .forever\n\n  def run =\n    MVar.empty[Int].flatMap { s =>\n      producer(s) <&>\n        consumer(s)("A") <&> consumer(s)("B") <&> consumer(s)("C")\n    }\n}\n')))}m.isMDXComponent=!0}}]);