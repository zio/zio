"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[57510],{15680:(e,t,n)=>{n.d(t,{xA:()=>m,yg:()=>u});var r=n(96540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},g="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),g=l(n),d=o,u=g["".concat(p,".").concat(d)]||g[d]||c[d]||a;return n?r.createElement(u,i(i({ref:t},m),{},{components:n})):r.createElement(u,i({ref:t},m))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[g]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},37626:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(58168),o=(n(96540),n(15680));const a={id:"opentelemetry",title:"OpenTelemetry"},i=void 0,s={unversionedId:"zio-telemetry/opentelemetry",id:"zio-telemetry/opentelemetry",title:"OpenTelemetry",description:"OpenTelemetry is a collection of tools, APIs, and SDKs. You can use it to instrument, generate, collect, and export telemetry data for analysis in order to understand your software's performance and behavior. Well known implementations are Jaeger and Zipkin.",source:"@site/docs/zio-telemetry/opentelemetry.md",sourceDirName:"zio-telemetry",slug:"/zio-telemetry/opentelemetry",permalink:"/zio-telemetry/opentelemetry",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-telemetry/opentelemetry.md",tags:[],version:"current",frontMatter:{id:"opentelemetry",title:"OpenTelemetry"},sidebar:"ecosystem-sidebar",previous:{title:"OpenCensus",permalink:"/zio-telemetry/opencensus"},next:{title:"OpenTelemetry Example",permalink:"/zio-telemetry/opentelemetry-example"}},p={},l=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Tracing",id:"tracing",level:3},{value:"Metrics",id:"metrics",level:3},{value:"Logging",id:"logging",level:3},{value:"Baggage",id:"baggage",level:3},{value:"Context Propagation",id:"context-propagation",level:3},{value:"Usage with OpenTelemetry automatic instrumentation",id:"usage-with-opentelemetry-automatic-instrumentation",level:3}],m={toc:l},g="wrapper";function c(e){let{components:t,...n}=e;return(0,o.yg)(g,(0,r.A)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"OpenTelemetry is a collection of tools, APIs, and SDKs. You can use it to instrument, generate, collect, and export telemetry data for analysis in order to understand your software's performance and behavior. Well known implementations are ",(0,o.yg)("a",{parentName:"p",href:"https://www.jaegertracing.io"},"Jaeger")," and ",(0,o.yg)("a",{parentName:"p",href:"https://www.zipkin.io"},"Zipkin"),"."),(0,o.yg)("p",null,"The library provides an idiomatic ZIO 2.0 interface to OpenTelemetry, ensuring seamless interoperability with the native ZIO capabilities and beyond."),(0,o.yg)("p",null,"Some of the key features:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"ZIO native")," - Pleasant API that leverages native ZIO features, such as ",(0,o.yg)("a",{parentName:"li",href:"https://zio.dev/reference/resource/"},"Resource Management"),", ",(0,o.yg)("a",{parentName:"li",href:"https://zio.dev/reference/di/"},"Depenency Injection"),", ",(0,o.yg)("a",{parentName:"li",href:"https://zio.dev/reference/stream/"},"Streaming"),", ",(0,o.yg)("a",{parentName:"li",href:"https://zio.dev/reference/observability/logging"},"Logging"),", ",(0,o.yg)("a",{parentName:"li",href:"https://zio.dev/reference/observability/metrics/"},"Metrics"),", and ",(0,o.yg)("a",{parentName:"li",href:"https://zio.dev/reference/core/zio/#zio-aspect"},"ZIO Aspect")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"OpenTelemetry Java SDK and ZIO Runtime interoperability")," - Protecting users from directly engaging in OTEL context manipulations, offering a straightforward and clear interface for instrumenting spans, metrics, logs, and baggage. In this scenario, the ZIO effect serves as the span's scope."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Seamless signals correlation")," -  Automatically correlates spans, metrics, and logs with a surrounding span."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Integration with ZIO capabilities")," - Propagation of log annotations, metrics, and other data from the ZIO runtime as OTEL attributes and metrics.")),(0,o.yg)("h2",{id:"installation"},"Installation"),(0,o.yg)("p",null,"Add the following dependency to your ",(0,o.yg)("inlineCode",{parentName:"p"},"build.sbt")," to use OpenTelemetry inside your ZIO application:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'"dev.zio" %% "zio-opentelemetry" % "<version>"\n')),(0,o.yg)("p",null,"You will also need SDK dependencies to be able to provide configured instances of ",(0,o.yg)("a",{parentName:"p",href:"https://javadoc.io/doc/io.opentelemetry/opentelemetry-api/latest/io/opentelemetry/api/trace/Tracer.html"},"Tracer"),", ",(0,o.yg)("a",{parentName:"p",href:"https://javadoc.io/static/io.opentelemetry/opentelemetry-api/1.33.0/io/opentelemetry/api/metrics/Meter.html"},"Meter"),", and ",(0,o.yg)("a",{parentName:"p",href:"https://javadoc.io/doc/io.opentelemetry/opentelemetry-api/latest/io/opentelemetry/api/logs/Logger.html"},"Logger"),", such as:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'"io.opentelemetry"         % "opentelemetry-sdk"           % <opentelemetry-java-version>\n"io.opentelemetry"         % "opentelemetry-exporter-otlp" % <opentelemetry-java-version>\n"io.opentelemetry.semconv" % "opentelemetry-semconv"       % <opentelemetry-java-version>\n')),(0,o.yg)("p",null,"For the complete list of available Java artifacts, please consult the information available at the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-java#releases"},"link")),(0,o.yg)("h2",{id:"usage"},"Usage"),(0,o.yg)("p",null,"All examples below can be run using amazing ",(0,o.yg)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"Scala CLI"),". You can find their full copies in the ",(0,o.yg)("inlineCode",{parentName:"p"},"scala-cli/opentelemetry/")," directory. To run, type ",(0,o.yg)("inlineCode",{parentName:"p"},"scala-cli <AppName>.scala")," while in the directory where the file is located."),(0,o.yg)("h3",{id:"tracing"},"Tracing"),(0,o.yg)("p",null,"To send ",(0,o.yg)("a",{parentName:"p",href:"https://opentelemetry.io/docs/concepts/signals/traces/"},"Trace signals"),", you will need a ",(0,o.yg)("inlineCode",{parentName:"p"},"Tracing")," service in your environment. For this, use the ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry.tracing")," layer which in turn requires an instance of ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry")," provided by Java SDK and a suitable ",(0,o.yg)("inlineCode",{parentName:"p"},"ContextStorage")," implementation. The ",(0,o.yg)("inlineCode",{parentName:"p"},"Tracing")," API includes methods for creating spans, as well as for adding attributes and events to them.\nHere are some of the main ones:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"root")," - sets the current span to be the new root span"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"span")," - sets the current span to be the child of the current span"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"spanScoped")," - sets the current span to be the child of the current span, but ends it only when the scope closes"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"extractSpan")," - extracts the span from carrier and set its child span to be the current span"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"injectSpan")," - injects the current span into carrier"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"setAttribute")," - sets an attribute of the current span"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"addEvent")," - adds an event to the current span")),(0,o.yg)("p",null,"Some of the methods above are available via ",(0,o.yg)("a",{parentName:"p",href:"https://zio.dev/reference/core/zio/#zio-aspect"},"ZIO Aspect")," syntax. "),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'//> using scala "2.13.12"\n//> using dep dev.zio::zio:2.0.20\n//> using dep dev.zio::zio-opentelemetry:3.0.0-RC20\n//> using dep io.opentelemetry:opentelemetry-sdk:1.33.0\n//> using dep io.opentelemetry:opentelemetry-sdk-trace:1.33.0\n//> using dep io.opentelemetry:opentelemetry-exporter-logging-otlp:1.33.0\n//> using dep io.opentelemetry.semconv:opentelemetry-semconv:1.22.0-alpha\n\nimport io.opentelemetry.exporter.logging.otlp.OtlpJsonLoggingSpanExporter\nimport io.opentelemetry.api.trace.SpanKind\nimport io.opentelemetry.sdk.trace.SdkTracerProvider\nimport io.opentelemetry.sdk.trace.export.SimpleSpanProcessor\nimport io.opentelemetry.sdk.resources.Resource\nimport io.opentelemetry.semconv.ResourceAttributes\nimport io.opentelemetry.api.common.Attributes\nimport io.opentelemetry.sdk.OpenTelemetrySdk\nimport io.opentelemetry.api\nimport zio._\nimport zio.telemetry.opentelemetry.tracing.Tracing\nimport zio.telemetry.opentelemetry.OpenTelemetry\nimport zio.telemetry.opentelemetry.context.ContextStorage\n\nobject TracingApp extends ZIOAppDefault {\n\n  val instrumentationScopeName = "dev.zio.TracingApp"\n  val resourceName             = "tracing-app"\n\n  // Prints to stdout in OTLP Json format\n  val stdoutTracerProvider: RIO[Scope, SdkTracerProvider] =\n    for {\n      spanExporter   <- ZIO.fromAutoCloseable(ZIO.succeed(OtlpJsonLoggingSpanExporter.create()))\n      spanProcessor  <- ZIO.fromAutoCloseable(ZIO.succeed(SimpleSpanProcessor.create(spanExporter)))\n      tracerProvider <-\n        ZIO.fromAutoCloseable(\n          ZIO.succeed(\n            SdkTracerProvider\n              .builder()\n              .setResource(Resource.create(Attributes.of(ResourceAttributes.SERVICE_NAME, resourceName)))\n              .addSpanProcessor(spanProcessor)\n              .build()\n          )\n        )\n    } yield tracerProvider\n\n  val otelSdkLayer: TaskLayer[api.OpenTelemetry] =\n    OpenTelemetry.custom(\n      for {\n        tracerProvider <- stdoutTracerProvider\n        sdk            <- ZIO.fromAutoCloseable(\n                            ZIO.succeed(\n                              OpenTelemetrySdk\n                                .builder()\n                                .setTracerProvider(tracerProvider)\n                                .build()\n                            )\n                          )\n      } yield sdk\n    )\n\n  override def run =\n    ZIO\n      .serviceWithZIO[Tracing] { tracing =>\n        val logic = for {\n          // Set an attribute to the current span\n          _       <- tracing.setAttribute("attr1", "value1")\n          // Add an event to the current span\n          _       <- tracing.addEvent("Waiting for the user input")\n          // Read user input\n          message <- Console.readLine\n          // Add another event to the current span\n          _       <- tracing.addEvent(s"User typed: $message")\n        } yield message\n\n        // Create a root span with a lifetime equal to the runtime of the given ZIO effect.\n        // We use ZIO Aspect\'s @@ syntax here just for the sake of example.\n        logic @@ tracing.aspects.root("root_span", SpanKind.INTERNAL)\n      }\n      .provide(\n        otelSdkLayer,\n        ContextStorage.fiberRef,\n        OpenTelemetry.tracing(instrumentationScopeName)\n      )\n\n}\n\n')),(0,o.yg)("h3",{id:"metrics"},"Metrics"),(0,o.yg)("p",null,"To send ",(0,o.yg)("a",{parentName:"p",href:"https://opentelemetry.io/docs/concepts/signals/metrics/"},"Metric signals"),", you will need a ",(0,o.yg)("inlineCode",{parentName:"p"},"Meter")," service in your environment. For this, use the ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry.meter")," layer which in turn requires an instance of ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry")," provided by Java SDK and a suitable ",(0,o.yg)("inlineCode",{parentName:"p"},"ContextStorage")," implementation. The ",(0,o.yg)("inlineCode",{parentName:"p"},"Meter")," API lets you create ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/api.md#counter"},"Counter"),", ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/api.md#updowncounter"},"UpDownCounter"),", ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/api.md#gauge"},"Gauge"),", ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/api.md#histogram"},"Histogram")," and their ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/api.md#asynchronous-instrument-api"},"asynchronous")," (aka observable) counterparts.\nAs a rule of thumb, observable instruments must be initialized on an application startup. They are scoped, so you should not be worried about shutting them down manually."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'//> using scala "2.13.12"\n//> using dep dev.zio::zio:2.0.20\n//> using dep dev.zio::zio-opentelemetry:3.0.0-RC20\n//> using dep io.opentelemetry:opentelemetry-sdk:1.33.0\n//> using dep io.opentelemetry:opentelemetry-sdk-trace:1.33.0\n//> using dep io.opentelemetry:opentelemetry-exporter-logging-otlp:1.33.0\n//> using dep io.opentelemetry.semconv:opentelemetry-semconv:1.22.0-alpha\n\nimport io.opentelemetry.sdk.trace.SdkTracerProvider\nimport io.opentelemetry.sdk.trace.export.SimpleSpanProcessor\nimport io.opentelemetry.sdk.metrics.SdkMeterProvider\nimport io.opentelemetry.sdk.metrics.export.PeriodicMetricReader\nimport io.opentelemetry.sdk.resources.Resource\nimport io.opentelemetry.api.common\nimport io.opentelemetry.semconv.ResourceAttributes\nimport io.opentelemetry.exporter.logging.otlp.OtlpJsonLoggingSpanExporter\nimport io.opentelemetry.exporter.logging.otlp.OtlpJsonLoggingMetricExporter\nimport io.opentelemetry.sdk.OpenTelemetrySdk\nimport io.opentelemetry.api\nimport zio._\nimport zio.telemetry.opentelemetry.tracing.Tracing\nimport zio.telemetry.opentelemetry.metrics.Meter\nimport zio.telemetry.opentelemetry.common.Attributes\nimport zio.telemetry.opentelemetry.common.Attribute\nimport zio.telemetry.opentelemetry.OpenTelemetry\nimport zio.telemetry.opentelemetry.context.ContextStorage\n\nobject MetricsApp extends ZIOAppDefault {\n\n  val instrumentationScopeName = "dev.zio.MetricsApp"\n  val resourceName             = "metrics-app"\n\n  // Prints to stdout in OTLP Json format\n  val stdoutMeterProvider: RIO[Scope, SdkMeterProvider] =\n    for {\n      metricExporter <- ZIO.fromAutoCloseable(ZIO.succeed(OtlpJsonLoggingMetricExporter.create()))\n      metricReader   <-\n        ZIO.fromAutoCloseable(ZIO.succeed(PeriodicMetricReader.builder(metricExporter).setInterval(5.second).build()))\n      meterProvider  <-\n        ZIO.fromAutoCloseable(\n          ZIO.succeed(\n            SdkMeterProvider\n              .builder()\n              .registerMetricReader(metricReader)\n              .setResource(Resource.create(common.Attributes.of(ResourceAttributes.SERVICE_NAME, resourceName)))\n              .build()\n          )\n        )\n    } yield meterProvider\n\n  // Prints to stdout in OTLP Json format\n  val stdoutTracerProvider: RIO[Scope, SdkTracerProvider] =\n    for {\n      spanExporter   <- ZIO.fromAutoCloseable(ZIO.succeed(OtlpJsonLoggingSpanExporter.create()))\n      spanProcessor  <- ZIO.fromAutoCloseable(ZIO.succeed(SimpleSpanProcessor.create(spanExporter)))\n      tracerProvider <-\n        ZIO.fromAutoCloseable(\n          ZIO.succeed(\n            SdkTracerProvider\n              .builder()\n              .setResource(Resource.create(common.Attributes.of(ResourceAttributes.SERVICE_NAME, resourceName)))\n              .addSpanProcessor(spanProcessor)\n              .build()\n          )\n        )\n    } yield tracerProvider\n\n  val otelSdkLayer: TaskLayer[api.OpenTelemetry] =\n    OpenTelemetry.custom(\n      for {\n        tracerProvider <- stdoutTracerProvider\n        meterProvider  <- stdoutMeterProvider\n        sdk            <- ZIO.fromAutoCloseable(\n                            ZIO.succeed(\n                              OpenTelemetrySdk\n                                .builder()\n                                .setTracerProvider(tracerProvider)\n                                .setMeterProvider(meterProvider)\n                                .build()\n                            )\n                          )\n      } yield sdk\n    )\n\n  // Stores the number of seconds elapsed since the application startup\n  val tickRefLayer: ULayer[Ref[Long]] =\n    ZLayer(\n      for {\n        ref <- Ref.make(0L)\n        _   <- ref\n                 .update(_ + 1)\n                 .repeat[Any, Long](Schedule.spaced(1.second))\n                 .forkDaemon\n      } yield ref\n    )\n\n  // Records the number of seconds elapsed since the application startup\n  val tickCounterLayer: RLayer[Meter with Ref[Long], Unit] =\n    ZLayer.scoped(\n      for {\n        meter <- ZIO.service[Meter]\n        ref   <- ZIO.service[Ref[Long]]\n        // Initialize observable counter instrument\n        _     <- meter.observableCounter("tick_counter") { om =>\n                   for {\n                     tick <- ref.get\n                     _    <- om.record(tick)\n                   } yield ()\n                 }\n      } yield ()\n    )\n\n  override def run =\n    ZIO\n      .serviceWithZIO[Tracing] { tracing =>\n        val logic = for {\n          meter                <- ZIO.service[Meter]\n          // Create a counter\n          messageLengthCounter <- meter.counter("message_length_counter")\n          // Read user input\n          message              <- Console.readLine\n          // Sleep for the number of seconds equal to the message length  to demonstrate the work of observable counter\n          _                    <- ZIO.sleep(message.length.seconds)\n          // Record the message length\n          _                    <- messageLengthCounter.add(message.length, Attributes(Attribute.string("message", message)))\n        } yield message\n\n        // By wrapping our logic into a span, we make the `messageLengthCounter` data points correlated with a "root_span" automatically\n        logic @@ tracing.aspects.root("root_span")\n      }\n      .provide(\n        otelSdkLayer,\n        ContextStorage.fiberRef,\n        OpenTelemetry.meter(instrumentationScopeName),\n        OpenTelemetry.tracing(instrumentationScopeName),\n        tickCounterLayer,\n        tickRefLayer\n      )\n\n}\n')),(0,o.yg)("h3",{id:"logging"},"Logging"),(0,o.yg)("p",null,"To send ",(0,o.yg)("a",{parentName:"p",href:"https://opentelemetry.io/docs/concepts/signals/logs/"},"Log signals"),", you will need a ",(0,o.yg)("inlineCode",{parentName:"p"},"Logging")," service in your environment. For this, use the ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry.logging")," layer which in turn requires an instance of ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry")," provided by Java SDK and a suitable ",(0,o.yg)("inlineCode",{parentName:"p"},"ContextStorage")," implementation. You can achieve the same by incorporating ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/logger-mdc-instrumentation.md"},"Logger MDC auto-instrumentation"),", so the rule of thumb is to use the ",(0,o.yg)("inlineCode",{parentName:"p"},"Logging")," service when you need to propagate ZIO log annotations as log record attributes or, for some reason you don't want to use auto-instrumentation."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'//> using scala "2.13.12"\n//> using dep dev.zio::zio:2.0.20\n//> using dep dev.zio::zio-opentelemetry:3.0.0-RC20\n//> using dep io.opentelemetry:opentelemetry-sdk:1.33.0\n//> using dep io.opentelemetry:opentelemetry-sdk-trace:1.33.0\n//> using dep io.opentelemetry:opentelemetry-exporter-logging-otlp:1.33.0\n//> using dep io.opentelemetry.semconv:opentelemetry-semconv:1.22.0-alpha\n\nimport io.opentelemetry.exporter.logging.otlp.OtlpJsonLoggingSpanExporter\nimport io.opentelemetry.exporter.logging.otlp.OtlpJsonLoggingLogRecordExporter\nimport io.opentelemetry.api.common.Attributes\nimport io.opentelemetry.sdk.trace.SdkTracerProvider\nimport io.opentelemetry.sdk.trace.export.SimpleSpanProcessor\nimport io.opentelemetry.sdk.logs.SdkLoggerProvider\nimport io.opentelemetry.sdk.logs.`export`.SimpleLogRecordProcessor\nimport io.opentelemetry.sdk.resources.Resource\nimport io.opentelemetry.semconv.ResourceAttributes\nimport io.opentelemetry.sdk.OpenTelemetrySdk\nimport io.opentelemetry.api\nimport zio._\nimport zio.telemetry.opentelemetry.tracing.Tracing\nimport zio.telemetry.opentelemetry.OpenTelemetry\nimport zio.telemetry.opentelemetry.context.ContextStorage\n\nobject LoggingApp extends ZIOAppDefault {\n\n  val instrumentationScopeName = "dev.zio.LoggingApp"\n  val resourceName             = "logging-app"\n\n  // Prints to stdout in OTLP Json format\n  val stdoutLoggerProvider: RIO[Scope, SdkLoggerProvider] =\n    for {\n      logRecordExporter  <- ZIO.fromAutoCloseable(ZIO.succeed(OtlpJsonLoggingLogRecordExporter.create()))\n      logRecordProcessor <- ZIO.fromAutoCloseable(ZIO.succeed(SimpleLogRecordProcessor.create(logRecordExporter)))\n      loggerProvider     <-\n        ZIO.fromAutoCloseable(\n          ZIO.succeed(\n            SdkLoggerProvider\n              .builder()\n              .setResource(Resource.create(Attributes.of(ResourceAttributes.SERVICE_NAME, resourceName)))\n              .addLogRecordProcessor(logRecordProcessor)\n              .build()\n          )\n        )\n    } yield loggerProvider\n\n  // Prints to stdout in OTLP Json format\n  val stdoutTracerProvider: RIO[Scope, SdkTracerProvider] =\n    for {\n      spanExporter   <- ZIO.fromAutoCloseable(ZIO.succeed(OtlpJsonLoggingSpanExporter.create()))\n      spanProcessor  <- ZIO.fromAutoCloseable(ZIO.succeed(SimpleSpanProcessor.create(spanExporter)))\n      tracerProvider <-\n        ZIO.fromAutoCloseable(\n          ZIO.succeed(\n            SdkTracerProvider\n              .builder()\n              .setResource(Resource.create(Attributes.of(ResourceAttributes.SERVICE_NAME, resourceName)))\n              .addSpanProcessor(spanProcessor)\n              .build()\n          )\n        )\n    } yield tracerProvider\n\n  val otelSdkLayer: TaskLayer[api.OpenTelemetry] =\n    OpenTelemetry.custom(\n      for {\n        tracerProvider <- stdoutTracerProvider\n        loggerProvider <- stdoutLoggerProvider\n        sdk            <- ZIO.fromAutoCloseable(\n                            ZIO.succeed(\n                              OpenTelemetrySdk\n                                .builder()\n                                .setTracerProvider(tracerProvider)\n                                .setLoggerProvider(loggerProvider)\n                                .build()\n                            )\n                          )\n      } yield sdk\n    )\n\n  override def run =\n    ZIO\n      .serviceWithZIO[Tracing] { tracing =>\n        val logic = for {\n          // Read user input\n          message <- Console.readLine\n          // Propagate a ZIO.logInfo message as an OTEL log signal and log annotations as log record attributes\n          _       <- ZIO.logAnnotate("correlated", "true")(\n                       ZIO.logInfo(s"User message: $message")\n                     )\n        } yield ()\n\n        // All log messages produced by logic will be correlated with a "root_span" automatically\n        logic @@ tracing.aspects.root("root_span")\n      }\n      .provide(\n        otelSdkLayer,\n        ContextStorage.fiberRef,\n        OpenTelemetry.logging(instrumentationScopeName),\n        OpenTelemetry.tracing(instrumentationScopeName)\n      )\n\n}\n')),(0,o.yg)("h3",{id:"baggage"},"Baggage"),(0,o.yg)("p",null,"To pass contextual information in ",(0,o.yg)("a",{parentName:"p",href:"https://opentelemetry.io/docs/concepts/signals/baggage/"},"Baggage"),", you will need a ",(0,o.yg)("inlineCode",{parentName:"p"},"Baggage")," service in your environment. For this, use the ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry.logging")," layer which in turn requires an instance of ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry")," provided by Java SDK and a suitable ",(0,o.yg)("inlineCode",{parentName:"p"},"ContextStorage")," implementation. The ",(0,o.yg)("inlineCode",{parentName:"p"},"Baggage")," API includes methods for getting/setting key/value pairs and injecting/extracting baggage data using the current context. By default the ",(0,o.yg)("inlineCode",{parentName:"p"},"Baggage")," service does not take ZIO log annotations into account. To turn it on use ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry.baggage(logAnnotated = true)"),"."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'//> using scala "2.13.12"\n//> using dep dev.zio::zio:2.0.20\n//> using dep dev.zio::zio-opentelemetry:3.0.0-RC20\n\nimport zio._\nimport zio.telemetry.opentelemetry.baggage.Baggage\nimport zio.telemetry.opentelemetry.baggage.propagation.BaggagePropagator\nimport zio.telemetry.opentelemetry.context.ContextStorage\nimport zio.telemetry.opentelemetry.OpenTelemetry\n\nobject BaggageApp extends ZIOAppDefault {\n\n  override def run =\n    ZIO\n      .serviceWithZIO[Baggage] { baggage =>\n        for {\n          // Read user input\n          message <- Console.readLine\n          // Set baggage key/value\n          _       <- baggage.set("message", message)\n          // Read all baggage data including ZIO log annotations\n          data    <- ZIO.logAnnotate("message2", "annotation")(\n                       baggage.getAll\n                     )\n          // Print the resulting data\n          _       <- Console.printLine(s"Baggage data: $data")\n        } yield message\n      }\n      .provide(\n        ContextStorage.fiberRef,\n        OpenTelemetry.baggage(logAnnotated = true)\n      )\n\n}\n\n')),(0,o.yg)("h3",{id:"context-propagation"},"Context Propagation"),(0,o.yg)("p",null,"Explicitly utilizing the context propagation API becomes relevant only when auto-instrumentation is not used.\nPlease note that injection and extraction are not referentially transparent due to the use of the mutable OpenTelemetry carrier Java API."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'//> using scala "2.13.12"\n//> using dep dev.zio::zio:2.0.20\n//> using dep dev.zio::zio-opentelemetry:3.0.0-RC20\n//> using dep io.opentelemetry:opentelemetry-sdk:1.33.0\n//> using dep io.opentelemetry:opentelemetry-sdk-trace:1.33.0\n//> using dep io.opentelemetry:opentelemetry-exporter-logging-otlp:1.33.0\n//> using dep io.opentelemetry.semconv:opentelemetry-semconv:1.22.0-alpha\n\nimport io.opentelemetry.exporter.logging.otlp.OtlpJsonLoggingSpanExporter\nimport io.opentelemetry.api.trace.SpanKind\nimport io.opentelemetry.sdk.trace.SdkTracerProvider\nimport io.opentelemetry.sdk.trace.export.SimpleSpanProcessor\nimport io.opentelemetry.sdk.resources.Resource\nimport io.opentelemetry.semconv.ResourceAttributes\nimport io.opentelemetry.api.common.Attributes\nimport io.opentelemetry.sdk.OpenTelemetrySdk\nimport io.opentelemetry.api\nimport zio._\nimport zio.telemetry.opentelemetry.baggage.Baggage\nimport zio.telemetry.opentelemetry.baggage.propagation.BaggagePropagator\nimport zio.telemetry.opentelemetry.tracing.Tracing\nimport zio.telemetry.opentelemetry.tracing.propagation.TraceContextPropagator\nimport zio.telemetry.opentelemetry.OpenTelemetry\nimport zio.telemetry.opentelemetry.context.ContextStorage\nimport zio.telemetry.opentelemetry.context.IncomingContextCarrier\nimport zio.telemetry.opentelemetry.context.OutgoingContextCarrier\nimport scala.collection.mutable\n\nobject PropagatingApp extends ZIOAppDefault {\n\n  val instrumentationScopeName = "dev.zio.PropagatingApp"\n  val resourceName             = "propagating-app"\n\n  // Prints to stdout in OTLP Json format\n  val stdoutTracerProvider: RIO[Scope, SdkTracerProvider] =\n    for {\n      spanExporter   <- ZIO.fromAutoCloseable(ZIO.succeed(OtlpJsonLoggingSpanExporter.create()))\n      spanProcessor  <- ZIO.fromAutoCloseable(ZIO.succeed(SimpleSpanProcessor.create(spanExporter)))\n      tracerProvider <-\n        ZIO.fromAutoCloseable(\n          ZIO.succeed(\n            SdkTracerProvider\n              .builder()\n              .setResource(Resource.create(Attributes.of(ResourceAttributes.SERVICE_NAME, resourceName)))\n              .addSpanProcessor(spanProcessor)\n              .build()\n          )\n        )\n    } yield tracerProvider\n\n  val otelSdkLayer: TaskLayer[api.OpenTelemetry] =\n    OpenTelemetry.custom(\n      for {\n        tracerProvider <- stdoutTracerProvider\n        sdk            <- ZIO.fromAutoCloseable(\n                            ZIO.succeed(\n                              OpenTelemetrySdk\n                                .builder()\n                                .setTracerProvider(tracerProvider)\n                                .build()\n                            )\n                          )\n      } yield sdk\n    )\n\n  override def run =\n    ZIO\n      .serviceWithZIO[Tracing] { tracing =>\n        val tracePropagator   = TraceContextPropagator.default\n        val baggagePropagator = BaggagePropagator.default\n        // Using the same kernel and carriers for baggage and tracing context propagation is safe\n        // since their encodings occup\u0443 different keys in the OTEL context.\n        val kernel            = mutable.Map.empty[String, String]\n        val outgoingCarrier   = OutgoingContextCarrier.default(kernel)\n        val incomingCarrier   = IncomingContextCarrier.default(kernel)\n\n        ZIO.serviceWithZIO[Baggage] { baggage =>\n          // Representing upstream service\n          val upstreamService = for {\n            // Read user input\n            message <- Console.readLine\n            // Set and propagate the baggage data using outgoing carrier\n            _       <- baggage.set("message", message)\n            _       <- baggage.inject(baggagePropagator, outgoingCarrier)\n            // Emulate the computation to be wrapped in a root span\n            logic    = for {\n                         _ <- ZIO.logInfo(s"Message length is ${message.length}")\n                         // Inject the current span using outgoing carrier\n                         _ <- tracing.injectSpan(tracePropagator, outgoingCarrier)\n                       } yield ()\n            // Run the logic, wrapping it into a root span\n            _       <- logic @@ tracing.aspects.root("upstream_root_span")\n          } yield ()\n\n          // Representing downstream service\n          val downstreamService = for {\n            // Extract the baggage data using incoming carrier\n            _      <- baggage.extract(baggagePropagator, incomingCarrier)\n            data   <- baggage.getAll\n            message = data("message")\n            // Emulate the logic that computes message length and sets an attribute of the current span\n            logic   = for {\n                        _ <- ZIO.logInfo(s"Message length is ${message.length}")\n                        _ <- tracing.setAttribute("message", message)\n                      } yield ()\n            // Run the logic, wrapping it into a child span of the upstream root span\n            _      <- logic @@ tracing.aspects.extractSpan(tracePropagator, incomingCarrier, "downstream_root_span")\n          } yield ()\n\n          // Simulate the interaction between services\n          upstreamService *> downstreamService\n        }\n\n      }\n      .provide(\n        otelSdkLayer,\n        ContextStorage.fiberRef,\n        OpenTelemetry.tracing(instrumentationScopeName),\n        OpenTelemetry.baggage()\n      )\n\n}\n')),(0,o.yg)("h3",{id:"usage-with-opentelemetry-automatic-instrumentation"},"Usage with OpenTelemetry automatic instrumentation"),(0,o.yg)("p",null,"OpenTelemetry provides a ",(0,o.yg)("a",{parentName:"p",href:"https://opentelemetry.io/docs/instrumentation/java/automatic/"},"JVM agent for automatic instrumentation")," which supports many ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md"},"popular Java libraries"),".\nSince ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases/tag/v1.25.0"},"version 1.25.0")," OpenTelemetry JVM agent supports ZIO."),(0,o.yg)("p",null,"To enable interoperability between automatic instrumentation and ",(0,o.yg)("inlineCode",{parentName:"p"},"zio-opentelemetry"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"Tracing")," has to be created\nusing ",(0,o.yg)("inlineCode",{parentName:"p"},"ContextStorage")," backed by OpenTelemetry's native ",(0,o.yg)("inlineCode",{parentName:"p"},"Context")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"Tracer")," provided by globally registered ",(0,o.yg)("inlineCode",{parentName:"p"},"TracerProvider"),". It means that instead of ",(0,o.yg)("inlineCode",{parentName:"p"},"ContextStorage.fiberRef")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry.custom")," you have to provide ",(0,o.yg)("inlineCode",{parentName:"p"},"ContextStorage.native")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"OpenTelemetry.global")," layers."))}c.isMDXComponent=!0}}]);