"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[70580],{95788:(e,t,a)=>{a.d(t,{Iu:()=>d,yg:()=>u});var n=a(11504);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(a),y=i,u=c["".concat(s,".").concat(y)]||c[y]||g[y]||o;return a?n.createElement(u,r(r({ref:t},d),{},{components:a})):n.createElement(u,r({ref:t},d))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=y;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}y.displayName="MDXCreateElement"},68332:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=a(45072),i=(a(11504),a(95788));const o={id:"index",title:"Introduction to ZIO Prelude",sidebar_label:"ZIO Prelude"},r=void 0,l={unversionedId:"zio-prelude/index",id:"zio-prelude/index",title:"Introduction to ZIO Prelude",description:"ZIO Prelude is a lightweight, distinctly Scala takes on functional abstractions, with tight ZIO integration.",source:"@site/docs/zio-prelude/index.md",sourceDirName:"zio-prelude",slug:"/zio-prelude/",permalink:"/zio-prelude/",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/index.md",tags:[],version:"current",frontMatter:{id:"index",title:"Introduction to ZIO Prelude",sidebar_label:"ZIO Prelude"},sidebar:"ecosystem-sidebar",previous:{title:"ZIO Parser",permalink:"/zio-parser/"},next:{title:"Abstraction Diagrams",permalink:"/zio-prelude/abstraction-diagrams"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Example",id:"example",level:2}],d={toc:p},c="wrapper";function g(e){let{components:t,...a}=e;return(0,i.yg)(c,(0,n.c)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://github.com/zio/zio-prelude"},"ZIO Prelude")," is a lightweight, distinctly Scala takes on ",(0,i.yg)("strong",{parentName:"p"},"functional abstractions"),", with tight ZIO integration."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://github.com/zio/zio/wiki/Project-Stages"},(0,i.yg)("img",{parentName:"a",src:"https://img.shields.io/badge/Project%20Stage-Production%20Ready-brightgreen.svg",alt:"Production Ready"}))," ",(0,i.yg)("img",{parentName:"p",src:"https://github.com/zio/zio-prelude/workflows/CI/badge.svg",alt:"CI Badge"})," ",(0,i.yg)("a",{parentName:"p",href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-prelude_2.13/"},(0,i.yg)("img",{parentName:"a",src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-prelude_2.13.svg?label=Sonatype%20Release",alt:"Sonatype Releases"}))," ",(0,i.yg)("a",{parentName:"p",href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-prelude_2.13/"},(0,i.yg)("img",{parentName:"a",src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-prelude_2.13.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"}))," ",(0,i.yg)("a",{parentName:"p",href:"https://javadoc.io/doc/dev.zio/zio-prelude-docs_2.13"},(0,i.yg)("img",{parentName:"a",src:"https://javadoc.io/badge2/dev.zio/zio-prelude-docs_2.13/javadoc.svg",alt:"javadoc"}))," ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/zio/zio-prelude"},(0,i.yg)("img",{parentName:"a",src:"https://img.shields.io/github/stars/zio/zio-prelude?style=social",alt:"ZIO Prelude"}))),(0,i.yg)("h2",{id:"introduction"},"Introduction"),(0,i.yg)("p",null,"ZIO Prelude is a small library that brings common, useful algebraic abstractions and data types to scala developers. It is an alternative to libraries like ",(0,i.yg)("em",{parentName:"p"},"Scalaz")," and ",(0,i.yg)("em",{parentName:"p"},"Cats")," based on radical ideas that embrace ",(0,i.yg)("strong",{parentName:"p"},"modularity")," and ",(0,i.yg)("strong",{parentName:"p"},"subtyping")," in Scala and offer ",(0,i.yg)("strong",{parentName:"p"},"new levels of power and ergonomics"),". It throws out the classic functor hierarchy in favor of a modular algebraic approach that is smaller, easier to understand and teach, and more expressive."),(0,i.yg)("p",null,"ZIO Prelude has three key areas of focus:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Data structures, and type classes for traversing them.")," ZIO Prelude embraces the collections in the Scala standard library, and extends them with new instances and new useful additions."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Patterns of composition for types.")," ZIO Prelude provides a small catalog of patterns for binary operators, which combine two values into another value of the same type. These patterns are named after the algebraic laws they satisfy: associativity, commutativity, and identity."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Patterns of composition for type constructors.")," ZIO Prelude provides a catalog of patterns for binary operators on type constructors (things like ",(0,i.yg)("inlineCode",{parentName:"li"},"Future"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"Option"),", ZIO ",(0,i.yg)("inlineCode",{parentName:"li"},"Task"),"). These patterns are named after the algebraic laws they satisfy (associativity, commutativity, and identity) and the structure they produce, whether a tuple or an either.")),(0,i.yg)("p",null,"Design principles behind ZIO Prelude:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Radical")," \u2014 So basically it ignores all dogma, and it is completely written with a new mindset."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Orthogonality")," \u2014 The goal for ZIO Prelude is to have no overlap. Type classes should do one thing and fit it well. So there is not any duplication to describe type classes."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Principled")," \u2014 All type classes in ZIO Prelude include a set of laws that instances must obey."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Pragmatic")," \u2014 If we have data types that don't satisfy laws but that are still useful to use in most cases, we can go ahead and provide instances for them."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Scala-First")," - It embraces subtyping and benefit from object-oriented features of Scala.")),(0,i.yg)("p",null,"ZIO Prelude gives us:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/zio-prelude/functional-data-types/"},"Functional Data Types")),"\u2014 Additional data types to supplement the ones in the Scala standard library such as ",(0,i.yg)("inlineCode",{parentName:"li"},"Validation")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"NonEmptyList")," to enable more accurate domain modeling and handle common problems like data validation. For example:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"NonEmptyList"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"NonEmptySet")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"ZSet"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"ZNonEmptySet")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Validation"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"ZValidation")))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/zio-prelude/functional-abstractions/"},"Functional Abstractions")),"\u2014 Functional abstractions to describe different ways of combining data, making it easy for us to combine complex data types in a principled way."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/zio-prelude/newtypes/"},"New Types")),"\u2014 that allow to ",(0,i.yg)("em",{parentName:"li"},"increase type safety")," in domain modeling. Wrapping existing type adding no runtime overhead. These refined newtypes allow us to increase the type safety of our code base with zero overhead and minimal boilerplate."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/zio-prelude/zpure/"},"ZPure")),"\u2014 A description of a computation that supports logging, context, state, and errors, providing all the functionality traditionally offered by monad transformers with dramatically better performance and ergonomics.")),(0,i.yg)("p",null,"The library has a small research-stage package (",(0,i.yg)("inlineCode",{parentName:"p"},"zio.prelude.fx"),") that provides abstraction over expressive effect types like ZIO and ",(0,i.yg)("inlineCode",{parentName:"p"},"ZPure"),"."),(0,i.yg)("p",null,"ZIO Prelude is a library focused on providing a core set of functional data types and abstractions that can help you solve a variety of day to day problems. The tools provided by ZIO Prelude fall into the following main categories:"),(0,i.yg)("h2",{id:"installation"},"Installation"),(0,i.yg)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.yg)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-prelude" % "1.0.0-RC21"\n')),(0,i.yg)("h2",{id:"example"},"Example"),(0,i.yg)("p",null,"In this example, we are going to create a simple voting application. We will use two features of ZIO Prelude:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"To become more type safety we are going to use ",(0,i.yg)("em",{parentName:"li"},"New Types")," and introducing ",(0,i.yg)("inlineCode",{parentName:"li"},"Topic")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"Votes")," data types."),(0,i.yg)("li",{parentName:"ol"},"Providing instance of ",(0,i.yg)("inlineCode",{parentName:"li"},"Associative")," type class for ",(0,i.yg)("inlineCode",{parentName:"li"},"Votes")," data type which helps us to combine ",(0,i.yg)("inlineCode",{parentName:"li"},"Votes")," values.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.prelude._\n\nobject VotingExample extends scala.App {\n\n  object Votes extends Subtype[Int] {\n    implicit val associativeVotes: Associative[Votes] =\n      new Associative[Votes] {\n        override def combine(l: => Votes, r: => Votes): Votes =\n          Votes(l + r)\n      }\n  }\n  type Votes = Votes.Type\n\n  object Topic extends Subtype[String]\n  type Topic = Topic.Type\n\n  final case class VoteState(map: Map[Topic, Votes]) { self =>\n    def combine(that: VoteState): VoteState =\n      VoteState(self.map combine that.map)\n  }\n\n  val zioHttp    = Topic("zio-http")\n  val uziHttp    = Topic("uzi-http")\n  val zioTlsHttp = Topic("zio-tls-http")\n\n  val leftVotes  = VoteState(Map(zioHttp -> Votes(4), uziHttp -> Votes(2)))\n  val rightVotes = VoteState(Map(zioHttp -> Votes(2), zioTlsHttp -> Votes(2)))\n\n  println(leftVotes combine rightVotes)\n  // Output: VoteState(Map(zio-http -> 6, uzi-http -> 2, zio-tls-http -> 2))\n}\n')))}g.isMDXComponent=!0}}]);