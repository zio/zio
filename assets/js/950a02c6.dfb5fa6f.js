"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[90142],{95788:(e,n,t)=>{t.d(n,{Iu:()=>p,yg:()=>g});var a=t(11504);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(t),m=s,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var o=t.length,i=new Array(o);i[0]=m;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[u]="string"==typeof e?e:s,i[1]=r;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},95244:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=t(45072),s=(t(11504),t(95788));const o={id:"test-effects",title:"How to Test effects?"},i=void 0,r={unversionedId:"guides/test-effects",id:"version-1.0.18/guides/test-effects",title:"How to Test effects?",description:"How zio-test was designed",source:"@site/versioned_docs/version-1.0.18/guides/test_effects.md",sourceDirName:"guides",slug:"/guides/test-effects",permalink:"/1.0.18/guides/test-effects",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/guides/test_effects.md",tags:[],version:"1.0.18",frontMatter:{id:"test-effects",title:"How to Test effects?"},sidebar:"overview_sidebar",previous:{title:"How to Use Test Assertions",permalink:"/1.0.18/guides/use-test-assertions"},next:{title:"How to Mock Services?",permalink:"/1.0.18/guides/mock-services"}},l={},c=[{value:"How zio-test was designed",id:"how-zio-test-was-designed",level:2},{value:"Constructing tests",id:"constructing-tests",level:2},{value:"Assertions - creating TestResults",id:"assertions---creating-testresults",level:3},{value:"Running tests",id:"running-tests",level:3},{value:"Using Test Environment",id:"using-test-environment",level:2},{value:"Testing Random",id:"testing-random",level:3},{value:"Testing Clock",id:"testing-clock",level:3},{value:"Clock Time",id:"clock-time",level:4},{value:"Examples",id:"examples",level:4},{value:"Testing Console",id:"testing-console",level:3},{value:"Testing System",id:"testing-system",level:3},{value:"Test Aspects",id:"test-aspects",level:2}],p={toc:c},u="wrapper";function d(e){let{components:n,...t}=e;return(0,s.yg)(u,(0,a.c)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("h2",{id:"how-zio-test-was-designed"},"How zio-test was designed"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"zio-test")," is designed around the idea of making tests first-class objects. What it means is that tests (and other accompanying concepts like assertions) become ordinary values that can be passed around, transformed and composed together. This approach allows for greater flexibility comparing to some other testing frameworks where tests and additional logic around tests had to be put into callbacks so that framework could make use of them. This approach also fits better with other ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO")," concepts like ",(0,s.yg)("inlineCode",{parentName:"p"},"ZManaged")," which can only be used within a scoped block of code. This also created a mismatch between ",(0,s.yg)("inlineCode",{parentName:"p"},"BeforeAll"),", ",(0,s.yg)("inlineCode",{parentName:"p"},"AfterAll"),' callback-like methods when there were resources that should be opened and closed during test suite execution.\nAnother thing worth pointing out is that tests being values, are also effects. Implications of this design are far reaching. First of all well known problem of testing asynchronous value is gone. Whereas in other frameworks you have to somehow "run" your effects\nand at best wrap them in ',(0,s.yg)("inlineCode",{parentName:"p"},"scala.util.Future")," because blocking would eliminate running on ScalaJS, ",(0,s.yg)("inlineCode",{parentName:"p"},"zio-test")," expects you to create ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO")," objects. There is no need for indirect transformations from one wrapping object to another. Second, because our tests are ordinary ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO")," values we don't need to turn to testing framework for things like retries, timeouts and resource management. We can solve all those problems with full richness of functions that ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO")," exposes."),(0,s.yg)("h2",{id:"constructing-tests"},"Constructing tests"),(0,s.yg)("p",null,"All below code assumes that you have imported ",(0,s.yg)("inlineCode",{parentName:"p"},"zio.test._")),(0,s.yg)("p",null,"The backbone of ",(0,s.yg)("inlineCode",{parentName:"p"},"zio-test")," is the ",(0,s.yg)("inlineCode",{parentName:"p"},"Spec[L, T]")," class. Every spec is labeled with ",(0,s.yg)("inlineCode",{parentName:"p"},"L")," and can be a suite which contains other specs or a test of type ",(0,s.yg)("inlineCode",{parentName:"p"},"T"),"."),(0,s.yg)("p",null,"The most common and easy way to create suites is to use ",(0,s.yg)("inlineCode",{parentName:"p"},"suite")," function. For testing of pure functions there is ",(0,s.yg)("inlineCode",{parentName:"p"},"test")," function and for effectful testing there is ",(0,s.yg)("inlineCode",{parentName:"p"},"testM")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.environment.Live\nimport zio.clock.nanoTime\nimport Assertion.isGreaterThan\n\nval clockSuite = suite("clock") (\n  testM("time is non-zero") {\n    assertM(Live.live(nanoTime))(isGreaterThan(0L))\n  }\n)\n// clockSuite: Spec[Live, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "clock",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "time is non-zero",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,21)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,"As you can see the whole suite was assigned to ",(0,s.yg)("inlineCode",{parentName:"p"},"clockSuite")," val. As it was said suites can contain other suites so we can aggregate them as much as needed. Example, we can have multiple suites that test external HTTP apis and one big suite that will aggregate them all."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport Assertion._\n\nval paymentProviderABCSuite  = suite("ABC payment provider tests") {test("Your test")(assert("Your value")(Assertion.isNonEmptyString))}\n// paymentProviderABCSuite: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "ABC payment provider tests",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "Your test",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,36)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval paymentProviderXYZSuite  = suite("XYZ payment provider tests") {test("Your other test")(assert("Your other value")(Assertion.isNonEmptyString))}\n// paymentProviderXYZSuite: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "XYZ payment provider tests",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "Your other test",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,39)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval allPaymentProvidersTests = suite("All payment providers tests")(paymentProviderABCSuite, paymentProviderXYZSuite)\n// allPaymentProvidersTests: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "All payment providers tests",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "ABC payment provider tests",\n//               spec = Spec(\n//                 caseValue = MultipleCase(\n//                   specs = IndexedSeq(\n//                     Spec(\n//                       caseValue = LabeledCase(\n//                         label = "Your test",\n//                         spec = Spec(\n//                           caseValue = TestCase(\n//                             test = <function1>,\n//                             annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,36)))\n//                           )\n//                         )\n//                       )\n//                     )\n//                   )\n//                 )\n//               )\n//             )\n//           ),\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "XYZ payment provider tests",\n//               spec = Spec(\n//                 caseValue = MultipleCase(\n//                   specs = IndexedSeq(\n//                     Spec(\n//                       caseValue = LabeledCase(\n//                         label = "Your other test",\n//                         spec = Spec(\n//                           caseValue = TestCase(\n//                             test = <function1>,\n//                             annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,39)))\n//                           )\n//                         )\n//                       )\n//                     )\n//                   )\n//                 )\n// ...\n')),(0,s.yg)("p",null,"Real tests that run some logic and return testing result are created mostly with ",(0,s.yg)("inlineCode",{parentName:"p"},"testM")," function. It expects two arguments, first one that will be the label of test\nwhich will be used for visual reporting back to the user and an assertion of type\n",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, TestResult]"),". This means writing test in ",(0,s.yg)("inlineCode",{parentName:"p"},"zio-test")," mostly gets down to creating a ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO")," object that\nwill produce ",(0,s.yg)("inlineCode",{parentName:"p"},"TestResult"),". There is another variant of function for creating test that are pure called simply ",(0,s.yg)("inlineCode",{parentName:"p"},"test"),".\nIt expects a thunk of code that will just return a ",(0,s.yg)("inlineCode",{parentName:"p"},"TestResult")," without packing it into ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO"),"."),(0,s.yg)("h3",{id:"assertions---creating-testresults"},"Assertions - creating TestResults"),(0,s.yg)("p",null,"As it was already mentioned tests should return ",(0,s.yg)("inlineCode",{parentName:"p"},"TestResult"),". The most common way to produce a ",(0,s.yg)("inlineCode",{parentName:"p"},"TestResult"),"\nis to resort to ",(0,s.yg)("inlineCode",{parentName:"p"},"assert")," or its effectful counterpart ",(0,s.yg)("inlineCode",{parentName:"p"},"assertM"),". Both of them accept a value of type ",(0,s.yg)("inlineCode",{parentName:"p"},"A")," (effectful version wrapped in a ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO"),") and an ",(0,s.yg)("inlineCode",{parentName:"p"},"Assertion[A]"),".\nTo create ",(0,s.yg)("inlineCode",{parentName:"p"},"Assertion[A]")," object one can use functions defined under ",(0,s.yg)("inlineCode",{parentName:"p"},"zio.test.Assertion"),". There are already a number\nof useful assertions predefined like ",(0,s.yg)("inlineCode",{parentName:"p"},"equalTo"),", ",(0,s.yg)("inlineCode",{parentName:"p"},"isFalse"),", ",(0,s.yg)("inlineCode",{parentName:"p"},"isTrue"),", ",(0,s.yg)("inlineCode",{parentName:"p"},"contains"),", ",(0,s.yg)("inlineCode",{parentName:"p"},"throws")," and more.\nWhat is really useful in assertions is that they behave like boolean values and can be composed with operators\nknown from operating on boolean values like and (",(0,s.yg)("inlineCode",{parentName:"p"},"&&"),"), or (",(0,s.yg)("inlineCode",{parentName:"p"},"||"),"), negation (",(0,s.yg)("inlineCode",{parentName:"p"},"negate"),")."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion\n\nval assertionForString: Assertion[String] = Assertion.containsString("Foo") && Assertion.endsWithString("Bar")\n// assertionForString: Assertion[String] = (containsString(Foo) && endsWithString(Bar))\n')),(0,s.yg)("p",null,"What's more, assertions also compose with each other allowing for doing rich diffs not only simple value to value comparison."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion.{isRight, isSome,equalTo, hasField}\n\ntest("Check assertions") {\n  assert(Right(Some(2)))(isRight(isSome(equalTo(2))))\n}\n// res0: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Check assertions",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,60)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,"Here we're checking deeply nested values inside an ",(0,s.yg)("inlineCode",{parentName:"p"},"Either")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"Option"),". Because ",(0,s.yg)("inlineCode",{parentName:"p"},"Assertion"),"s compose this is not a problem\nall layers are being peeled off tested for condition until final value is reached.\nHere the expression ",(0,s.yg)("inlineCode",{parentName:"p"},"Right(Some(2))")," is of type ",(0,s.yg)("inlineCode",{parentName:"p"},"Either[Any, Option[Int]]"),"and our assertion ",(0,s.yg)("inlineCode",{parentName:"p"},"isRight(isSome(equalTo(2)))"),"\nis of type ",(0,s.yg)("inlineCode",{parentName:"p"},"Assertion[Either[Any, Option[Int]]]")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.Assertion.{isRight, isSome,equalTo, isGreaterThanEqualTo, not, hasField}\n\nfinal case class Address(country:String, city:String)\nfinal case class User(name:String, age:Int, address: Address)\n\ntest("Rich checking") {\n  assert(\n    User("Jonny", 26, Address("Denmark", "Copenhagen"))\n  )(\n    hasField("age", (u:User) => u.age, isGreaterThanEqualTo(18)) &&\n    hasField("country", (u:User) => u.address.country, not(equalTo("USA")))\n  )\n}\n// res2: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Rich checking",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,83)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,"There is also an easy way to test object's data for certain assertions with ",(0,s.yg)("inlineCode",{parentName:"p"},"hasField")," which accepts besides a name, a mapping function from object to its tested property and ",(0,s.yg)("inlineCode",{parentName:"p"},"Assertion")," object which will validate this property. Here our test checks if a person has at least 18 years and is not from USA. What is nice about those tests is that, test reporters will tell you exactly which assertion was broken. Let's say we would change ",(0,s.yg)("inlineCode",{parentName:"p"},"isGreaterThanEqualTo(18)")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"isGreaterThanEqualTo(40)")," which will fail. Printout\non console will be a nice detailed text explaining what exactly went wrong:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-bash"},'[info]       User(Jonny,26,Address(Denmark,Copenhagen)) did not satisfy (hasField("age", _.age, isGreaterThanEqualTo(45)) && hasField("country", _.country, not(equalTo(USA))))\n[info]       26 did not satisfy isGreaterThanEqualTo(45)\n')),(0,s.yg)("p",null,"Having this all in mind probably the most common and also most readable way of structuring tests is to pass\na for-comprehension to ",(0,s.yg)("inlineCode",{parentName:"p"},"testM")," function and yield a call to ",(0,s.yg)("inlineCode",{parentName:"p"},"assert")," function."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test._\nimport Assertion._\n\ntestM("Semaphore should expose available number of permits") {\n  for {\n    s         <- Semaphore.make(1L)\n    permits   <- s.available\n  } yield assert(permits)(equalTo(1L))\n}\n// res3: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Semaphore should expose available number of permits",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,105)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("h3",{id:"running-tests"},"Running tests"),(0,s.yg)("p",null,"When all of our tests are constructed, we need to have a way to actually execute them. Your first stop is the ",(0,s.yg)("inlineCode",{parentName:"p"},"zio.test.DefaultRunnableSpec")," which accepts a single suite that will be executed. A single suite might seem to be limiting but as it was already said suites can hold any number of other suites. You may structure your tests like this:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.clock.nanoTime\nimport Assertion._\n\nval suite1 = suite("suite1") (\n  testM("s1.t1") {assertM(nanoTime)(isGreaterThanEqualTo(0L))},\n  testM("s1.t2") {assertM(nanoTime)(isGreaterThanEqualTo(0L))}\n)\n// suite1: Spec[clock.package.Clock, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "suite1",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s1.t1",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,126)))\n//                 )\n//               )\n//             )\n//           ),\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s1.t2",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,127)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval suite2 = suite("suite2") (\n  testM("s2.t1") {assertM(nanoTime)(isGreaterThanEqualTo(0L))},\n  testM("s2.t2") {assertM(nanoTime)(isGreaterThanEqualTo(0L))},\n  testM("s2.t3") {assertM(nanoTime)(isGreaterThanEqualTo(0L))}\n)\n// suite2: Spec[clock.package.Clock, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "suite2",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s2.t1",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,132)))\n//                 )\n//               )\n//             )\n//           ),\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s2.t2",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,133)))\n//                 )\n//               )\n//             )\n//           ),\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s2.t3",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,134)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval suite3 = suite("suite3") (\n  testM("s3.t1") {assertM(nanoTime)(isGreaterThanEqualTo(0L))}\n)\n// suite3: Spec[clock.package.Clock, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "suite3",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s3.t1",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,139)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n\nobject AllSuites extends DefaultRunnableSpec {\n  def spec = suite("All tests")(suite1, suite2, suite3)\n}\n')),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," is very similar in its logic of operations to ",(0,s.yg)("inlineCode",{parentName:"p"},"zio.App"),". Instead of providing one ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO")," application\nat the end of the world we provide a suite that can be a tree of other suites and tests. Another resemblance is that ",(0,s.yg)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," provides an Environment. Here it is an instance of ",(0,s.yg)("inlineCode",{parentName:"p"},"TestEnvironment")," which helps us with controlling our systems infrastructure. More info on using test environment can be found in sections below.\nJust like with ",(0,s.yg)("inlineCode",{parentName:"p"},"zio.App")," where at the very end an instance of ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO[R,E,A]")," is expected where ",(0,s.yg)("inlineCode",{parentName:"p"},"R")," can be at maximum of type ",(0,s.yg)("inlineCode",{parentName:"p"},"Environment")," in ",(0,s.yg)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," ",(0,s.yg)("inlineCode",{parentName:"p"},"R")," cannot be more than ",(0,s.yg)("inlineCode",{parentName:"p"},"TestEnvironment"),". So just like in normal application if our\n",(0,s.yg)("inlineCode",{parentName:"p"},"R")," is composed of some other modules we need to provide them first before test can be executed. How can we provide our dependencies?\nHere again the design of ",(0,s.yg)("inlineCode",{parentName:"p"},"zio-test")," shines. Since our tests are ordinary values we can just transform them with a call to ",(0,s.yg)("inlineCode",{parentName:"p"},"mapTest"),".\nIt accepts a lambda of type ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO[R with TestSystem, TestFailure[Throwable], TestSuccess[Unit] ] => T1"),". Without getting into too much details about types we can see that our lambda argument is a test instance (",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO"),") that expects an environment of type ",(0,s.yg)("inlineCode",{parentName:"p"},"R with TestSystem"),". This is no different from normal usage of ZIO in ",(0,s.yg)("inlineCode",{parentName:"p"},"zio.App"),". We can use the same ",(0,s.yg)("inlineCode",{parentName:"p"},"provide"),", ",(0,s.yg)("inlineCode",{parentName:"p"},"provideSome")," methods to provide modules which ",(0,s.yg)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," cannot provide itself as those are users modules. When all dependencies are provided we can run our tests in two ways. If we added ",(0,s.yg)("inlineCode",{parentName:"p"},"zio-test-sbt")," to our dependencies and ",(0,s.yg)("inlineCode",{parentName:"p"},"zio.test.sbt.TestFramework")," to SBT's ",(0,s.yg)("inlineCode",{parentName:"p"},"testFrameworks")," our tests should be automatically picked up by SBT on invocation of ",(0,s.yg)("inlineCode",{parentName:"p"},"test"),". However if we're not using SBT or have some other special needs ",(0,s.yg)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," has a ",(0,s.yg)("inlineCode",{parentName:"p"},"main")," method which can be invoked directly or with SBTs ",(0,s.yg)("inlineCode",{parentName:"p"},"test:run"),"."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sbt"},'libraryDependencies ++= Seq(\n  "dev.zio" %% "zio-test"     % zioVersion % "test",\n  "dev.zio" %% "zio-test-sbt" % zioVersion % "test"\n),\ntestFrameworks += new TestFramework("zio.test.sbt.ZTestFramework")\n')),(0,s.yg)("h2",{id:"using-test-environment"},"Using Test Environment"),(0,s.yg)("p",null,"What we expect from tests (at least those that we consider unit tests) is to be stable i.e. consecutive runs should yield the same results and take\nmore or less the same amount of time. Biggest source of complexity during testing comes from external services which we cannot control like external\npayment APIs, object storages, http APIs etc. It is normal to hide these kind of services behind an interface and provide test instances to regain\ncontrol and determinism. However there is another source of complexity that comes from the local infrastructure that is also hard to control without building prior abstractions. Things like stdin/stdout, clocks, random generators, schedulers can make writing tests hard or even impossible. Fortunately ZIO abstracted most of it in its runtime under ",(0,s.yg)("inlineCode",{parentName:"p"},"Environment")," type. Thanks to this design ",(0,s.yg)("inlineCode",{parentName:"p"},"zio-test")," could easily provide its own implementation named ",(0,s.yg)("inlineCode",{parentName:"p"},"TestEnvironment")," which gives you test implementations of mentioned infrastructure. In most of the cases when you'll be using ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO"),"s ",(0,s.yg)("inlineCode",{parentName:"p"},"testM")," test implementations are already created and should be controlled by exposed functions on companion object. If for some reason you would like to provide custom environment or are using other testing framework but still want to use test environment there are ",(0,s.yg)("inlineCode",{parentName:"p"},"make")," functions on companion objects of test modules where you can construct your own."),(0,s.yg)("p",null,"It is easy to accidentally use different test instances at the same time."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.environment.TestClock\nimport Assertion._\nimport zio.duration._\n\ntestM("`acquire` doesn\'t leak permits upon cancellation") {\n  for {\n      testClock <- TestClock.makeTest(TestClock.DefaultData)\n      s         <- Semaphore.make(1L)\n      sf        <- s.acquireN(2).timeout(1.millisecond).either.fork\n      _         <- testClock.adjust(1.second)\n      _         <- sf.join\n      _         <- s.release\n      permits   <- s.available\n  } yield assert(permits, equalTo(2L))\n}\n')),(0,s.yg)("p",null,"Above code doesn't work. We created a new ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock")," instance and are correctly adjusting its time. What might be surprising is that call to ",(0,s.yg)("inlineCode",{parentName:"p"},"timeout")," will use the ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock")," provided by the ",(0,s.yg)("inlineCode",{parentName:"p"},"TestEnvironment")," not our ",(0,s.yg)("inlineCode",{parentName:"p"},"testClock")," instance. It easy to know why when you look at the signature of ",(0,s.yg)("inlineCode",{parentName:"p"},"timeout"),":"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.duration.Duration\nimport zio.clock.Clock\n\nsealed trait ZIO[-R, +E, +A] extends Serializable { self =>\n    /* All other method declarations in this trait ignored to avoid clutter */\n\n    def timeout(d: Duration): ZIO[R with Clock, E, Option[A]]\n}\n")),(0,s.yg)("p",null,"The returned type is ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO[R with Clock, E, Option[A]]"),' where our environment is "some R plus a Clock".\nBefore running this ',(0,s.yg)("inlineCode",{parentName:"p"},"Clock")," has to be provided and the framework provides the Clock from the ",(0,s.yg)("inlineCode",{parentName:"p"},"TestEnvironment")," not our instance variable as it is not aware that we created it."),(0,s.yg)("p",null,"If you need to provide real implementations instead of the test instances to some part of your tests there is a ",(0,s.yg)("inlineCode",{parentName:"p"},"live")," method which will transform your ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, A]")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO[Live[R], E, A]"),". Going from ",(0,s.yg)("inlineCode",{parentName:"p"},"R")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"Live[R]")," instructs the framework that we really want to be provided with live implementations."),(0,s.yg)("h3",{id:"testing-random"},"Testing Random"),(0,s.yg)("p",null,"When working with randomness testing might be hard because the inputs to the tested function change on every invocation so our code behave in a indeterministic way. Precisely because of this reason ",(0,s.yg)("inlineCode",{parentName:"p"},"ZIO")," exposes ",(0,s.yg)("inlineCode",{parentName:"p"},"TestRandom")," module which allows for fully deterministic testing of code\nthat deals with Randomness.\n",(0,s.yg)("inlineCode",{parentName:"p"},"TestRandom")," can operate in two modes based on needed use case. In first mode it is a purely functional pseudo-random number generator. During generation on random values like when calling ",(0,s.yg)("inlineCode",{parentName:"p"},"nextInt")," no internal state is being mutated. It is expected to chain such operations with combinators like ",(0,s.yg)("inlineCode",{parentName:"p"},"flatMap"),". To preserve the same values generated between invocation of tests ",(0,s.yg)("inlineCode",{parentName:"p"},"setSeed")," method can be used. It is guaranteed to return the same sequence of values for any given seed."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test.assert\nimport zio.test.environment.TestRandom\nimport zio.test.Assertion.equalTo\n\ntestM("Use setSeed to generate stable values") {\n  for {\n    _  <- TestRandom.setSeed(27)\n    r1 <- random.nextLong\n    r2 <- random.nextLong\n    r3 <- random.nextLong\n  } yield\n    assert(List(r1,r2,r3))(equalTo(List[Long](\n      -4947896108136290151L,\n      -5264020926839611059L,\n      -9135922664019402287L\n    )))\n}\n// res4: ZSpec[TestRandom with random.package.Random, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Use setSeed to generate stable values",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,176)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,"In second mode ",(0,s.yg)("inlineCode",{parentName:"p"},"TestRandom"),' maintains an internal buffer of values that can be "fed" upfront with methods such as ',(0,s.yg)("inlineCode",{parentName:"p"},"feedInts"),". When random values are being generated first values from that buffer are being used."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test.environment.TestRandom\ntestM("One can provide its own list of ints") {\n  for {\n    _  <- TestRandom.feedInts(1, 9, 2, 8, 3, 7, 4, 6, 5)\n    r1 <- random.nextInt\n    r2 <- random.nextInt\n    r3 <- random.nextInt\n    r4 <- random.nextInt\n    r5 <- random.nextInt\n    r6 <- random.nextInt\n    r7 <- random.nextInt\n    r8 <- random.nextInt\n    r9 <- random.nextInt\n  } yield assert(\n    List(1, 9, 2, 8, 3, 7, 4, 6, 5)\n  )(equalTo(List(r1, r2, r3, r4, r5, r6, r7, r8, r9)))\n}\n// res5: ZSpec[TestRandom with random.package.Random, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "One can provide its own list of ints",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,197)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,"When we run out of values in buffer ",(0,s.yg)("inlineCode",{parentName:"p"},"TestRandom")," it falls back to first mode. If we want to we can also clear internal buffers by calling method\nlike ",(0,s.yg)("inlineCode",{parentName:"p"},"clearInts"),"."),(0,s.yg)("h3",{id:"testing-clock"},"Testing Clock"),(0,s.yg)("p",null,"In most cases you want unit tests to be as fast as possible. Waiting for real time to pass by is a real killer for  this. ZIO exposes a ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock")," in ",(0,s.yg)("inlineCode",{parentName:"p"},"TestEnvironment")," that can control time so we can deterministically and efficiently  test effects involving the passage of time without actually having to wait for the full amount of time to pass. Calls to ",(0,s.yg)("inlineCode",{parentName:"p"},"sleep")," and methods derived from it will semantically block until the clock time is set/adjusted to on or after the time the effect is scheduled to run. "),(0,s.yg)("h4",{id:"clock-time"},"Clock Time"),(0,s.yg)("p",null,"Clock time is just like a clock on the wall, except that in our ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock"),", the clock is broken Instead of moving by itself, the clock time only changes when adjusted or set by the user, using the ",(0,s.yg)("inlineCode",{parentName:"p"},"adjust")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"setTime")," methods. The clock time never changes by itself. When the clock is adjusted, any effects scheduled to run on or before the new clock time will automatically be run, in order."),(0,s.yg)("h4",{id:"examples"},"Examples"),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"Example 1")),(0,s.yg)("p",null,"Thanks to the call to ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock.adjust(1.minute)")," we moved the time instantly 1 minute."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import java.util.concurrent.TimeUnit\nimport zio.clock.currentTime\nimport zio.duration._\nimport zio.test.Assertion.isGreaterThanEqualTo\nimport zio.test._\nimport zio.test.environment.TestClock\n\ntestM("One can move time very fast") {\n  for {\n    startTime <- currentTime(TimeUnit.SECONDS)\n    _         <- TestClock.adjust(1.minute)\n    endTime   <- currentTime(TimeUnit.SECONDS)\n  } yield assert(endTime - startTime)(isGreaterThanEqualTo(60L))\n}\n// res6: ZSpec[TestClock with Clock, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "One can move time very fast",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,236)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"Example 2")),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"TestClock")," affects also all code running asynchronously that is scheduled to run after a certain time."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.duration._\nimport zio.test.Assertion.equalTo\nimport zio.test._\nimport zio.test.environment.TestClock\n\ntestM("One can control time as he see fit") {\n  for {\n    promise <- Promise.make[Unit, Int]\n    _       <- (ZIO.sleep(10.seconds) *> promise.succeed(1)).fork\n    _       <- TestClock.adjust(10.seconds)\n    readRef <- promise.await\n  } yield assert(1)(equalTo(readRef))\n}\n// res7: ZSpec[Clock with TestClock, Unit] = Spec(\n//   caseValue = LabeledCase(\n//     label = "One can control time as he see fit",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,260)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,'The above code creates a write once cell that will be set to "1" after 10 seconds asynchronously from a different thread thanks to call to ',(0,s.yg)("inlineCode",{parentName:"p"},"fork"),". At the end we wait on the promise until it is set. With call to ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock.adjust(10.seconds)")," we simulate passing of 10 seconds of time. Because of it we don't need to wait for the real 10 seconds to pass and thus our unit test can run faster This is a pattern that will very often be used when ",(0,s.yg)("inlineCode",{parentName:"p"},"sleep")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock")," are being used for testing of effects that are based on time. The fiber that needs to sleep will be forked and ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock")," will used to adjust the time so that all expected effects are run in the forked fiber."),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"Example 3")),(0,s.yg)("p",null,"A more complex example leveraging layers and multiple services is shown below. "),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.clock.Clock\nimport zio.duration._\nimport zio.test.Assertion._\nimport zio.test._\nimport zio.test.environment.{ TestClock, TestEnvironment }\nimport zio._\n\ntrait SchedulingService {\n  def schedule(promise: Promise[Unit, Int]): ZIO[Any, Exception, Boolean]\n}\n\ntrait LoggingService {\n  def log(msg: String): ZIO[Any, Exception, Unit]\n}\n\nval schedulingLayer: ZLayer[Clock with Has[LoggingService], Nothing, Has[SchedulingService]] =\n  ZLayer.fromFunction { env =>\n    new SchedulingService {\n      def schedule(promise: Promise[Unit, Int]): ZIO[Any, Exception, Boolean] =\n        (ZIO.sleep(10.seconds) *> promise.succeed(1))\n          .tap(b => ZIO.service[LoggingService].flatMap(_.log(b.toString)))\n          .provide(env)\n    }\n}\n// schedulingLayer: ZLayer[Clock with Has[LoggingService], Nothing, Has[SchedulingService]] = Managed(\n//   self = zio.ZManaged$$anon$2@58d7efdd\n// )\n\ntestM("One can control time for failing effects too") {\n  val failingLogger = ZLayer.succeed(new LoggingService {\n    override def log(msg: String): ZIO[Any, Exception, Unit] = ZIO.fail(new Exception("BOOM"))\n  })\n\n  val partialLayer = (ZLayer.identity[Clock] ++ failingLogger) >>> schedulingLayer\n\n  val testCase =\n    for {\n      promise <- Promise.make[Unit, Int]\n      result  <- ZIO.service[SchedulingService].flatMap(_.schedule(promise)).run.fork\n      _       <- TestClock.adjust(10.seconds)\n      readRef <- promise.await\n      result  <- result.join\n    } yield assert(1)(equalTo(readRef)) && assert(result)(fails(isSubtype[Exception](anything)))\n  testCase.provideSomeLayer[TestEnvironment](partialLayer)\n}\n// res9: ZSpec[TestEnvironment, Unit] = Spec(\n//   caseValue = LabeledCase(\n//     label = "One can control time for failing effects too",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,315)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,"In this case we want to test a layered effect that can potentially fail with an error. To do this we need to run the effect\nand use assertions that expect an ",(0,s.yg)("inlineCode",{parentName:"p"},"Exit")," value.\nBecause we are providing a layer to the test we need to provide everything expected by our test case and leave the test\nenvironment behind using ",(0,s.yg)("inlineCode",{parentName:"p"},".provideSomeLayer[TestEnvironment]"),". Keep in mind we do not provide any implementation of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Clock"),"\nbecause doing will make force ",(0,s.yg)("inlineCode",{parentName:"p"},"SchedulingService")," to use it, while the clock we need here is the ",(0,s.yg)("inlineCode",{parentName:"p"},"TestClock")," provided by\nthe test environment."),(0,s.yg)("p",null,"The pattern with ",(0,s.yg)("inlineCode",{parentName:"p"},"Promise")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"await")," can be generalized when we need to wait for multiple values using a ",(0,s.yg)("inlineCode",{parentName:"p"},"Queue"),". We simply need to put multiple values into the queue and progress the clock multiple times and there is no need to create multiple promises. Even if you have a non-trivial flow of data from multiple streams that can produce at different intervals and would like to test snapshots of data in particular point in time ",(0,s.yg)("inlineCode",{parentName:"p"},"Queue")," can help with that."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.duration._\nimport zio.test.Assertion.equalTo\nimport zio.test._\nimport zio.test.environment.TestClock\nimport zio.stream._\n\ntestM("zipWithLatest") {\n  val s1 = Stream.iterate(0)(_ + 1).fixed(100.milliseconds)\n  val s2 = Stream.iterate(0)(_ + 1).fixed(70.milliseconds)\n  val s3 = s1.zipWithLatest(s2)((_, _))\n\n  for {\n    q      <- Queue.unbounded[(Int, Int)]\n    _      <- s3.foreach(q.offer).fork\n    fiber  <- ZIO.collectAll(ZIO.replicate(4)(q.take)).fork\n    _      <- TestClock.adjust(1.second)\n    result <- fiber.join\n  } yield assert(result)(equalTo(List(0 -> 0, 0 -> 1, 1 -> 1, 1 -> 2)))\n}\n// res10: ZSpec[Any with Clock with TestClock, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "zipWithLatest",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,352)))\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("h3",{id:"testing-console"},"Testing Console"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"TestConsole")," allows testing of applications that interact with console by modeling working with standard input and output\nas writing and reading to and from internal buffers."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test.environment.TestConsole\nimport zio.console\n\nval consoleSuite = suite("ConsoleTest")(\n  testM("One can test output of console") {\n    for {\n      _              <- TestConsole.feedLines("Jimmy", "37")\n      _              <- console.putStrLn("What is your name?")\n      name           <- console.getStrLn\n      _              <- console.putStrLn("What is your age?")\n      age            <- console.getStrLn.map(_.toInt)\n      questionVector <- TestConsole.output\n      q1             = questionVector(0)\n      q2             = questionVector(1)\n    } yield {\n      assert(name)(equalTo("Jimmy")) &&\n      assert(age)(equalTo(37)) &&\n      assert(q1)(equalTo("What is your name?\\n")) &&\n      assert(q2)(equalTo("What is your age?\\n"))\n    }\n  }\n)\n// consoleSuite: Spec[console.package.Console with TestConsole, TestFailure[java.io.IOException], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "ConsoleTest",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "One can test output of console",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,377)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n')),(0,s.yg)("p",null,"Above code simulates an application that will ask for name and age of the user. To test it we prefill buffers with answers\nwith call to ",(0,s.yg)("inlineCode",{parentName:"p"},"TestConsole.feedLines")," method. Calls to ",(0,s.yg)("inlineCode",{parentName:"p"},"console.getStrLn")," will get the value from the buffers instead of\ninteracting with the users keyboard. Also all output that our program produces by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"console.putStrLn")," (and other\nprinting methods) is being gathered and can be accessed with call to ",(0,s.yg)("inlineCode",{parentName:"p"},"TestConsole.output"),"."),(0,s.yg)("h3",{id:"testing-system"},"Testing System"),(0,s.yg)("p",null,"With increased usage of containers and runtimes like Kubernetes more and more applications are being configured by means\nof environment variables. It is important to test this logic just like other parts of application. For this purpose ",(0,s.yg)("inlineCode",{parentName:"p"},"zio-test"),"\nexposes ",(0,s.yg)("inlineCode",{parentName:"p"},"TestSystem")," module. Additionally to setting the environment variables it also allows for setting JVM system properties\nlike in the code below:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.system\nimport zio.test.environment._\n\nfor {\n  _      <- TestSystem.putProperty("java.vm.name", "VM")\n  result <- system.property("java.vm.name")\n} yield assert(result)(equalTo(Some("VM")))\n// res11: ZIO[TestSystem with system.package.System, Throwable, TestResult] = zio.ZIO$FlatMap@500bc260\n')),(0,s.yg)("p",null,"It is worth noticing that no actual environment variables or properties will be set during testing so there will be\nno impact on other parts of the system."),(0,s.yg)("h2",{id:"test-aspects"},"Test Aspects"),(0,s.yg)("p",null,"Test aspects are used to modify existing tests or even entire suites that you have already created. Test aspects are\napplied to a test or suite using the ",(0,s.yg)("inlineCode",{parentName:"p"},"@@")," operator. This is an example test suite showing the use of aspects to modify\ntest behavior:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.duration._\nimport zio.test.Assertion._\nimport zio.test.TestAspect._\nimport zio.test._\n\nobject MySpec extends DefaultRunnableSpec {\n  def spec = suite("A Suite")(\n    test("A passing test") {\n      assert(true)(isTrue)\n    },\n    test("A passing test run for JVM only") {\n      assert(true)(isTrue)\n    } @@ jvmOnly, //@@ jvmOnly only runs tests on the JVM\n    test("A passing test run for JS only") {\n      assert(true)(isTrue)\n    } @@ jsOnly, //@@ jsOnly only runs tests on Scala.js\n    test("A passing test with a timeout") {\n      assert(true)(isTrue)\n    } @@ timeout(10.nanos), //@@ timeout will fail a test that doesn\'t pass within the specified time\n    test("A failing test... that passes") {\n      assert(true)(isFalse)\n    } @@ failing, //@@ failing turns a failing test into a passing test\n    test("A ignored test") {\n      assert(false)(isTrue)\n    } @@ ignore, //@@ ignore marks test as ignored\n    test("A flaky test that only works on the JVM and sometimes fails; let\'s compose some aspects!") {\n      assert(false)(isTrue)\n    } @@ jvmOnly           // only run on the JVM\n      @@ eventually        //@@ eventually retries a test indefinitely until it succeeds\n      @@ timeout(20.nanos) //it\'s a good idea to compose `eventually` with `timeout`, or the test may never end\n  ) @@ timeout(60.seconds)   //apply a timeout to the whole suite\n}\n')))}d.isMDXComponent=!0}}]);