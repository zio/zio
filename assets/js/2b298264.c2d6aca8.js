"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[9305],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(n),m=s,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,i[1]=r;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4194:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(7462),s=n(3366),o=(n(7294),n(3905)),i=["components"],r={id:"test-effects",title:"How to Test effects?"},l=void 0,c={unversionedId:"howto/test-effects",id:"howto/test-effects",isDocsHomePage:!1,title:"How to Test effects?",description:"How zio-test was designed",source:"@site/docs/howto/test_effects.md",sourceDirName:"howto",slug:"/howto/test-effects",permalink:"/howto/test-effects",tags:[],version:"current",frontMatter:{id:"test-effects",title:"How to Test effects?"},sidebar:"howto-sidebar",previous:{title:"How to Use Test Assertions",permalink:"/howto/use-test-assertions"},next:{title:"How to Mock Services?",permalink:"/howto/mock-services"}},p=[{value:"How zio-test was designed",id:"how-zio-test-was-designed",children:[]},{value:"Constructing tests",id:"constructing-tests",children:[{value:"Assertions - creating TestResults",id:"assertions---creating-testresults",children:[]},{value:"Running tests",id:"running-tests",children:[]}]},{value:"Using Test Environment",id:"using-test-environment",children:[{value:"Testing Random",id:"testing-random",children:[]},{value:"Testing Clock",id:"testing-clock",children:[]},{value:"Testing Console",id:"testing-console",children:[]},{value:"Testing System",id:"testing-system",children:[]}]},{value:"Test Aspects",id:"test-aspects",children:[]}],u={toc:p};function d(e){var t=e.components,n=(0,s.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"how-zio-test-was-designed"},"How zio-test was designed"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"zio-test")," is designed around the idea of ",(0,o.kt)("em",{parentName:"p"},"making tests first-class objects"),". What it means is that tests (and other accompanying concepts like assertions) become ordinary values that can be passed around, transformed, and composed together."),(0,o.kt)("p",null,"This approach allows for greater flexibility compared to some other testing frameworks where tests and additional logic around tests had to be put into callbacks so that framework could make use of them."),(0,o.kt)("p",null,"This approach also fits better with other ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," concepts like ",(0,o.kt)("inlineCode",{parentName:"p"},"ZManaged")," which can only be used within a scoped block of code. This also created a mismatch between ",(0,o.kt)("inlineCode",{parentName:"p"},"BeforeAll"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"AfterAll")," callback-like methods when there were resources that should be opened and closed during test suite execution."),(0,o.kt)("p",null,"Another thing worth pointing out is that tests being values are also effects. Implications of this design are far-reaching."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},'First, the well-known problem of testing asynchronous value is gone. Whereas in other frameworks you have to somehow "run" your effects and at best wrap them in ',(0,o.kt)("inlineCode",{parentName:"p"},"scala.util.Future")," because blocking would eliminate running on ScalaJS, ",(0,o.kt)("inlineCode",{parentName:"p"},"zio-test")," expects you to create ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," objects. There is no need for indirect transformations from one wrapping object to another.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Second, because our tests are ordinary ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," values we don't need to turn to a testing framework for things like retries, timeouts, and resource management. We can solve all those problems with the full richness of functions that ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," exposes."))),(0,o.kt)("h2",{id:"constructing-tests"},"Constructing tests"),(0,o.kt)("p",null,"All below code assumes that you have imported ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.test._")),(0,o.kt)("p",null,"The backbone of ",(0,o.kt)("inlineCode",{parentName:"p"},"zio-test")," is the ",(0,o.kt)("inlineCode",{parentName:"p"},"Spec[L, T]")," class. Every spec is labeled with ",(0,o.kt)("inlineCode",{parentName:"p"},"L"),", and can be a suite that contains other specs, or a test of type ",(0,o.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,o.kt)("p",null,"The most common and easy way to create suites is to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"suite")," function. For testing of pure functions and for effectful testing there is ",(0,o.kt)("inlineCode",{parentName:"p"},"test"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.environment.Live\nimport zio.Clock.nanoTime\nimport Assertion.isGreaterThan\n\nval clockSuite = suite("clock") (\n  test("time is non-zero") {\n    assertM(Live.live(nanoTime))(isGreaterThan(0L))\n  }\n)\n// clockSuite: Spec[zio.Has[Live], TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "clock",\n//     spec = Spec(\n//       caseValue = LabeledCase(\n//         label = "time is non-zero",\n//         spec = Spec(\n//           caseValue = TestCase(\n//             test = <function1>,\n//             annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,21)))\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,"As you can see the whole suite was assigned to ",(0,o.kt)("inlineCode",{parentName:"p"},"clockSuite")," val. As it was said suites can contain other suites, so we can aggregate them as much as needed."),(0,o.kt)("p",null,"For example, we can have multiple suites that test external HTTP APIs and one big suite that will aggregate them all:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport Assertion._\n\nval paymentProviderABCSuite  =\n  suite("ABC payment provider tests") {\n    test("Your test")(\n      assert("Your value")(Assertion.isNonEmptyString)\n    )\n  }\n// paymentProviderABCSuite: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "ABC payment provider tests",\n//     spec = Spec(\n//       caseValue = LabeledCase(\n//         label = "Your test",\n//         spec = Spec(\n//           caseValue = TestCase(\n//             test = <function1>,\n//             annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,38)))\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval paymentProviderXYZSuite  =\n  suite("XYZ payment provider tests") {\n    test("Your other test")(\n      assert("Your other value")(Assertion.isNonEmptyString)\n    )\n  }\n// paymentProviderXYZSuite: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "XYZ payment provider tests",\n//     spec = Spec(\n//       caseValue = LabeledCase(\n//         label = "Your other test",\n//         spec = Spec(\n//           caseValue = TestCase(\n//             test = <function1>,\n//             annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,46)))\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval allPaymentProvidersTests =\n  suite("All payment providers tests")(\n    paymentProviderABCSuite,\n    paymentProviderXYZSuite\n  )\n// allPaymentProvidersTests: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "All payment providers tests",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "ABC payment provider tests",\n//               spec = Spec(\n//                 caseValue = LabeledCase(\n//                   label = "Your test",\n//                   spec = Spec(\n//                     caseValue = TestCase(\n//                       test = <function1>,\n//                       annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,38)))\n//                     )\n//                   )\n//                 )\n//               )\n//             )\n//           ),\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "XYZ payment provider tests",\n//               spec = Spec(\n//                 caseValue = LabeledCase(\n//                   label = "Your other test",\n//                   spec = Spec(\n//                     caseValue = TestCase(\n//                       test = <function1>,\n//                       annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,46)))\n//                     )\n//                   )\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,"Real tests that run some logic and return testing result are created mostly with ",(0,o.kt)("inlineCode",{parentName:"p"},"test")," function. It expects two arguments, first one will be the label of test which will be used for visual reporting back to the user, and an assertion of type ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO[R, E, TestResult]"),"."),(0,o.kt)("p",null,"This means writing test in ",(0,o.kt)("inlineCode",{parentName:"p"},"zio-test")," mostly gets down to creating a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," object that will produce ",(0,o.kt)("inlineCode",{parentName:"p"},"TestResult"),"."),(0,o.kt)("p",null,"There is another variant of function for creating a test that are pure called simply ",(0,o.kt)("inlineCode",{parentName:"p"},"test"),". It expects a thunk of code that will just return a ",(0,o.kt)("inlineCode",{parentName:"p"},"TestResult")," without packing it into ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO"),"."),(0,o.kt)("h3",{id:"assertions---creating-testresults"},"Assertions - creating TestResults"),(0,o.kt)("p",null,"As it was already mentioned, tests should return ",(0,o.kt)("inlineCode",{parentName:"p"},"TestResult"),". The most common way to produce a ",(0,o.kt)("inlineCode",{parentName:"p"},"TestResult")," is to resort to ",(0,o.kt)("inlineCode",{parentName:"p"},"assert")," or its effectful counterpart ",(0,o.kt)("inlineCode",{parentName:"p"},"assertM"),". Both of them accept a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," (effectful version wrapped in a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO"),") and an ",(0,o.kt)("inlineCode",{parentName:"p"},"Assertion[A]"),"."),(0,o.kt)("p",null,"To create ",(0,o.kt)("inlineCode",{parentName:"p"},"Assertion[A]")," object one can use functions defined under ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.test.Assertion"),". There are already a number of useful assertions predefined like ",(0,o.kt)("inlineCode",{parentName:"p"},"equalTo"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"isFalse"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"isTrue"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"contains"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"throws")," and more."),(0,o.kt)("p",null,"What is really useful in assertions is that they behave like boolean values and can be composed with operators\nknown from operating on boolean values like and (",(0,o.kt)("inlineCode",{parentName:"p"},"&&"),"), or (",(0,o.kt)("inlineCode",{parentName:"p"},"||"),"), negation (",(0,o.kt)("inlineCode",{parentName:"p"},"negate"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion\n\nval assertionForString: Assertion[String] = \n  Assertion.containsString("Foo") && Assertion.endsWithString("Bar")\n// assertionForString: Assertion[String] = (containsString(Foo) && endsWithString(Bar))\n')),(0,o.kt)("p",null,"What's more, assertions also compose with each other allowing for doing rich diffs not only simple value to value comparison:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion.{isRight, isSome,equalTo, hasField}\n\ntest("Check assertions") {\n  assert(Right(Some(2)))(isRight(isSome(equalTo(2))))\n}\n// res0: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Check assertions",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,75)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,"Here we're checking deeply nested values inside an ",(0,o.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Option"),". Because ",(0,o.kt)("inlineCode",{parentName:"p"},"Assertion"),"s compose this is not a problem. All layers are being peeled off tested for the condition until the final value is reached."),(0,o.kt)("p",null,"Here the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"Right(Some(2))")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Either[Any, Option[Int]]"),"and our assertion ",(0,o.kt)("inlineCode",{parentName:"p"},"isRight(isSome(equalTo(2)))")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Assertion[Either[Any, Option[Int]]]")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.Assertion.{isRight, isSome,equalTo, isGreaterThanEqualTo, not, hasField}\n\nfinal case class Address(country:String, city:String)\nfinal case class User(name:String, age:Int, address: Address)\n\ntest("Rich checking") {\n  assert(\n    User("Jonny", 26, Address("Denmark", "Copenhagen"))\n  )(\n    hasField("age", (u:User) => u.age, isGreaterThanEqualTo(18)) &&\n    hasField("country", (u:User) => u.address.country, not(equalTo("USA")))\n  )\n}\n// res2: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Rich checking",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,98)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,"There is also an easy way to test an object's data for certain assertions with ",(0,o.kt)("inlineCode",{parentName:"p"},"hasField")," which accepts besides a name, a mapping function from object to its tested property, and ",(0,o.kt)("inlineCode",{parentName:"p"},"Assertion")," object which will validate this property. Here our test checks if a person has at least 18 years and is not from the USA."),(0,o.kt)("p",null,"What is nice about those tests is that test reporters will tell you exactly which assertion was broken. Let's say we would change ",(0,o.kt)("inlineCode",{parentName:"p"},"isGreaterThanEqualTo(18)")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"isGreaterThanEqualTo(40)")," which will fail. Printout\non the console will be a nice detailed text explaining what exactly went wrong:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'[info]       User(Jonny,26,Address(Denmark,Copenhagen)) did not satisfy (hasField("age", _.age, isGreaterThanEqualTo(45)) && hasField("country", _.country, not(equalTo(USA))))\n[info]       26 did not satisfy isGreaterThanEqualTo(45)\n')),(0,o.kt)("p",null,"Having this all in mind, probably the most common and also most readable way of structuring tests is to pass a for-comprehension to ",(0,o.kt)("inlineCode",{parentName:"p"},"test")," function and yield a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"assert")," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.{test => _, _}\nimport zio.test._\nimport Assertion._\n\ntest("Semaphore should expose an available number of permits") {\n  for {\n    s         <- Semaphore.make(1L)\n    permits   <- s.available.commit\n  } yield assert(permits)(equalTo(1L))\n}\n// res3: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Semaphore should expose an available number of permits",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,120)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("h3",{id:"running-tests"},"Running tests"),(0,o.kt)("p",null,"When all of our tests are constructed, we need to have a way to actually execute them. Your first stop is the ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.test.DefaultRunnableSpec")," which accepts a single suite that will be executed. A single suite might seem to be limiting but as it was already said suites can hold any number of other suites. You may structure your tests like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.Clock.nanoTime\nimport Assertion._\n\nval suite1 = suite("suite1") (\n  test("s1.t1") {assertM(nanoTime)(isGreaterThanEqualTo(0L))},\n  test("s1.t2") {assertM(nanoTime)(isGreaterThanEqualTo(0L))}\n)\n// suite1: Spec[Has[Clock], TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "suite1",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s1.t1",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,141)))\n//                 )\n//               )\n//             )\n//           ),\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s1.t2",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,142)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval suite2 = suite("suite2") (\n  test("s2.t1") {assertM(nanoTime)(isGreaterThanEqualTo(0L))},\n  test("s2.t2") {assertM(nanoTime)(isGreaterThanEqualTo(0L))},\n  test("s2.t3") {assertM(nanoTime)(isGreaterThanEqualTo(0L))}\n)\n// suite2: Spec[Has[Clock], TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "suite2",\n//     spec = Spec(\n//       caseValue = MultipleCase(\n//         specs = IndexedSeq(\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s2.t1",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,147)))\n//                 )\n//               )\n//             )\n//           ),\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s2.t2",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,148)))\n//                 )\n//               )\n//             )\n//           ),\n//           Spec(\n//             caseValue = LabeledCase(\n//               label = "s2.t3",\n//               spec = Spec(\n//                 caseValue = TestCase(\n//                   test = <function1>,\n//                   annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,149)))\n//                 )\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval suite3 = suite("suite3") (\n  test("s3.t1") {assertM(nanoTime)(isGreaterThanEqualTo(0L))}\n)\n// suite3: Spec[Has[Clock], TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "suite3",\n//     spec = Spec(\n//       caseValue = LabeledCase(\n//         label = "s3.t1",\n//         spec = Spec(\n//           caseValue = TestCase(\n//             test = <function1>,\n//             annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,154)))\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n\nobject AllSuites extends DefaultRunnableSpec {\n  def spec = suite("All tests")(suite1, suite2, suite3)\n}\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," is very similar in its logic of operations to ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.App"),". Instead of providing one ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," application at the end of the world, we provide a suite that can be a tree of other suites and tests. Another resemblance is that ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," provides an Environment."),(0,o.kt)("p",null,"Here it is an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"TestEnvironment")," which helps us with controlling our systems infrastructure. More info on using test environment can be found in the sections below."),(0,o.kt)("p",null,"Just like with ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.App")," where at the very end an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO[R,E,A]")," is expected where ",(0,o.kt)("inlineCode",{parentName:"p"},"R")," can be at maximum of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Environment")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," ",(0,o.kt)("inlineCode",{parentName:"p"},"R")," cannot be more than ",(0,o.kt)("inlineCode",{parentName:"p"},"TestEnvironment"),". So just like in normal application if our ",(0,o.kt)("inlineCode",{parentName:"p"},"R")," is composed of some other modules we need to provide them first before test can be executed. How can we provide our dependencies?"),(0,o.kt)("p",null,"Here again, the design of ",(0,o.kt)("inlineCode",{parentName:"p"},"zio-test")," shines. Since our tests are ordinary values we can just transform them with a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"mapTest"),". It accepts a lambda of type ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO[R with TestSystem, TestFailure[Throwable], TestSuccess[Unit] ] => T1"),"."),(0,o.kt)("p",null,"Without getting into too much detail about types, we can see that our lambda argument is a test instance (",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO"),") that expects an environment of type ",(0,o.kt)("inlineCode",{parentName:"p"},"R with TestSystem"),". This is no different from normal usage of ZIO in ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.App"),". We can use the same ",(0,o.kt)("inlineCode",{parentName:"p"},"provide"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"provideSome")," methods to provide modules that ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," cannot provide itself as those are users modules."),(0,o.kt)("p",null,"When all dependencies are provided, we can run our tests in two ways. If we added ",(0,o.kt)("inlineCode",{parentName:"p"},"zio-test-sbt")," to our dependencies and ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.test.sbt.TestFramework")," to SBT's ",(0,o.kt)("inlineCode",{parentName:"p"},"testFrameworks")," our tests should be automatically picked up by SBT on invocation of ",(0,o.kt)("inlineCode",{parentName:"p"},"test"),". However, if we're not using SBT or have some other special needs ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultRunnableSpec")," has a ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," method which can be invoked directly or with SBTs ",(0,o.kt)("inlineCode",{parentName:"p"},"test:run"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sbt"},'libraryDependencies ++= Seq(\n  "dev.zio" %% "zio-test"     % zioVersion % "test",\n  "dev.zio" %% "zio-test-sbt" % zioVersion % "test"\n),\ntestFrameworks += new TestFramework("zio.test.sbt.ZTestFramework")\n')),(0,o.kt)("h2",{id:"using-test-environment"},"Using Test Environment"),(0,o.kt)("p",null,"What we expect from tests (at least those that we consider unit tests) is to be stable, i.e., consecutive runs should yield the same results and take more or less the same amount of time."),(0,o.kt)("p",null,"The biggest source of complexity during testing comes from external services which we cannot control like external payment APIs, object storages, HTTP APIs, etc. It is normal to hide these kinds of services behind an interface and provide test instances to regain control and determinism."),(0,o.kt)("p",null,"However, there is another source of complexity that comes from the local infrastructure that is also hard to control without building prior abstractions. Things like stdin/stdout, clocks, random generators, schedulers can make writing tests hard or even impossible."),(0,o.kt)("p",null,"Fortunately, ZIO abstracted most of it in its runtime under ",(0,o.kt)("inlineCode",{parentName:"p"},"Environment")," type. Thanks to this design ",(0,o.kt)("inlineCode",{parentName:"p"},"zio-test")," could easily provide its own implementation named ",(0,o.kt)("inlineCode",{parentName:"p"},"TestEnvironment")," which gives you test implementations of mentioned infrastructure."),(0,o.kt)("p",null,"In most of the cases when you'll be using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO"),"s ",(0,o.kt)("inlineCode",{parentName:"p"},"test")," test implementations are already created and should be controlled by exposed functions on companion object."),(0,o.kt)("p",null,"If for some reason you would like to provide a custom environment or are using another testing framework but still want to use test environment there are ",(0,o.kt)("inlineCode",{parentName:"p"},"make")," functions on companion objects of test modules where you can construct your own."),(0,o.kt)("p",null,"It is easy to accidentally use different test instances at the same time."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.environment.TestClock\nimport Assertion._\n\ntest("`acquire` doesn\'t leak permits upon cancellation") {\n  for {\n      testClock <- TestClock.makeTest(TestClock.DefaultData)\n      s         <- Semaphore.make(1L)\n      sf        <- s.acquireN(2).timeout(1.millisecond).either.fork\n      _         <- testClock.adjust(1.second)\n      _         <- sf.join\n      _         <- s.release\n      permits   <- s.available\n  } yield assert(permits, equalTo(2L))\n}\n')),(0,o.kt)("p",null,"The above code doesn't work. We created a new ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock")," instance and are correctly adjusting its time. What might be surprising is that call to ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout")," will use the ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock")," provided by the ",(0,o.kt)("inlineCode",{parentName:"p"},"TestEnvironment")," not our ",(0,o.kt)("inlineCode",{parentName:"p"},"testClock")," instance. It is easy to know why when you look at the signature of ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.Clock\n\nsealed trait ZIO[-R, +E, +A] extends Serializable { self =>\n    /* All other method declarations in this trait ignored to avoid clutter */\n\n    def timeout(d: Duration): ZIO[R with Has[Clock], E, Option[A]]\n}\n")),(0,o.kt)("p",null,"The returned type is ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO[R with Clock, E, Option[A]]"),' where our environment is "some R plus a Clock". Before running this ',(0,o.kt)("inlineCode",{parentName:"p"},"Clock")," has to be provided, and the framework provides the Clock from the ",(0,o.kt)("inlineCode",{parentName:"p"},"TestEnvironment")," not our instance variable as it is not aware that we created it."),(0,o.kt)("p",null,"If you need to provide real implementations instead of the test instances to some part of your tests there is a ",(0,o.kt)("inlineCode",{parentName:"p"},"live")," method that will transform your ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO[R, E, A]")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO[Live[R], E, A]"),". Going from ",(0,o.kt)("inlineCode",{parentName:"p"},"R")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Live[R]")," instructs the framework that we really want to be provided with live implementations."),(0,o.kt)("h3",{id:"testing-random"},"Testing Random"),(0,o.kt)("p",null,"When working with randomness, testing might be hard because the inputs to the tested function change on every invocation. So our code behaves in an indeterministic way."),(0,o.kt)("p",null,"Precisely because of this reason ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," exposes ",(0,o.kt)("inlineCode",{parentName:"p"},"TestRandom")," module which allows for fully deterministic testing of code that deals with Randomness. ",(0,o.kt)("inlineCode",{parentName:"p"},"TestRandom")," can operate in two modes based on the needed use-case."),(0,o.kt)("p",null,"In the first mode it is a purely functional pseudo-random number generator. During generation on random values like when calling ",(0,o.kt)("inlineCode",{parentName:"p"},"nextInt")," no internal state is being mutated. It is expected to chain such operations with combinators like ",(0,o.kt)("inlineCode",{parentName:"p"},"flatMap"),". To preserve the same values generated between invocation of tests ",(0,o.kt)("inlineCode",{parentName:"p"},"setSeed")," method can be used. It is guaranteed to return the same sequence of values for any given seed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.assert\nimport zio.test.environment.TestRandom\nimport zio.test.Assertion.equalTo\n\ntest("Use setSeed to generate stable values") {\n  for {\n    _  <- TestRandom.setSeed(27)\n    r1 <- Random.nextLong\n    r2 <- Random.nextLong\n    r3 <- Random.nextLong\n  } yield\n    assert(List(r1,r2,r3))(equalTo(List[Long](\n      -4947896108136290151L,\n      -5264020926839611059L,\n      -9135922664019402287L\n    )))\n}\n// res4: Spec[Has[TestRandom] with Has[Random], TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Use setSeed to generate stable values",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,188)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,"In the second mode ",(0,o.kt)("inlineCode",{parentName:"p"},"TestRandom"),' maintains an internal buffer of values that can be "fed" upfront with methods such as ',(0,o.kt)("inlineCode",{parentName:"p"},"feedInts"),". When random values are being generated, the first values from that buffer are being used."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.environment.TestRandom\ntest("One can provide its own list of ints") {\n  for {\n    _  <- TestRandom.feedInts(1, 9, 2, 8, 3, 7, 4, 6, 5)\n    r1 <- Random.nextInt\n    r2 <- Random.nextInt\n    r3 <- Random.nextInt\n    r4 <- Random.nextInt\n    r5 <- Random.nextInt\n    r6 <- Random.nextInt\n    r7 <- Random.nextInt\n    r8 <- Random.nextInt\n    r9 <- Random.nextInt\n  } yield assert(\n    List(1, 9, 2, 8, 3, 7, 4, 6, 5)\n  )(equalTo(List(r1, r2, r3, r4, r5, r6, r7, r8, r9)))\n}\n// res5: Spec[Has[TestRandom] with Has[Random], TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "One can provide its own list of ints",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,209)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,"When we run out of values in buffer ",(0,o.kt)("inlineCode",{parentName:"p"},"TestRandom")," it falls back to the first mode. If we want we can also clear internal buffers by calling methods like ",(0,o.kt)("inlineCode",{parentName:"p"},"clearInts"),"."),(0,o.kt)("h3",{id:"testing-clock"},"Testing Clock"),(0,o.kt)("p",null,"In most cases you want unit tests to be as fast as possible. Waiting for real time to pass by is a real killer for this."),(0,o.kt)("p",null,"ZIO exposes a ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"TestEnvironment")," that can control the time. We can deterministically and efficiently test effects involving the passage of time without actually having to wait for the full amount of time to pass."),(0,o.kt)("p",null,"Calls to ",(0,o.kt)("inlineCode",{parentName:"p"},"sleep")," and methods derived from it will semantically block until the clock time is set/adjusted to on or after the time the effect is scheduled to run."),(0,o.kt)("h4",{id:"clock-time"},"Clock Time"),(0,o.kt)("p",null,"Clock time is just like a clock on the wall, except that in our ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock"),", the clock is broken. Instead of moving by itself, the clock time only changes when adjusted or set by the user, using the ",(0,o.kt)("inlineCode",{parentName:"p"},"adjust")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"setTime")," methods. The clock time never changes by itself."),(0,o.kt)("p",null,"When the clock is adjusted, any effects scheduled to run on or before the new clock time will automatically be run, in order."),(0,o.kt)("h4",{id:"examples"},"Examples"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1")),(0,o.kt)("p",null,"Thanks to the call to ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock.adjust(1.minute)")," we moved the time instantly 1 minute."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import java.util.concurrent.TimeUnit\nimport zio.Clock.currentTime\nimport zio.test.Assertion.isGreaterThanEqualTo\nimport zio.test._\nimport zio.test.environment.TestClock\n\ntest("One can move time very fast") {\n  for {\n    startTime <- currentTime(TimeUnit.SECONDS)\n    _         <- TestClock.adjust(1.minute)\n    endTime   <- currentTime(TimeUnit.SECONDS)\n  } yield assert(endTime - startTime)(isGreaterThanEqualTo(60L))\n}\n// res6: Spec[Has[TestClock] with Has[Clock], TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "One can move time very fast",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,245)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"TestClock")," affects also all code running asynchronously that is scheduled to run after a certain time:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion.equalTo\nimport zio.test._\nimport zio.test.environment.TestClock\n\ntest("One can control time as he see fit") {\n  for {\n    promise <- Promise.make[Unit, Int]\n    _       <- (ZIO.sleep(10.seconds) *> promise.succeed(1)).fork\n    _       <- TestClock.adjust(10.seconds)\n    readRef <- promise.await\n  } yield assert(1)(equalTo(readRef))\n}\n// res7: Spec[Has[Clock] with Has[TestClock], TestFailure[Unit], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "One can control time as he see fit",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,266)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,'The above code creates a write-once cell that will be set to "1" after 10 seconds asynchronously from a different thread thanks to the call to ',(0,o.kt)("inlineCode",{parentName:"p"},"fork"),". In the end, we wait on the promise until it is set."),(0,o.kt)("p",null,"With the call to ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock.adjust(10.seconds)")," we simulate the passing of 10 seconds of time. Because of it, we don't need to wait for the real 10 seconds to pass and thus our unit test can run faster."),(0,o.kt)("p",null,"This is a pattern that will very often be used when ",(0,o.kt)("inlineCode",{parentName:"p"},"sleep")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock")," are being used for testing of effects that are based on time. The fiber that needs to sleep will be forked and ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock")," will used to adjust the time so that all expected effects are run in the forked fiber."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 3")),(0,o.kt)("p",null,"A more complex example leveraging layers and multiple services is shown below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion._\nimport zio.test._\nimport zio.test.environment.{ TestClock, TestEnvironment }\nimport zio.{test => _, _}\n\ntrait SchedulingService {\n  def schedule(promise: Promise[Unit, Int]): ZIO[Any, Exception, Boolean]\n}\n\ntrait LoggingService {\n  def log(msg: String): ZIO[Any, Exception, Unit]\n}\n\nval schedulingLayer: ZLayer[Has[Clock] with Has[LoggingService], Nothing, Has[SchedulingService]] =\n  ZLayer.fromFunction { env =>\n    new SchedulingService {\n      def schedule(promise: Promise[Unit, Int]): ZIO[Any, Exception, Boolean] =\n        (ZIO.sleep(10.seconds) *> promise.succeed(1))\n          .tap(b => ZIO.service[LoggingService].flatMap(_.log(b.toString)))\n          .provide(env)\n    }\n}\n// schedulingLayer: ZLayer[Has[Clock] with Has[LoggingService], Nothing, Has[SchedulingService]] = Managed(\n//   self = zio.ZManaged$$anon$2@a06191d\n// )\n\ntest("One can control time for failing effects too") {\n  val failingLogger = ZLayer.succeed(new LoggingService {\n    override def log(msg: String): ZIO[Any, Exception, Unit] = ZIO.fail(new Exception("BOOM"))\n  })\n\n  val partialLayer = (Clock.any ++ failingLogger) >>> schedulingLayer\n\n  val testCase =\n    for {\n      promise <- Promise.make[Unit, Int]\n      result  <- ZIO.service[SchedulingService].flatMap(_.schedule(promise)).exit.fork\n      _       <- TestClock.adjust(10.seconds)\n      readRef <- promise.await\n      result  <- result.join\n    } yield assert(1)(equalTo(readRef)) && assert(result)(fails(isSubtype[Exception](anything)))\n  testCase.provideSomeLayer[TestEnvironment](partialLayer)\n}\n// res9: Spec[Has[Annotations] with Has[environment.Live] with Has[Sized] with Has[TestClock] with Has[TestConfig] with Has[environment.TestConsole] with Has[environment.TestRandom] with Has[environment.TestSystem] with Has[Clock] with Has[Console] with Has[System] with Has[Random], TestFailure[Unit], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "One can control time for failing effects too",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,315)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,"In this case, we want to test a layered effect that can potentially fail with an error. To do this we need to run the effect and use assertions that expect an ",(0,o.kt)("inlineCode",{parentName:"p"},"Exit")," value."),(0,o.kt)("p",null,"Because we are providing a layer to the test we need to provide everything expected by our test case and leave the test environment behind using ",(0,o.kt)("inlineCode",{parentName:"p"},".provideSomeLayer[TestEnvironment]"),"."),(0,o.kt)("p",null,"Keep in mind we do not provide any implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Clock")," because doing will make force ",(0,o.kt)("inlineCode",{parentName:"p"},"SchedulingService")," to use it, while the clock we need here is the ",(0,o.kt)("inlineCode",{parentName:"p"},"TestClock")," provided by the test environment."),(0,o.kt)("p",null,"The pattern with ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," can be generalized when we need to wait for multiple values using a ",(0,o.kt)("inlineCode",{parentName:"p"},"Queue"),". We simply need to put multiple values into the queue and progress the clock multiple times and there is no need to create multiple promises."),(0,o.kt)("p",null,"Even if you have a non-trivial flow of data from multiple streams that can produce at different intervals and would like to test snapshots of data at a particular point in time ",(0,o.kt)("inlineCode",{parentName:"p"},"Queue")," can help with that."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion.equalTo\nimport zio.test._\nimport zio.test.environment.TestClock\nimport zio.stream._\n\ntest("zipWithLatest") {\n  val s1 = Stream.iterate(0)(_ + 1).fixed(100.milliseconds)\n  val s2 = Stream.iterate(0)(_ + 1).fixed(70.milliseconds)\n  val s3 = s1.zipWithLatest(s2)((_, _))\n\n  for {\n    q      <- Queue.unbounded[(Int, Int)]\n    _      <- s3.foreach(q.offer).fork\n    fiber  <- ZIO.collectAll(ZIO.replicate(4)(q.take)).fork\n    _      <- TestClock.adjust(1.second)\n    result <- fiber.join\n  } yield assert(result)(equalTo(List(0 -> 0, 0 -> 1, 1 -> 1, 1 -> 2)))\n}\n// res10: Spec[Any with Has[Clock] with Has[TestClock], TestFailure[Nothing], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "zipWithLatest",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,349)))\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("h3",{id:"testing-console"},"Testing Console"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"TestConsole")," allows testing of applications that interact with the console by modeling working with standard input and output as writing and reading to and from internal buffers:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.environment.TestConsole\nimport zio.Console\n\nval consoleSuite = suite("ConsoleTest")(\n  test("One can test output of console") {\n    for {\n      _              <- TestConsole.feedLines("Jimmy", "37")\n      _              <- Console.printLine("What is your name?")\n      name           <- Console.readLine\n      _              <- Console.printLine("What is your age?")\n      age            <- Console.readLine.map(_.toInt)\n      questionVector <- TestConsole.output\n      q1             = questionVector(0)\n      q2             = questionVector(1)\n    } yield {\n      assert(name)(equalTo("Jimmy")) &&\n      assert(age)(equalTo(37)) &&\n      assert(q1)(equalTo("What is your name?\\n")) &&\n      assert(q2)(equalTo("What is your age?\\n"))\n    }\n  }\n)\n// consoleSuite: Spec[Has[Console] with Has[TestConsole], TestFailure[java.io.IOException], TestSuccess] = Spec(\n//   caseValue = LabeledCase(\n//     label = "ConsoleTest",\n//     spec = Spec(\n//       caseValue = LabeledCase(\n//         label = "One can test output of console",\n//         spec = Spec(\n//           caseValue = TestCase(\n//             test = <function1>,\n//             annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(test_effects.md,374)))\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n')),(0,o.kt)("p",null,"The above code simulates an application that will ask for the name and age of the user. To test it we prefill buffers with answers with the call to ",(0,o.kt)("inlineCode",{parentName:"p"},"TestConsole.feedLines")," method. Calls to ",(0,o.kt)("inlineCode",{parentName:"p"},"Console.readLine")," will get the value from the buffers instead of interacting with the users keyboard."),(0,o.kt)("p",null,"Also, all output that our program produces by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"Console.printLine")," (and other printing methods) is being gathered and can be accessed with a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"TestConsole.output"),"."),(0,o.kt)("h3",{id:"testing-system"},"Testing System"),(0,o.kt)("p",null,"With the increased usage of containers and runtimes like Kubernetes, more and more applications are being configured by means of environment variables. It is important to test this logic just like other parts of an application."),(0,o.kt)("p",null,"For this purpose ",(0,o.kt)("inlineCode",{parentName:"p"},"zio-test")," exposes ",(0,o.kt)("inlineCode",{parentName:"p"},"TestSystem")," module. Additionally, to setting the environment variables it also allows for setting JVM system properties like in the code below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.environment._\n\nfor {\n  _      <- TestSystem.putProperty("java.vm.name", "VM")\n  result <- System.property("java.vm.name")\n} yield assert(result)(equalTo(Some("VM")))\n// res11: ZIO[Has[TestSystem] with Has[System], Throwable, TestResult] = zio.ZIO$FlatMap@24e82844\n')),(0,o.kt)("p",null,"It is worth noticing that no actual environment variables or properties will be set during testing so there will be no impact on other parts of the system."),(0,o.kt)("h2",{id:"test-aspects"},"Test Aspects"),(0,o.kt)("p",null,"Test aspects are used to modify existing tests or even entire suites that you have already created. Test aspects are applied to a test or suite using the ",(0,o.kt)("inlineCode",{parentName:"p"},"@@")," operator."),(0,o.kt)("p",null,"This is an example test suite showing the use of aspects to modify test behavior:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.{test => _, _}\nimport zio.test.Assertion._\nimport zio.test.TestAspect._\nimport zio.test._\n\nobject MySpec extends DefaultRunnableSpec {\n  def spec = suite("A Suite")(\n    test("A passing test") {\n      assert(true)(isTrue)\n    },\n    test("A passing test run for JVM only") {\n      assert(true)(isTrue)\n    } @@ jvmOnly, //@@ jvmOnly only runs tests on the JVM\n    test("A passing test run for JS only") {\n      assert(true)(isTrue)\n    } @@ jsOnly, //@@ jsOnly only runs tests on Scala.js\n    test("A passing test with a timeout") {\n      assert(true)(isTrue)\n    } @@ timeout(10.nanos), //@@ timeout will fail a test that doesn\'t pass within the specified time\n    test("A failing test... that passes") {\n      assert(true)(isFalse)\n    } @@ failing, //@@ failing turns a failing test into a passing test\n    test("A ignored test") {\n      assert(false)(isTrue)\n    } @@ ignore, //@@ ignore marks test as ignored\n    test("A flaky test that only works on the JVM and sometimes fails; let\'s compose some aspects!") {\n      assert(false)(isTrue)\n    } @@ jvmOnly           // only run on the JVM\n      @@ eventually        //@@ eventually retries a test indefinitely until it succeeds\n      @@ timeout(20.nanos) //it\'s a good idea to compose `eventually` with `timeout`, or the test may never end\n  ) @@ timeout(60.seconds)   //apply a timeout to the whole suite\n}\n')))}d.isMDXComponent=!0}}]);