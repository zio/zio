"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[42956],{15680:(e,n,t)=>{t.d(n,{xA:()=>m,yg:()=>u});var r=t(96540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},g="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),g=p(t),d=a,u=g["".concat(l,".").concat(d)]||g[d]||c[d]||o;return t?r.createElement(u,i(i({ref:n},m),{},{components:t})):r.createElement(u,i({ref:n},m))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[g]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},76845:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=t(58168),a=(t(96540),t(15680));const o={id:"how-generators-work",title:"How Generators Work?"},i=void 0,s={unversionedId:"reference/test/property-testing/how-generators-work",id:"reference/test/property-testing/how-generators-work",title:"How Generators Work?",description:"A Gen[R, A] represents a generator of values of type A, which requires an environment R. The Gen data type is the base functionality for generating test data for property-based testing. We use them to produce deterministic and non-deterministic (PRNG) random values.",source:"@site/docs/reference/test/property-testing/how-generators-work.md",sourceDirName:"reference/test/property-testing",slug:"/reference/test/property-testing/how-generators-work",permalink:"/reference/test/property-testing/how-generators-work",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/property-testing/how-generators-work.md",tags:[],version:"current",frontMatter:{id:"how-generators-work",title:"How Generators Work?"},sidebar:"reference-sidebar",previous:{title:"Getting Started",permalink:"/reference/test/property-testing/getting-started"},next:{title:"Built-in Generators",permalink:"/reference/test/property-testing/built-in-generators"}},l={},p=[{value:"How Generators Work?",id:"how-generators-work",level:2},{value:"Two Types of Generators",id:"two-types-of-generators",level:2},{value:"Random Generators Are Deterministic by Default",id:"random-generators-are-deterministic-by-default",level:2},{value:"How Samples Are Generated?",id:"how-samples-are-generated",level:2},{value:"Running a Generator For Debugging Purpose",id:"running-a-generator-for-debugging-purpose",level:2}],m={toc:p},g="wrapper";function c(e){let{components:n,...t}=e;return(0,a.yg)(g,(0,r.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"A ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen[R, A]")," represents a generator of values of type ",(0,a.yg)("inlineCode",{parentName:"p"},"A"),", which requires an environment ",(0,a.yg)("inlineCode",{parentName:"p"},"R"),". The ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen")," data type is the base functionality for generating test data for property-based testing. We use them to produce deterministic and non-deterministic (PRNG) random values."),(0,a.yg)("p",null,"It is encoded as a stream of optional samples:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"case class Gen[-R, +A](sample: ZStream[R, Nothing, Option[Sample[R, A]]])\n")),(0,a.yg)("p",null,"Before deep into the generators, let's see what is property-based testing and what problem it solves in the testing world."),(0,a.yg)("h2",{id:"how-generators-work"},"How Generators Work?"),(0,a.yg)("p",null,"We can think of ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen[R, A]")," as a ",(0,a.yg)("inlineCode",{parentName:"p"},"ZStream[R, Nothing, A]"),". For example the ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen.int")," is a stream of random integers ",(0,a.yg)("inlineCode",{parentName:"p"},"ZStream.fromZIO(Random.nextInt)"),"."),(0,a.yg)("p",null,"To find out how a generator works, Let's take a look at the following snippet.  It shows how the ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen")," data type is implemented."),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},'Although it doesn\'t provide the exact implementation, this condensed edition of the "Gen" data type is sufficient to grasp how generators operate.'),(0,a.yg)("p",{parentName:"admonition"},"For instance, we don't use a ",(0,a.yg)("a",{parentName:"p",href:"#random-generators-are-deterministic-by-default"},"pseudo-random generator")," throughout the following implementation. We haven't encoded the ",(0,a.yg)("a",{parentName:"p",href:"/reference/test/property-testing/shrinking"},"shrinking algorithm"),", either.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.test._\nimport zio.stream._\n\ncase class Gen[R, A](sample: ZStream[R, Nothing, A]) {\n  def map[B](f: A => B): Gen[R, B] = Gen(sample.map(f))\n\n  def flatMap[R1 <: R, B](f: A => Gen[R1, B]): Gen[R1, B] = ???\n\n  def runCollect: ZIO[R, Nothing, List[A]] = sample.runCollect.map(_.toList)\n}\n\nobject Gen {\n  // A constant generator of the specified value.\n  def const[A](a: => A): Gen[Any, A] = \n    Gen(ZStream.succeed(a))\n  \n  // A random generator of integers.\n  def int: Gen[Any, Int] = \n    Gen(ZStream.fromZIO(Random.nextInt))\n  def int(min: Int, max: Int): Gen[Any, Int] = \n    ???\n  \n  // A random generator of specified values.\n  def elements[A](as: A*): Gen[Any, A] = \n    if (as.isEmpty) Gen(ZStream.empty) else int(0, as.length - 1).map(as)\n  \n  // A constant generator of fixed values.\n  def fromIterable[A](xs: Iterable[A]): Gen[Any, A] = \n    Gen(ZStream.fromIterable(xs))\n}\n\nGen.const(42).runCollect.debug\n// Output: List(42)\n\nGen.int.runCollect.debug\n// Output: List(82) or List(3423) or List(-352) or ...\n\nGen.elements(1, 2, 3).runCollect.debug\n// Output: List(1) or List(2) or List(3)\n\nGen.fromIterable(List(1, 2, 3))\n")),(0,a.yg)("p",null,"So we can see that the ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen")," data type is nothing more than the stream of random/constant values."),(0,a.yg)("h2",{id:"two-types-of-generators"},"Two Types of Generators"),(0,a.yg)("p",null,"We have two types of generators:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Deterministic Generators"),"\u2014 Generators that produce constant fixed values, such as ",(0,a.yg)("inlineCode",{parentName:"li"},"Gen.empty"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"Gen.const(42)")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"Gen.fromIterable(List(1, 2, 3))"),"."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Random Generators"),"\u2014 Generators that produce random values, such as ",(0,a.yg)("inlineCode",{parentName:"li"},"Gen.boolean"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"Gen.int"),", and ",(0,a.yg)("inlineCode",{parentName:"li"},"Gen.elements(1, 2, 3)"),".")),(0,a.yg)("h2",{id:"random-generators-are-deterministic-by-default"},"Random Generators Are Deterministic by Default"),(0,a.yg)("p",null,"The important fact about random generators is that they produce deterministic values by default. This means that if we run the same random generator multiple times, it will always produce the same sequence of values to achieve reproducibility."),(0,a.yg)("p",null,"So the let's add some debugging print lines inside a test and see what values are produced:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.TestAspect._\n\nobject ExampleSpec extends ZIOSpecDefault {\n  def spec =\n    test("example test") {\n      check(Gen.int(0, 10)) { n =>\n        println(n)\n        assertTrue(n + n == 2 * n)\n      }\n    } @@ samples(5)\n}\n')),(0,a.yg)("p",null,"We can see, even though the ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen.int")," is a non-deterministic generator, every time we run the test, the generator will produce the same sequence of values:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"runSpec\n9\n3\n0\n9\n6\n+ example test\n")),(0,a.yg)("p",null,"This is due to the fact that the generator uses a pseudo-random number generator which uses a deterministic algorithm."),(0,a.yg)("p",null,"The generator provides a fixed seed number to its underlying deterministic algorithm to generate random numbers. As the seed number is fixed, the generator will always produce the same sequence of values."),(0,a.yg)("p",null,"For more information, there is a separate page about this on ",(0,a.yg)("a",{parentName:"p",href:"/reference/test/services/random"},"TestRandom")," which is the underlying service for generating test values."),(0,a.yg)("p",null,"This behavior helps us to have reproducible tests. However, if we need non-deterministic tests values, we can use the ",(0,a.yg)("inlineCode",{parentName:"p"},"TestAspect.nondeterministic")," to change the default behavior:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.TestAspect._\n\nobject ExampleSpec extends ZIOSpecDefault {\n  def spec =\n    test("example test") {\n      check(Gen.int(0, 10)) { n =>\n        println(n)\n        assertTrue(n + n == 2 * n)\n      }\n    } @@ samples(5) @@ nondeterministic\n}\n')),(0,a.yg)("h2",{id:"how-samples-are-generated"},"How Samples Are Generated?"),(0,a.yg)("p",null,"When we run the ",(0,a.yg)("inlineCode",{parentName:"p"},"check")," function, the ",(0,a.yg)("inlineCode",{parentName:"p"},"check")," function repeatedly run the underlying stream of generators (using the ",(0,a.yg)("inlineCode",{parentName:"p"},"forever")," combinator), and then it takes ",(0,a.yg)("inlineCode",{parentName:"p"},"n")," samples from the stream, where ",(0,a.yg)("inlineCode",{parentName:"p"},"n")," is by default 200."),(0,a.yg)("p",null,"We can modify the default sample size by using the ",(0,a.yg)("inlineCode",{parentName:"p"},"samples")," test aspect. So if we the ",(0,a.yg)("inlineCode",{parentName:"p"},"check")," function, with ",(0,a.yg)("inlineCode",{parentName:"p"},"TestAspect.samples(5)"),". Let's see how the samples are produced for each of the following generators:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"check(Gen.const(42))(n => ???)")," it will repeatedly run the ",(0,a.yg)("inlineCode",{parentName:"li"},"Zstream.succeed(42)")," stream, and then take ",(0,a.yg)("inlineCode",{parentName:"li"},"n")," samples from it: 42, 42, 42, 42, 42."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"check(Gen.int)(n => ???)")," it will repeatedly run the ",(0,a.yg)("inlineCode",{parentName:"li"},"ZStream.fromZIO(Random.nextInt)")," stream, and then take ",(0,a.yg)("inlineCode",{parentName:"li"},"n")," samples from it: e.g. 2, -3422, 33, 3991334, 98138."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"check(Gen.elements(1, 2, 3))(n => ???)")," it will repeatedly run the ",(0,a.yg)("inlineCode",{parentName:"li"},"ZStream.fromZIO(Random.nextInt(2).flatMap(Chunk(1, 2, 3)))")," stream, and then take ",(0,a.yg)("inlineCode",{parentName:"li"},"n")," samples from it: e.g. 3, 1, 1, 3, 2."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"check(Gen.fromIterable(List(1, 2, 3)))(n => ???)")," it will repeatedly run the ",(0,a.yg)("inlineCode",{parentName:"li"},"ZStream.fromIterable(List(1, 2, 3))")," stream, and then take ",(0,a.yg)("inlineCode",{parentName:"li"},"n")," samples from it: 1, 2, 3, 1, 2.")),(0,a.yg)("p",null,"When we run the ",(0,a.yg)("inlineCode",{parentName:"p"},"check")," function with multiple generators, the samples will be the cartesian product of their streams. Let's try some examples:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("two deterministic generators") {\n  check(Gen.const(1), Gen.fromIterable(List("a", "b", "c"))) { (a, b) =>\n    println((a, b))\n    assertTrue(true)\n  }\n} @@ TestAspect.samples(5)\n')),(0,a.yg)("p",null,"The output will be:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"(1,a)\n(1,b)\n(1,c)\n(1,a)\n(1,b)\n+ two deterministic generators\n1 tests passed. 0 tests failed. 0 tests ignored.\n")),(0,a.yg)("p",null,"So the example above is something like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\n\n{\n  for {\n    a <- ZStream.succeed(1)\n    b <- ZStream.fromIterable(List("a", "b", "c"))\n  } yield (a, b)\n}.forever.take(5).runCollect.debug\n')),(0,a.yg)("p",null,"Now let's try use one non-deterministic generator and one deterministic generator:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("one non-deterministic generator and one deterministic generator") {\n  check(Gen.int(1, 3), Gen.fromIterable(List("a", "b", "c"))) { (a, b) =>\n    println((a, b))\n    assertTrue(true)\n  }\n} @@ TestAspect.samples(5)\n')),(0,a.yg)("p",null,"Here is one example output:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"(3,a)\n(3,b)\n(3,c)\n(2,a)\n(2,b)\n+ one non-deterministic generator and one deterministic generator\n1 tests passed. 0 tests failed. 0 tests ignored.\n")),(0,a.yg)("p",null,"This is the same as the previous example, it is like we have the following stream:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\n\n{\n  for {\n    a <- ZStream.fromZIO(Random.nextIntBetween(1, 3))\n    b <- ZStream.fromIterable(List("a", "b", "c"))\n  } yield (a, b)\n}.forever.take(5).runCollect.debug\n')),(0,a.yg)("h2",{id:"running-a-generator-for-debugging-purpose"},"Running a Generator For Debugging Purpose"),(0,a.yg)("p",null,"To run a generator, we can call ",(0,a.yg)("inlineCode",{parentName:"p"},"runCollect")," operation:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.test._\n\nval ints: ZIO[Any, Nothing, List[Int]] = Gen.int.runCollect.debug\n// Output: List(-2090696713)\n")),(0,a.yg)("p",null,"This will return a ",(0,a.yg)("inlineCode",{parentName:"p"},"ZIO")," effect containing all its values in a list, which in this example it contains only one element."),(0,a.yg)("p",null,"To create more samples, we can use ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen#runCollectN"),", which repeatedly runs the generator as much as we need. In this example, it will generate a list of containing 5 integer elements:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"Gen.int.runCollectN(5).debug\n")),(0,a.yg)("p",null,"In addition, there is an operator called ",(0,a.yg)("inlineCode",{parentName:"p"},"Gen#runHead"),", which returns the first value generated by the generator."))}c.isMDXComponent=!0}}]);