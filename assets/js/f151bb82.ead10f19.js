"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[6072],{95788:(e,t,n)=>{n.d(t,{Iu:()=>m,yg:()=>d});var a=n(11504);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=s(n),u=i,d=c["".concat(p,".").concat(u)]||c[u]||h[u]||r;return n?a.createElement(d,o(o({ref:t},m),{},{components:n})):a.createElement(d,o({ref:t},m))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},52832:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(45072),i=(n(11504),n(95788));const r={id:"commutativeeither",title:"CommutativeEither"},o=void 0,l={unversionedId:"zio-prelude/functional-abstractions/parameterized-types/commutativeeither",id:"zio-prelude/functional-abstractions/parameterized-types/commutativeeither",title:"CommutativeEither",description:"CommutativeEither[F] describes a way of combining two parameterized types F[A] and F[B] that is commutative.",source:"@site/docs/zio-prelude/functional-abstractions/parameterized-types/commutativeeither.md",sourceDirName:"zio-prelude/functional-abstractions/parameterized-types",slug:"/zio-prelude/functional-abstractions/parameterized-types/commutativeeither",permalink:"/zio-prelude/functional-abstractions/parameterized-types/commutativeeither",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/commutativeeither.md",tags:[],version:"current",frontMatter:{id:"commutativeeither",title:"CommutativeEither"},sidebar:"ecosystem-sidebar",previous:{title:"CommutativeBoth",permalink:"/zio-prelude/functional-abstractions/parameterized-types/commutativeboth"},next:{title:"Contravariant",permalink:"/zio-prelude/functional-abstractions/parameterized-types/contravariant"}},p={},s=[],m={toc:s},c="wrapper";function h(e){let{components:t,...n}=e;return(0,i.yg)(c,(0,a.c)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither[F]")," describes a way of combining two parameterized types ",(0,i.yg)("inlineCode",{parentName:"p"},"F[A]")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"F[B]")," that is commutative."),(0,i.yg)("p",null,"Its signature is:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait AssociativeEither[F[_]] {\n  def either(fa: => F[A], fb: => F[B]): F[Either[A, B]]\n}\n\ntrait CommutativeEither[F[_]] extends AssociativeEither[F]\n")),(0,i.yg)("p",null,"If we import ",(0,i.yg)("inlineCode",{parentName:"p"},"zio.prelude._")," we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"orElseEitherPar")," operator or its symbolic alias ",(0,i.yg)("inlineCode",{parentName:"p"},"<|>")," to combine two values of a parameterized type that has a ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," instance defined for it in a commutative way."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"either")," operator must be commutative. So after rearranging the order of ",(0,i.yg)("inlineCode",{parentName:"p"},"Either")," values the following property must hold:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"fa <|> fb === fb <|> fa\n")),(0,i.yg)("p",null,"This is the same as the law defined by the ",(0,i.yg)("inlineCode",{parentName:"p"},"Commutative")," abstraction for concrete types, but lifted into the context of parameterized types."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"either")," operator runs the left value and the right value in parallel, returning the result from either the left value or the right value."),(0,i.yg)("p",null,"We can see this by noting that the requirement that the ",(0,i.yg)("inlineCode",{parentName:"p"},"either")," operator is commutative places significant limitations on our implementation. We must choose on some basis between the left and right values but we can't run one and then if it fails run the other because that would in general not be commutative."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," provides a good example of why running the left value and then running the right value if it fails is not commutative and what a commutative operator would look like."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\nval helloZIO: ZIO[Console, IOException, Either[Unit, Unit]] =\n  Console.printLine("Hello").orElseEither(Console.printLine("ZIO"))\n// helloZIO: ZIO[Console, IOException, Either[Unit, Unit]] = OnSuccessAndFailure(\n//   trace = "repl.MdocSession.MdocApp.helloZIO(commutativeeither.md:15)",\n//   first = Stateful(\n//     trace = "repl.MdocSession.MdocApp.helloZIO(commutativeeither.md:15)",\n//     onState = zio.FiberRef$unsafe$$anon$2$$Lambda$16469/1392082310@4746861d\n//   ),\n//   successK = zio.ZIO$$$Lambda$16455/131458822@28409e99,\n//   failureK = zio.ZIO$$Lambda$16567/2121115595@39be44c5\n// )\n\nval zioHello: ZIO[Console, IOException, Either[Unit, Unit]] =\n  Console.printLine("ZIO").orElseEither(Console.printLine("Hello"))\n// zioHello: ZIO[Console, IOException, Either[Unit, Unit]] = OnSuccessAndFailure(\n//   trace = "repl.MdocSession.MdocApp.zioHello(commutativeeither.md:19)",\n//   first = Stateful(\n//     trace = "repl.MdocSession.MdocApp.zioHello(commutativeeither.md:19)",\n//     onState = zio.FiberRef$unsafe$$anon$2$$Lambda$16469/1392082310@6b2152f8\n//   ),\n//   successK = zio.ZIO$$$Lambda$16455/131458822@28409e99,\n//   failureK = zio.ZIO$$Lambda$16567/2121115595@18a447ef\n// )\n')),(0,i.yg)("p",null,"If the ",(0,i.yg)("inlineCode",{parentName:"p"},"orElseEither")," operator was commutative then these two programs should be the same. But they obviously are not."),(0,i.yg)("p",null,"The first program will print ",(0,i.yg)("inlineCode",{parentName:"p"},"Hello")," to the console on one line but never print ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO"),". Since the left ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," workflow was successful the right ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," workflow will never be run."),(0,i.yg)("p",null,"Similarly the second program will print ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," to the console on one line but will never print ",(0,i.yg)("inlineCode",{parentName:"p"},"Hello"),"."),(0,i.yg)("p",null,"We have to return either of the values but the order can't matter. The ",(0,i.yg)("inlineCode",{parentName:"p"},"raceEither")," operator on ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," does just that."),(0,i.yg)("p",null,"It runs both effects concurrently, returning the first one to complete successfully and safely interrupting the other. With it we can make our example above satisfy the commutative law."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\nval helloZIO: ZIO[Console, IOException, Either[Unit, Unit]] =\n  Console.printLine("Hello").raceEither(Console.printLine("ZIO"))\n// helloZIO: ZIO[Console, IOException, Either[Unit, Unit]] = Stateful(\n//   trace = "repl.MdocSession.MdocApp.<local MdocApp>.helloZIO(commutativeeither.md:33)",\n//   onState = zio.ZIO$$$Lambda$16572/510475751@343cb634\n// )\n\nval zioHello: ZIO[Console, IOException, Either[Unit, Unit]] =\n  Console.printLine("ZIO").raceEither(Console.printLine("Hello"))\n// zioHello: ZIO[Console, IOException, Either[Unit, Unit]] = Stateful(\n//   trace = "repl.MdocSession.MdocApp.<local MdocApp>.zioHello(commutativeeither.md:37)",\n//   onState = zio.ZIO$$$Lambda$16572/510475751@7f6f541a\n// )\n')),(0,i.yg)("p",null,"Now both ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," workflows will begin execution at the same time."),(0,i.yg)("p",null,"For an individual execution of this workflow either ",(0,i.yg)("inlineCode",{parentName:"p"},"Hello")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," may be printed to the console, or possibly both if the loser is not interrupted before it runs. But both the left and right workflows have an equal opportunity to be run and we can say that both ",(0,i.yg)("inlineCode",{parentName:"p"},"helloZIO")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"zioHello")," describe the same program."),(0,i.yg)("p",null,"We can also see this interpretation of ",(0,i.yg)("inlineCode",{parentName:"p"},"orElseEitherPar")," in terms of racing in its implementation for ",(0,i.yg)("inlineCode",{parentName:"p"},"ZStream"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\ndef orElseEitherPar[R, E, A, B](left: => ZStream[R, E, A], right: => ZStream[R, E, B]): ZStream[R, E, Either[A, B]] =\n  left.mergeEither(right)\n")),(0,i.yg)("p",null,"We still run both streams concurrently but now instead of cancelling the loser we just emit elements from either stream whenever they are available. This is commutative because whatever order we merge the streams they will still be evaluated concurrently."),(0,i.yg)("p",null,"The difference in the implementations here reflects the fact that a ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," always succeeds with exactly one value, whereas a ",(0,i.yg)("inlineCode",{parentName:"p"},"ZStream")," can succeed with zero or more values."),(0,i.yg)("p",null,"So in the case of ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," if one fiber completes execution successfully first we have nothing to do with the value from the other and so just interrupt it. In contrast, a ",(0,i.yg)("inlineCode",{parentName:"p"},"ZStream")," can succeed with multiple values so we can just emit the values from either stream as they are available."),(0,i.yg)("p",null,"In many cases the implementation of the ",(0,i.yg)("inlineCode",{parentName:"p"},"orElseEitherPar")," will involve actual concurrency but it does not need to."),(0,i.yg)("p",null,"To see this, consider the following instance of the ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," abstraction for ",(0,i.yg)("inlineCode",{parentName:"p"},"Set"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.prelude._\n\nimplicit val SetCommutativeEither: CommutativeEither[Set] =\n  new CommutativeEither[Set] {\n    def either[A, B](left: => Set[A], right: => Set[B]): Set[Either[A, B]] =\n      left.map(Left(_)) ++ right.map(Right(_))\n  }\n// SetCommutativeEither: CommutativeEither[Set] = repl.MdocSession$MdocApp$$anon$1@1eb87f9d\n")),(0,i.yg)("p",null,"In this case there is no actual concurrency going on but we are combining the left ",(0,i.yg)("inlineCode",{parentName:"p"},"Set")," and right ",(0,i.yg)("inlineCode",{parentName:"p"},"Set"),", wrapping their values in ",(0,i.yg)("inlineCode",{parentName:"p"},"Left")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Right")," respectively."),(0,i.yg)("p",null,"This is like the interpretation of ",(0,i.yg)("inlineCode",{parentName:"p"},"orElseEither")," as concatenating two collections except normally concatenation would not be commutative since order matters. In the case of a ",(0,i.yg)("inlineCode",{parentName:"p"},"Set")," the order of elements doesn't matter."),(0,i.yg)("p",null,"We can think of this as running each ",(0,i.yg)("inlineCode",{parentName:"p"},"Set")," to get its elements until it fails by being empty."),(0,i.yg)("p",null,"As with the other operators for describing ways of combining parameterized types, we can also define ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," instances for data types that are contravariant or invariant. These also often do not require any actual concurrency because the logical parallelism is handled by running either the left value or the right value depending on the input."),(0,i.yg)("p",null,"For example, here is the instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," for the ",(0,i.yg)("inlineCode",{parentName:"p"},"Predicate")," data type."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Predicate[-A] {\n  def run(a: A): Boolean\n}\n\nobject Predicate {\n  implicit val PredicateCommutativeEither: CommutativeEither[Predicate] =\n    new CommutativeEither[Predicate] {\n      def either[A, B](left: => Predicate[A], right: => Predicate[B]): Predicate[Either[A, B]] =\n        new Predicate[Either[A, B]] {\n          def run(either: Either[A, B]): Boolean =\n            either match {\n              case Left(a) => left.run(a)\n              case Right(b) => right.run(b)\n            }\n        }\n    }\n}\n")),(0,i.yg)("p",null,"It is commutative because no matter what order we combine the two predices, we will always send ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," values to the predicate that can handle ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," values and ",(0,i.yg)("inlineCode",{parentName:"p"},"B")," values to the predicate that can handle ",(0,i.yg)("inlineCode",{parentName:"p"},"B")," values. If we did something different with the ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"B")," values other than just sending them to the predicate based on whether they were a ",(0,i.yg)("inlineCode",{parentName:"p"},"Left")," or a ",(0,i.yg)("inlineCode",{parentName:"p"},"Right")," then we would be at risk of violating the laws."),(0,i.yg)("p",null,"When a data type for which a ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," instance is defined is also covariant we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"orElsePar")," operator as well."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"def orElsePar[F[+_]: CommutativeEither : Covariant, A](left: => F[A], right: => F[A]): F[A] =\n  left.orElseEitherPar(right).map(_.merge)\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"orElsePar")," operator just maps over the output of the ",(0,i.yg)("inlineCode",{parentName:"p"},"orElseEitherPar")," operator and merges the ",(0,i.yg)("inlineCode",{parentName:"p"},"Either")," values when both the ",(0,i.yg)("inlineCode",{parentName:"p"},"left")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"right")," values are parameterized on the same types."),(0,i.yg)("p",null,"This is quite useful and typically has more domain specific names. For example this is the ",(0,i.yg)("inlineCode",{parentName:"p"},"race")," operator on ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," and the ",(0,i.yg)("inlineCode",{parentName:"p"},"merge")," operator on ",(0,i.yg)("inlineCode",{parentName:"p"},"ZStream"),". We can think of this as just like ",(0,i.yg)("inlineCode",{parentName:"p"},"orElseEither")," but eliminating the ",(0,i.yg)("inlineCode",{parentName:"p"},"Either")," when the types that the left and right values are parameterized on are the same."),(0,i.yg)("p",null,"There is also an additional operator we can use for contravariant types called ",(0,i.yg)("inlineCode",{parentName:"p"},"eitherWithPar"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"def orElseEitherWithPar[F[-_]: CommutativeEither : Contravariant, A, B, C](\n  left: => F[A],\n  right: => F[B]\n)(f: C => Either[A, B]): F[C] =\n  left.orElseEitherPar(right).contramap(f)\n")),(0,i.yg)("p",null,"This is like the ",(0,i.yg)("inlineCode",{parentName:"p"},"orElseEitherWith")," defined on data types that have an ",(0,i.yg)("inlineCode",{parentName:"p"},"AssociativeEither")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Contravariant")," instance except it guarantees that the ",(0,i.yg)("inlineCode",{parentName:"p"},"F[A]")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"F[B]")," values will be combined in a way that is commutative in addition to being associative."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," functional abstraction, along with the ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeBoth")," abstraction, describe the two fundamental ways of combining values in parallel. We can either run both values and return both their results, as in the ",(0,i.yg)("inlineCode",{parentName:"p"},"zipPar")," operator on ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO"),", or we can run both values and return either of their results, as in the ",(0,i.yg)("inlineCode",{parentName:"p"},"raceEither")," operator on ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO"),"."),(0,i.yg)("p",null,"As with some of the other functional abstractions for parameterized types, ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," tends to be most useful when you are defining your own parameterized types or writing generic code. If you are working with existing data types like ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"ZStream")," the operators described by this abstraction tend to already be available to you with more domain specific names."),(0,i.yg)("p",null,"If you are defining your own data type then exploring whether there is a way to run both values in parallel to produce either result can be a useful exercise."),(0,i.yg)("p",null,"If your data type describes some kind of effect then there is often a very obvious interpretation in terms of concurrency. If not it may require more thought."),(0,i.yg)("p",null,"Defining a ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," instance, if it exists, is a good practice to allow you to use other operators in ZIO Prelude that are defined for data types with ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," instances. It will also allow you to test that your implementation satisfies the expected laws, which can be tricky with some of these more complex types."),(0,i.yg)("p",null,"Finally, if you are writing generic code the ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeBoth")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"CommutativeEither")," abstractions describe the fundamental binary operators for combining values in parallel. So if you want to describe parallel or concurrent operators in a generic way you will definitely want to use these abstractions."))}h.isMDXComponent=!0}}]);