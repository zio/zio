"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[64724],{15680:(e,t,a)=>{a.d(t,{xA:()=>g,yg:()=>d});var n=a(96540);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},g=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,o=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),u=p(a),y=s,d=u["".concat(o,".").concat(y)]||u[y]||m[y]||r;return a?n.createElement(d,i(i({ref:t},g),{},{components:a})):n.createElement(d,i({ref:t},g))}));function d(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,i=new Array(r);i[0]=y;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[u]="string"==typeof e?e:s,i[1]=l;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}y.displayName="MDXCreateElement"},27570:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=a(58168),s=(a(96540),a(15680));const r={id:"smart-assertions",title:"Smart Assertions"},i=void 0,l={unversionedId:"reference/test/assertions/smart-assertions",id:"reference/test/assertions/smart-assertions",title:"Smart Assertions",description:"The smart assertion is a simple way to assert both ordinary values and ZIO effects. It uses the assertTrue function, which uses macro under the hood.",source:"@site/docs/reference/test/assertions/smart-assertions.md",sourceDirName:"reference/test/assertions",slug:"/reference/test/assertions/smart-assertions",permalink:"/reference/test/assertions/smart-assertions",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/assertions/smart-assertions.md",tags:[],version:"current",frontMatter:{id:"smart-assertions",title:"Smart Assertions"},sidebar:"reference-sidebar",previous:{title:"Classic Assertions",permalink:"/reference/test/assertions/classic-assertions"},next:{title:"Built-in Assertions",permalink:"/reference/test/assertions/built-in-assertions"}},o={},p=[{value:"Asserting Ordinary Values",id:"asserting-ordinary-values",level:2},{value:"Asserting ZIO effects",id:"asserting-zio-effects",level:2},{value:"Assertion Operators",id:"assertion-operators",level:2},{value:"Asserting Nested Values",id:"asserting-nested-values",level:2},{value:"Testing Optional Values",id:"testing-optional-values",level:3},{value:"Testing Either Values",id:"testing-either-values",level:3},{value:"Testing Exit Values",id:"testing-exit-values",level:3},{value:"Deeply Nested Values",id:"deeply-nested-values",level:2},{value:"Custom Assertions",id:"custom-assertions",level:2},{value:"More Examples",id:"more-examples",level:2}],g={toc:p},u="wrapper";function m(e){let{components:t,...a}=e;return(0,s.yg)(u,(0,n.A)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smart assertion is a simple way to assert both ",(0,s.yg)("em",{parentName:"p"},"ordinary values")," and ",(0,s.yg)("em",{parentName:"p"},"ZIO effects"),". It uses the ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," function, which uses macro under the hood."),(0,s.yg)("h2",{id:"asserting-ordinary-values"},"Asserting Ordinary Values"),(0,s.yg)("p",null,"In the following example, we assert simple ordinary values using the ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," method:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\n\ntest("sum"){\n  assertTrue(1 + 1 == 2)\n}\n')),(0,s.yg)("p",null,"We can assert multiple assertions inside a single ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue"),":"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'test("multiple assertions"){\n  assertTrue(\n    true,\n    1 + 1 == 2,\n    Some(1 + 1) == Some(2)\n  )\n}\n')),(0,s.yg)("h2",{id:"asserting-zio-effects"},"Asserting ZIO effects"),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," method can also be used to assert ZIO effects:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\n\ntest("updating ref") {\n  for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield assertTrue(v == 1)\n}\n')),(0,s.yg)("p",null,"Using ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," with for-comprehension style, we can think of testing as these three steps:"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"Set up the test")," \u2014 In this section we should setup the system under test (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"Ref.make(0)"),")."),(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"Running the test")," \u2014 Then we run the test scenario according to the test specification. (e.g ",(0,s.yg)("inlineCode",{parentName:"li"},"ref.update(_ + 1)"),")"),(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"Making assertions about the test")," - Finally, we should assert the result with the right expectations (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"assertTrue(v == 1)"),")")),(0,s.yg)("h2",{id:"assertion-operators"},"Assertion Operators"),(0,s.yg)("p",null,"Each ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," returns a ",(0,s.yg)("inlineCode",{parentName:"p"},"AssertResult"),", so they have the same operators as ",(0,s.yg)("inlineCode",{parentName:"p"},"AssertResult"),". Here are some of the useful operators:"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"&&"))," - This is the logical and operator to make sure that both assertions are true:")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("&&") {\n  check(Gen.int <*> Gen.int) { case (x: Int, y: Int) =>\n    assertTrue(x + y == y + x) && assertTrue(x * y == y * x)\n  }\n}\n')),(0,s.yg)("ol",{start:2},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"||")," - This is the logical or operator to make sure that at least one of the assertions is true:")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nsuite("||")(\n  test("false || true") {\n    assertTrue(false) || assertTrue(true) // this will pass\n  },\n  test("true || false") {\n    assertTrue(true) || assertTrue(false) // this will pass\n  },\n  test("true || true") {\n    assertTrue(true) || assertTrue(true) // this will pass\n  },\n  test("false || false") {\n    assertTrue(false) || assertTrue(false) // this will false\n  },\n)\n')),(0,s.yg)("ol",{start:3},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"!"))," - This is the logical not operator to negate the assertion:")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nsuite("unary !") (\n    test("negate true") {\n        !assertTrue(true) // this will fail\n    },\n    test("negate false") {\n        !assertTrue(false) // this will pass\n    }\n)\n')),(0,s.yg)("ol",{start:4},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"implies")," - This is the logical implies operator to make sure that the first assertion implies the second assertion. It is equivalent to ",(0,s.yg)("inlineCode",{parentName:"li"},"!p || q"),' which is a conditional statement of the form "if p, then q" where p and q are propositions. The ',(0,s.yg)("inlineCode",{parentName:"li"},"==>")," operator is an alias for ",(0,s.yg)("inlineCode",{parentName:"li"},"implies"),".")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nsuite("implies") (\n  test("true implies true")(\n    assertTrue(true) implies assertTrue(true) // this will pass\n  ),\n  test("true implies false")(\n    assertTrue(true) implies assertTrue(false) // this will fail\n  ),\n  test("false implies true")(\n    assertTrue(false) implies assertTrue(true) // this will pass\n  ),\n  test("false implies false")(\n    assertTrue(false) implies assertTrue(false) // this will pass\n  ),\n)\n')),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"implies")," assertion is true if either the p is false or when both p and q are true:"),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"P"),(0,s.yg)("th",{parentName:"tr",align:null},"Q"),(0,s.yg)("th",{parentName:"tr",align:null},"P implies Q"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"true"),(0,s.yg)("td",{parentName:"tr",align:null},"true"),(0,s.yg)("td",{parentName:"tr",align:null},"true")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"true"),(0,s.yg)("td",{parentName:"tr",align:null},"false"),(0,s.yg)("td",{parentName:"tr",align:null},"false")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"false"),(0,s.yg)("td",{parentName:"tr",align:null},"true"),(0,s.yg)("td",{parentName:"tr",align:null},"true")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"false"),(0,s.yg)("td",{parentName:"tr",align:null},"false"),(0,s.yg)("td",{parentName:"tr",align:null},"true")))),(0,s.yg)("ol",{start:5},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"iff")," - This is the logical iff operator to make sure that the first assertion is true if and only if the second assertion is true. It is equivalent to ",(0,s.yg)("inlineCode",{parentName:"li"},"(p implies q) && (q implies p)"),". The ",(0,s.yg)("inlineCode",{parentName:"li"},"<==>")," operator is an alias for ",(0,s.yg)("inlineCode",{parentName:"li"},"iff"),".")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nsuite("iff") (\n  test("true iff true")(\n    assertTrue(true) iff assertTrue(true) // this will pass\n  ),\n  test("true iff false")(\n    assertTrue(true) iff assertTrue(false) // this will fail\n  ),\n  test("false iff true")(\n    assertTrue(false) iff assertTrue(true) // this will fail\n  ),\n  test("false iff false")(\n    assertTrue(false) iff assertTrue(false) // this will pass\n  )\n)\n')),(0,s.yg)("p",null,"Here is the truth table for the iff operator:"),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"P"),(0,s.yg)("th",{parentName:"tr",align:null},"Q"),(0,s.yg)("th",{parentName:"tr",align:null},"P iff Q"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"true"),(0,s.yg)("td",{parentName:"tr",align:null},"true"),(0,s.yg)("td",{parentName:"tr",align:null},"true")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"true"),(0,s.yg)("td",{parentName:"tr",align:null},"false"),(0,s.yg)("td",{parentName:"tr",align:null},"false")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"false"),(0,s.yg)("td",{parentName:"tr",align:null},"true"),(0,s.yg)("td",{parentName:"tr",align:null},"false")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"false"),(0,s.yg)("td",{parentName:"tr",align:null},"false"),(0,s.yg)("td",{parentName:"tr",align:null},"true")))),(0,s.yg)("ol",{start:6},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"??"),"- We can add a custom message to the assertion using the ",(0,s.yg)("inlineCode",{parentName:"li"},"??")," operator. This will be useful when assertion fails, and we want to provide more information about the failure:")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nassertTrue(1 + 1 == 3) ?? "1 + 1 should be equal to 2"\n')),(0,s.yg)("h2",{id:"asserting-nested-values"},"Asserting Nested Values"),(0,s.yg)("p",null,"There are several operators designed specifically for use within the ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," macro, enhancing the ease and readability of assertions. These operators, intended exclusively for the ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," macro, leverage the ",(0,s.yg)("inlineCode",{parentName:"p"},"TestLens[A]")," type-class to access the underlying value of the type ",(0,s.yg)("inlineCode",{parentName:"p"},"A"),"."),(0,s.yg)("p",null,"We use the ",(0,s.yg)("inlineCode",{parentName:"p"},"is")," extension method inside the ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," macro to convert the given value to a ",(0,s.yg)("inlineCode",{parentName:"p"},"TestLens"),". Now no matter how deeply nested the value is, we can access the underlying values using extension method defined for ",(0,s.yg)("inlineCode",{parentName:"p"},"TestLens")," values:"),(0,s.yg)("h3",{id:"testing-optional-values"},"Testing Optional Values"),(0,s.yg)("p",null,"There are two operators for testing optional values:"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#some"))," - This operator is used to peek into the ",(0,s.yg)("inlineCode",{parentName:"li"},"Some")," value:")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("optional value is some(42)") {\n  val sut: Option[Int] = Some(40 + 2)\n  assertTrue(sut.is(_.some) == 42)\n}\n')),(0,s.yg)("ol",{start:2},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#anything"))," - This operator is used to assert that the value is ",(0,s.yg)("inlineCode",{parentName:"li"},"Some"),":")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("optional value is anything") {\n  val sut: Option[Int] = Some(42)\n  assertTrue(sut.is(_.anything))\n}\n')),(0,s.yg)("h3",{id:"testing-either-values"},"Testing Either Values"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#left"))," - This operator is used to peek into the ",(0,s.yg)("inlineCode",{parentName:"li"},"Left")," value:")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("TestLens#right") {\n  val sut: Either[Error, Int] = Right(40 + 2)\n  assertTrue(sut.is(_.right) == 42)\n}\n')),(0,s.yg)("ol",{start:2},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#left"))," - This operator is used to peek into the ",(0,s.yg)("inlineCode",{parentName:"li"},"Left")," value:")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ncase class Error(errorMessage: String)\n\ntest("TestLens#left") {\n  val sut: Either[Error, Int] = Left(Error("Boom!"))\n  assertTrue(sut.is(_.left).errorMessage == "Boom!")\n}\n')),(0,s.yg)("ol",{start:3},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#anything"))," - This operator is used to assert that the value is ",(0,s.yg)("inlineCode",{parentName:"li"},"Right"),":")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("TestLens#anything") {\n  val sut: Either[Error, Int] = Right(42)\n  assertTrue(sut.is(_.anything))\n}\n')),(0,s.yg)("h3",{id:"testing-exit-values"},"Testing Exit Values"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#success"))," - This operator transforms the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit")," value to its success type ",(0,s.yg)("inlineCode",{parentName:"li"},"A")," if it is a ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit.Success"),", otherwise it will fail. So this can be used for asserting the success value of the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit"),":")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.Exit\nimport zio.test._\n\ntest("TestLens#success") {\n  val sut: Exit[Error, Int] = Exit.succeed(42)\n  assertTrue(sut.is(_.success) == 42)\n}\n')),(0,s.yg)("ol",{start:2},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#failure"))," - This operator transforms the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit")," value to its failure type ",(0,s.yg)("inlineCode",{parentName:"li"},"E")," if it is a ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit.Failure"),", otherwise it will fail. So this can be used for asserting the failure value of the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit"),":")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.Exit\nimport zio.test._\n\ncase class Error(errorMessage: String)\n\ntest("TestLens#failure") {\n  val sut: Exit[Error, Int] = Exit.fail(Error("Boom!"))\n  assertTrue(sut.is(_.failure).errorMessage == "Boom!")\n}\n')),(0,s.yg)("ol",{start:3},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#die"))," - This operator transforms the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit")," value to its die type ",(0,s.yg)("inlineCode",{parentName:"li"},"E")," if it is a ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit.Die"),", otherwise it will fail. So this can be used for asserting the die value of the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit"),":")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.Exit\nimport zio.test._\n\ntest("TestLens#die") {\n  val sut: Exit[Error, Int] = Exit.die(new RuntimeException("Boom!"))\n  assertTrue(sut.is(_.die).getMessage == "Boom!")\n}\n')),(0,s.yg)("ol",{start:4},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#cause"))," - This operator transforms the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit")," value to its underlying ",(0,s.yg)("inlineCode",{parentName:"li"},"Cause")," value if it has one otherwise it will fail. So this can be used for asserting the cause of the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit"),":")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.{ZIO, Cause}\nimport zio.test._\n\ntest("TestLens#cause") {\n  for {\n    exit <- ZIO.failCause(Cause.fail("Boom!")).exit\n  } yield assertTrue(exit.is(_.cause) == Cause.fail("Boom!"))\n}\n// error: Error is already defined as case class Error\n// case class Error(errorMessage: String)\n//            ^^^^^\n')),(0,s.yg)("ol",{start:5},(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"TestLens#interrupt"))," - This operator transforms the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit")," value to its interrupt value if it is a ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit.Interrupt"),", otherwise it will fail. So this can be used for asserting the interrupt value of the ",(0,s.yg)("inlineCode",{parentName:"li"},"Exit"),":")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.{durationInt, ZIO}\nimport zio.test._\n\ntest("TestLens#interrupt") {\n  for {\n    exit <- ZIO.sleep(5.seconds).fork.flatMap(_.interrupt)\n  } yield assertTrue(exit.is(_.interrupted))\n}\n')),(0,s.yg)("h2",{id:"deeply-nested-values"},"Deeply Nested Values"),(0,s.yg)("p",null,"Sometimes we need to test values with more than one level of nesting. There is no difference in the way we test nested values:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("assertion of multiple nested values (TestLens#right.some)") {\n  val sut: Either[Error, Option[Int]] = Right(Some(40 + 2))\n  assertTrue(sut.is(_.right.some) == 42)\n}\n')),(0,s.yg)("h2",{id:"custom-assertions"},"Custom Assertions"),(0,s.yg)("p",null,"Using ",(0,s.yg)("inlineCode",{parentName:"p"},"CustomAssertion")," we can create our own custom assertions for use in ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue"),". We can define custom assertions using the ",(0,s.yg)("inlineCode",{parentName:"p"},"CustomAssertion.make")," method. This method takes a partial function from the type ",(0,s.yg)("inlineCode",{parentName:"p"},"A")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"Either[String, B]"),". If the partial function is defined for the given value, it returns ",(0,s.yg)("inlineCode",{parentName:"p"},"Right[B]"),", otherwise it returns ",(0,s.yg)("inlineCode",{parentName:"p"},"Left[String]"),". "),(0,s.yg)("p",null,"Here is an example of a custom assertion for a sealed trait and case classes:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\n// Define the sealed trait and case classes\nsealed trait Book\ncase class Novel(pageCount: Int) extends Book\ncase class Comic(illustrations: Int) extends Book\ncase class Textbook(subject: String) extends Book\n\n// Custom assertion for Book\nval subject =\n  CustomAssertion.make[Book] {\n    case Textbook(subject) => Right(subject)\n    case other => Left(s"Expected $$other to be Textbook")\n  }\n\n// Usage\nsuite("custom assertions")(\n  test("subject assertion") {\n    val book: Option[Book] = Some(Textbook("Mathematics"))\n    assertTrue(book.is(_.some.custom(subject)) == "Mathematics")\n  }\n)\n')),(0,s.yg)("p",null,"In the above example, we define a custom assertion for the ",(0,s.yg)("inlineCode",{parentName:"p"},"Book")," sealed trait. The custom assertion ",(0,s.yg)("inlineCode",{parentName:"p"},"subject")," is defined to extract the ",(0,s.yg)("inlineCode",{parentName:"p"},"subject")," from the ",(0,s.yg)("inlineCode",{parentName:"p"},"Textbook")," case class. So then we can assert the ",(0,s.yg)("inlineCode",{parentName:"p"},"subject")," of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Textbook")," case class."),(0,s.yg)("h2",{id:"more-examples"},"More Examples"),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," macro is designed to make it easy to write assertions in a more readable way. Most test cases can be written as when we're comparing ordinary values in Scala. However, we have a ",(0,s.yg)("a",{parentName:"p",href:"https://github.com/zio/zio/blob/series/2.x/test-tests/shared/src/test/scala/zio/test/SmartAssertionSpec.scala"},(0,s.yg)("inlineCode",{parentName:"a"},"SmartAssertionSpec"))," which is a collection of examples to demonstrate the power of the ",(0,s.yg)("inlineCode",{parentName:"p"},"assertTrue")," macro."))}m.isMDXComponent=!0}}]);