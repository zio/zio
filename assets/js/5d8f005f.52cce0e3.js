"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[35919],{15680:(e,n,a)=>{a.d(n,{xA:()=>d,yg:()=>m});var t=a(96540);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function p(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=t.createContext({}),s=function(e){var n=t.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},d=function(e){var n=s(e.components);return t.createElement(l.Provider,{value:n},e.children)},c="mdxType",y={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),c=s(a),u=r,m=c["".concat(l,".").concat(u)]||c[u]||y[u]||i;return a?t.createElement(m,o(o({ref:n},d),{},{components:a})):t.createElement(m,o({ref:n},d))}));function m(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p[c]="string"==typeof e?e:r,o[1]=p;for(var s=2;s<i;s++)o[s]=a[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},45544:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>y,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var t=a(58168),r=(a(96540),a(15680));const i={id:"covariant",title:"Covariant"},o=void 0,p={unversionedId:"zio-prelude/functional-abstractions/parameterized-types/covariant",id:"zio-prelude/functional-abstractions/parameterized-types/covariant",title:"Covariant",description:"Covariant[F] describes a parameterized type F[A] that potentially produces but never consumes A values.",source:"@site/docs/zio-prelude/functional-abstractions/parameterized-types/covariant.md",sourceDirName:"zio-prelude/functional-abstractions/parameterized-types",slug:"/zio-prelude/functional-abstractions/parameterized-types/covariant",permalink:"/zio-prelude/functional-abstractions/parameterized-types/covariant",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/covariant.md",tags:[],version:"current",frontMatter:{id:"covariant",title:"Covariant"},sidebar:"ecosystem-sidebar",previous:{title:"Contravariant",permalink:"/zio-prelude/functional-abstractions/parameterized-types/contravariant"},next:{title:"ForEach",permalink:"/zio-prelude/functional-abstractions/parameterized-types/foreach"}},l={},s=[],d={toc:s},c="wrapper";function y(e){let{components:n,...a}=e;return(0,r.yg)(c,(0,t.A)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"Covariant[F]")," describes a parameterized type ",(0,r.yg)("inlineCode",{parentName:"p"},"F[A]")," that potentially produces but never consumes ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," values."),(0,r.yg)("p",null,"Its signature is:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"trait Invariant[F[_]] {\n  def invmap[A, B](f: A <=> B): F[A] <=> F[B]\n}\n\ntrait Covariant[F[+_]] extends Invariant[F] {\n  def map[A, B](f: A => B): F[A] => F[B]\n  final def invmap[A, B](f: A <=> B): F[A] <=> F[B] =\n    Equivalence(map(f.to), map(f.from))\n}\n\ntype <=>[A, B] = Equivalence[A, B]\n\ncase class Equivalence[A, B](to: A => B, from: B => A)\n")),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"map"),' operator says we can "lift" a function ',(0,r.yg)("inlineCode",{parentName:"p"},"A => B")," to a function ",(0,r.yg)("inlineCode",{parentName:"p"},"F[A] => F[B]"),". If we import ",(0,r.yg)("inlineCode",{parentName:"p"},"zio.prelude._")," we can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"map")," operator to transform an ",(0,r.yg)("inlineCode",{parentName:"p"},"F[A]")," into an ",(0,r.yg)("inlineCode",{parentName:"p"},"F[B]")," with a function ",(0,r.yg)("inlineCode",{parentName:"p"},"A => B"),"."),(0,r.yg)("p",null,"The law is that the lifting of this function can transform ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," values into ",(0,r.yg)("inlineCode",{parentName:"p"},"B")," values but cannot otherwise change the structure of ",(0,r.yg)("inlineCode",{parentName:"p"},"F"),", so using ",(0,r.yg)("inlineCode",{parentName:"p"},"map")," with the identity function is an identity and separately using ",(0,r.yg)("inlineCode",{parentName:"p"},"map")," with two functions is the same as doing it with the composition of those functions."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"fa.map(identity) === fa\nfa.map(f).map(g) === fa.map(f.andThen(g))\n")),(0,r.yg)("p",null,"Data types that are covariant may either contain zero or more existing ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," values, such as a ",(0,r.yg)("inlineCode",{parentName:"p"},"Chunk"),", or potentially produce zero or more ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," values at some point in the future, such as a ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO"),"."),(0,r.yg)("p",null,"In the definition of ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," above you may notice that a ",(0,r.yg)("inlineCode",{parentName:"p"},"+")," appears before the ",(0,r.yg)("inlineCode",{parentName:"p"},"_"),". This tells the Scala compiler that the parameterized type is covariant with respect to this type parameter."),(0,r.yg)("p",null,"This improves type inference because it allows the Scala compiler to automatically widen an ",(0,r.yg)("inlineCode",{parentName:"p"},"F[A]")," to an ",(0,r.yg)("inlineCode",{parentName:"p"},"F[B]")," if ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," is a subtype of ",(0,r.yg)("inlineCode",{parentName:"p"},"B")," because a data type that outputs ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," values also outputs ",(0,r.yg)("inlineCode",{parentName:"p"},"B")," values by definition. It also allows the Scala compiler to check for us that types for which we define a ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," instance really are covariant with respect to their type parameters."),(0,r.yg)("p",null,"Other functional programming libraries do not take advantage of Scala's support for variance here and so have to resort to a ",(0,r.yg)("inlineCode",{parentName:"p"},"widen")," operator that essentially amounts to mapping with the identity function."),(0,r.yg)("p",null,"Often data types that appear to be invariant are actually versions of more polymorphic data types that are covariant with respect to one or more of their type parameters. Generalizing these data types can lead to improved API design and allow defining additional operators."),(0,r.yg)("p",null,"Let's see these ideas in action with the ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonCodec")," data type."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"trait JsonCodec[A] {\n  def decode(json: String): Either[String, A]\n  def encode(a: A): String\n}\n")),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonCodec")," data type is naturally invariant in the ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," type parameter because ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," appears as both an input to ",(0,r.yg)("inlineCode",{parentName:"p"},"encode")," and an output from ",(0,r.yg)("inlineCode",{parentName:"p"},"decode"),". As a result, the ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," type parameter appears in the definition of ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonCodec")," without a ",(0,r.yg)("inlineCode",{parentName:"p"},"+")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"-"),"."),(0,r.yg)("p",null,"Let's try adding a ",(0,r.yg)("inlineCode",{parentName:"p"},"+")," before the ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," type parameter to indicate that ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonCodec")," is covariant with respect to this type parameter."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"trait JsonCodec[+A] {\n  def decode(json: String): Either[String, A]\n  def encode(a: A): String\n}\n// error: covariant type A occurs in contravariant position in type A of value a\n//   def encode(a: A): String\n//              ^^^^\n")),(0,r.yg)("p",null,"This code does not compile!"),(0,r.yg)("p",null,"The Scala compiler helpfully informs us that the covariant type ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," appears in contravariant position in the ",(0,r.yg)("inlineCode",{parentName:"p"},"encode")," operator. Translating slightly, the Scala compiler is telling us that we are not honoring the guarantee of ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," being covariant that ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," is an output but never an input because ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," appears as an input to ",(0,r.yg)("inlineCode",{parentName:"p"},"encode"),"."),(0,r.yg)("p",null,"Whenever we have to make a type invariant because ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," is both an input and an output we should ask ourselves whether it is possible to split that up. We can do that either by using different type parameters for the input and output or by refactoring to create separate interfaces where ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," only appears as an input or output."),(0,r.yg)("p",null,"Here we will take the second approach and split the ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonCodec")," up into a ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," and a ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonEncoder"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"trait JsonDecoder[+A] {\n  def decode(json: String): Either[String, A]\n}\n\ntrait JsonEncoder[-A] {\n  def encode(a: A): String\n}\n\ntrait JsonCodec[A] extends JsonDecoder[A] with JsonEncoder[A]\n")),(0,r.yg)("p",null,"Now ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," only appears as an output of the ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonEncoder")," and only appears as an input of ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," and we can make ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," covariant by using the ",(0,r.yg)("inlineCode",{parentName:"p"},"+")," before the type parameter. We can also make ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonEncoder")," contravariant, but we will defer discussion of that to the section on the ",(0,r.yg)("inlineCode",{parentName:"p"},"Contravariant")," functional abstraction."),(0,r.yg)("p",null,"With the ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonEncoder")," separated out, we can now define a ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," instance for the ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonDecoder"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"trait JsonDecoder[+A] { self =>\n  def decode(json: String): Either[String, A]\n  def map[B](f: A => B): JsonDecoder[B] =\n    new JsonDecoder[B] {\n      def decode(json: String): Either[String, B] =\n        self.decode(json).map(f)\n    }\n}\n\nobject JsonDecoder {\n  implicit val JsonDecoderCovariant: Covariant[JsonDecoder] =\n    new Covariant[JsonDecoder] {\n      def map[A, B](f: A => B): JsonDecoder[A] => JsonDecoder[B] =\n        jsonDecoder => jsonDecoder.map(f)\n    }\n}\n")),(0,r.yg)("p",null,"In addition to being able to define a ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," instance, we have improved our API design by recognizing that our definition of ",(0,r.yg)("inlineCode",{parentName:"p"},"JsonCodec")," was actually combining two things that are conceptually distinct. Now users can work with just a ",(0,r.yg)("inlineCode",{parentName:"p"},"Decoder")," if all they are doing is reading data and it is easier to transform a decoder because we only need to provide a function and not an equivalence relationship."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"map")," operator is extremely useful and you are probably familiar with it from a variety of data types in the Scala standard library and ZIO. However, the ",(0,r.yg)("inlineCode",{parentName:"p"},"map")," operator is already defined directly on most data types that support it."),(0,r.yg)("p",null,"As a result, the ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," abstraction tends to be useful in two ways."),(0,r.yg)("p",null,"First, defining a ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," instance for your own data type allows it to work with other operators in ZIO Prelude that require a data type to be covariant."),(0,r.yg)("p",null,"There are only a few operators that are defined for a data type that only has a ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," instance but there are many more that we will learn about later that require a ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," instance as well as some other instance. So defining an instance of ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant"),", as well as whatever other functional abstractions are defined for your date type, is a good practice so that you can use any of these operators for your data type if you need to."),(0,r.yg)("p",null,"Second, ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," can be useful if you are writing your own generic code since many generic operators you may want to define will require a ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," instance. In particular, having a ",(0,r.yg)("inlineCode",{parentName:"p"},"Covariant")," instance as well as an instance of one of the abstractions that describe ways to combine parameterized types allow many interesting operators to be defined."))}y.isMDXComponent=!0}}]);