"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[4494],{15680:(e,n,a)=>{a.d(n,{xA:()=>p,yg:()=>m});var o=a(96540);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,o)}return a}function s(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,o,t=function(e,n){if(null==e)return{};var a,o,t={},r=Object.keys(e);for(o=0;o<r.length;o++)a=r[o],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)a=r[o],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var l=o.createContext({}),c=function(e){var n=o.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):s(s({},n),e)),a},p=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var a=e.components,t=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(a),u=t,m=d["".concat(l,".").concat(u)]||d[u]||g[u]||r;return a?o.createElement(m,s(s({ref:n},p),{},{components:a})):o.createElement(m,s({ref:n},p))}));function m(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var r=a.length,s=new Array(r);s[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[d]="string"==typeof e?e:t,s[1]=i;for(var c=2;c<r;c++)s[c]=a[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,a)}u.displayName="MDXCreateElement"},43923:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>g,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var o=a(58168),t=(a(96540),a(15680));const r={id:"decoding",title:"Decoding"},s=void 0,i={unversionedId:"zio-json/decoding",id:"zio-json/decoding",title:"Decoding",description:"Automatic Derivation",source:"@site/docs/zio-json/decoding.md",sourceDirName:"zio-json",slug:"/zio-json/decoding",permalink:"/zio-json/decoding",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-json/decoding.md",tags:[],version:"current",frontMatter:{id:"decoding",title:"Decoding"},sidebar:"ecosystem-sidebar",previous:{title:"Getting Started",permalink:"/zio-json/"},next:{title:"Encoding",permalink:"/zio-json/encoding"}},l={},c=[{value:"Automatic Derivation",id:"automatic-derivation",level:2},{value:"Automatic Derivation and case class default field values",id:"automatic-derivation-and-case-class-default-field-values",level:3},{value:"ADTs",id:"adts",level:2},{value:"Manual instances",id:"manual-instances",level:2},{value:"<code>.map</code>",id:"map",level:3},{value:"<code>.mapOrFail</code>",id:"maporfail",level:3},{value:"Approach 1: use annotation hints",id:"approach-1-use-annotation-hints",level:2},{value:"Approach 2: use an intermediate case class",id:"approach-2-use-an-intermediate-case-class",level:2},{value:"Approach 3: decode to JSON",id:"approach-3-decode-to-json",level:2},{value:"Approach 4: decode to JSON, use cursors",id:"approach-4-decode-to-json-use-cursors",level:2},{value:"JSON AST",id:"json-ast",level:2},{value:"Cursors",id:"cursors",level:2}],p={toc:c},d="wrapper";function g(e){let{components:n,...a}=e;return(0,t.yg)(d,(0,o.A)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("h2",{id:"automatic-derivation"},"Automatic Derivation"),(0,t.yg)("p",null,"Say we want to be able to read some JSON like"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-json"},'{ "curvature": 0.5 }\n')),(0,t.yg)("p",null,"into a Scala ",(0,t.yg)("inlineCode",{parentName:"p"},"case class")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"case class Banana(curvature: Double)\n")),(0,t.yg)("p",null,"To do this, we create an ",(0,t.yg)("em",{parentName:"p"},"instance")," of the ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," typeclass for ",(0,t.yg)("inlineCode",{parentName:"p"},"Banana")," using the ",(0,t.yg)("inlineCode",{parentName:"p"},"zio-json")," code generator. It is best practice to put it on the companion of ",(0,t.yg)("inlineCode",{parentName:"p"},"Banana"),", like so"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.json._\n\nobject Banana {\n  implicit val decoder: JsonDecoder[Banana] =\n    DeriveJsonDecoder.gen[Banana]\n}\n")),(0,t.yg)("p",null,"Now we can parse JSON into our object"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'"""{ "curvature": 0.5 }""".fromJson[Banana]\n// res0: Either[String, Banana] = Right(value = Banana(curvature = 0.5))\n')),(0,t.yg)("h3",{id:"automatic-derivation-and-case-class-default-field-values"},"Automatic Derivation and case class default field values"),(0,t.yg)("p",null,"If a case class field is defined with a default value and the field is not present or ",(0,t.yg)("inlineCode",{parentName:"p"},"null"),", the default value will be used."),(0,t.yg)("p",null,"Say we have a Scala ",(0,t.yg)("inlineCode",{parentName:"p"},"case class")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'case class Entity(id: Long, description: String = "", related: Seq[Entity] = Seq())\n\nimplicit val decoder: JsonDecoder[Entity] =\n  DeriveJsonDecoder.gen[Entity]\n// decoder: JsonDecoder[Entity] = zio.json.DeriveJsonDecoder$$anon$2@27ca4a14\n')),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'"""{ "id": 42, "related": null }""".fromJson[Entity]\n// res1: Either[String, Entity] = Right(\n//   value = Entity(id = 42L, description = "", related = List())\n// )\n')),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Note: If you\u2019re using Scala 3 and your case class is defining default parameters, ",(0,t.yg)("inlineCode",{parentName:"em"},"-Yretain-trees")," needs to be added to ",(0,t.yg)("inlineCode",{parentName:"em"},"scalacOptions"),".")),(0,t.yg)("h2",{id:"adts"},"ADTs"),(0,t.yg)("p",null,"Say we extend our data model to include more data types"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait Fruit\n\ncase class Banana(curvature: Double) extends Fruit\ncase class Apple (poison: Boolean)   extends Fruit\n")),(0,t.yg)("p",null,"we can generate the decoder for the entire ",(0,t.yg)("inlineCode",{parentName:"p"},"sealed")," family:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.json._\n\nobject Fruit {\n  implicit val decoder: JsonDecoder[Fruit] =\n    DeriveJsonDecoder.gen[Fruit]\n}\n")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'"""{ "Banana":{ "curvature":0.5 }}""".fromJson[Fruit]\n// res3: Either[String, Fruit] = Right(value = Banana(curvature = 0.5))\n')),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'"""{ "Apple": { "poison": false }}""".fromJson[Fruit]\n// res4: Either[String, Fruit] = Right(value = Apple(poison = false))\n')),(0,t.yg)("p",null,"Almost all of the standard library data types are supported as fields on the case class, and it is easy to add support if one is missing."),(0,t.yg)("h2",{id:"manual-instances"},"Manual instances"),(0,t.yg)("p",null,"Sometimes it is easier to reuse an existing ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," rather than generate a new one. This can be accomplished using convenience methods on the ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," typeclass to ",(0,t.yg)("em",{parentName:"p"},"derive")," new decoders"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"trait JsonDecoder[A] {\n  def map[B](f: A => B): JsonDecoder[B]\n  def mapOrFail[B](f: A => Either[String, B]): JsonDecoder[B]\n  ...\n}\n")),(0,t.yg)("h3",{id:"map"},(0,t.yg)("inlineCode",{parentName:"h3"},".map")),(0,t.yg)("p",null,"We can ",(0,t.yg)("inlineCode",{parentName:"p"},".map")," from another ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," in cases where the conversion will always succeed. This is very useful if we have a ",(0,t.yg)("inlineCode",{parentName:"p"},"case class")," that simply wraps another thing and shares the same expected JSON."),(0,t.yg)("p",null,"For example, say we want to model the count of fruit with a ",(0,t.yg)("inlineCode",{parentName:"p"},"case class")," to provide us with additional type safety in our business logic (this pattern is known as a ",(0,t.yg)("em",{parentName:"p"},"newtype"),")."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"case class FruitCount(value: Int)\n")),(0,t.yg)("p",null,"but this would cause us to expect JSON of the form"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-json"},'{"value": 1}\n')),(0,t.yg)("p",null,"wheres we really expect the raw number. We can derive a decoder from ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder[Int]")," and ",(0,t.yg)("inlineCode",{parentName:"p"},".map")," the result into a ",(0,t.yg)("inlineCode",{parentName:"p"},"FruitCount")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"object FruitCount {\n  implicit val decoder: JsonDecoder[FruitCount] =\n    JsonDecoder[Int].map(FruitCount(_))\n}\n")),(0,t.yg)("p",null,"and now the ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," for ",(0,t.yg)("inlineCode",{parentName:"p"},"FruitCount")," just expects a raw ",(0,t.yg)("inlineCode",{parentName:"p"},"Int"),"."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'"""3""".fromJson[FruitCount]\n// res5: Either[String, FruitCount] = Right(value = FruitCount(value = 3))\n')),(0,t.yg)("p",null,"Another use case is if we want to encode a ",(0,t.yg)("inlineCode",{parentName:"p"},"case class")," as an array of values, rather than an object with named fields. Such an encoding is very efficient because the messages are smaller and require less processing, but are very strict schemas that cannot be upgraded."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala:mdoc:reset"},'import zio.json._\n\ncase class Things(s: String, i: Int, b: Boolean)\n\nobject Things {\n  implicit val decoder: JsonDecoder[Things] =\n    JsonDecoder[(String, Int, Boolean)].map { case (p1, p2, p3) => Things(p1, p2, p3) }\n}\n\n"""[ "hello", 1, true ]""".fromJson[Things]\n')),(0,t.yg)("h3",{id:"maporfail"},(0,t.yg)("inlineCode",{parentName:"h3"},".mapOrFail")),(0,t.yg)("p",null,"We can use ",(0,t.yg)("inlineCode",{parentName:"p"},".mapOrFail")," to take the result of another ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder")," and try to convert it into our custom data type, failing with a message if there is an error."),(0,t.yg)("p",null,"Say we are using the ",(0,t.yg)("a",{parentName:"p",href:"https://github.com/fthomas/refined"},(0,t.yg)("inlineCode",{parentName:"a"},"refined"))," library to ensure that a ",(0,t.yg)("inlineCode",{parentName:"p"},"Person")," data type only holds a non-empty string in its ",(0,t.yg)("inlineCode",{parentName:"p"},"name")," field"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import eu.timepit.refined.api.Refined\nimport eu.timepit.refined.collection.NonEmpty\n\ncase class Person(name: String Refined NonEmpty)\n")),(0,t.yg)("p",null,"we will get a compile time error because there is no ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder[String Refined NonEmpty]"),"."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"object Person {\n  implicit val decoder: JsonDecoder[Person] = DeriveJsonDecoder.gen\n}\n// error: magnolia: could not find JsonDecoder.Typeclass for type eu.timepit.refined.api.Refined[String,eu.timepit.refined.collection.NonEmpty]\n//     in parameter 'name' of product type MdocApp0.this.Person\n// \n//   implicit val decoder: JsonDecoder[Person] = DeriveJsonDecoder.gen\n//                                               ^^^^^^^^^^^^^^^^^^^^^\n")),(0,t.yg)("p",null,"However, we can derive one by requesting the ",(0,t.yg)("inlineCode",{parentName:"p"},"JsonDecoder[String]")," and calling ",(0,t.yg)("inlineCode",{parentName:"p"},".mapOrFail"),", supplying the constructor for our special ",(0,t.yg)("inlineCode",{parentName:"p"},"String Refined NonEmpty")," type"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import eu.timepit.refined\n\nimplicit val decodeName: JsonDecoder[String Refined NonEmpty] =\n  JsonDecoder[String].mapOrFail(refined.refineV[NonEmpty](_))\n// decodeName: JsonDecoder[Refined[String, NonEmpty]] = zio.json.JsonDecoder$$anon$3@6abb6da6\n")),(0,t.yg)("p",null,"Now the code compiles."),(0,t.yg)("h1",{id:"parsing-custom-json"},"Parsing custom JSON"),(0,t.yg)("p",null,"In this section we show several approaches for decoding JSON that looks like:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "01. symbol": "IBM",\n  "02. open": "182.4300",\n  "03. high": "182.8000"\n}\n')),(0,t.yg)("p",null,"Which we want to decode into the following case class:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"final case class Quote(\n  symbol: String,\n  open: String,\n  high: String\n)\n")),(0,t.yg)("p",null,"All approaches have the same result:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'"""{"01. symbol":"IBM","02. open": "182.4300","03. high": "182.8000"}""".fromJson[Quote]\n// >> Right(Quote(IBM,182.4300,182.8000))\n// error: diverging implicit expansion for type zio.json.JsonDecoder[MdocApp0.this.Quote]\n// starting with method fromCodec in trait EncoderLowPriority4\n// """{"01. symbol":"IBM","02. open": "182.4300","03. high": "182.8000"}""".fromJson[Quote]\n//                                                                                  ^\n')),(0,t.yg)("h2",{id:"approach-1-use-annotation-hints"},"Approach 1: use annotation hints"),(0,t.yg)("p",null,"In this approach we enrich the case class with annotations to tell the derived decoder which field names to use.\nObviously, this approach only works if we can/want to change the case class."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.json._\n\nfinal case class Quote(\n  @jsonField("01. symbol") symbol: String,\n  @jsonField("02. open") open: String,\n  @jsonField("03. high") high: String\n)\n\nobject Quote {\n  implicit val decoder: JsonDecoder[Quote] = DeriveJsonDecoder.gen[Quote]\n}\n')),(0,t.yg)("h2",{id:"approach-2-use-an-intermediate-case-class"},"Approach 2: use an intermediate case class"),(0,t.yg)("p",null,"Instead of hints, we can also put the actual field names in an intermediate case class. In our example the field names\nare not valid scala identifiers. We fix this by putting the names in backticks:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.json._\n\nfinal case class Quote(symbol: String, open: String, high: String)\n\nobject Quote {\n  private final case class JsonQuote(\n    `01. symbol`: String,\n    `02. open`: String,\n    `03. high`: String\n  )\n\n  implicit val decoder: JsonDecoder[Quote] =\n    DeriveJsonDecoder\n      .gen[JsonQuote]\n      .map { case JsonQuote(s, o, h) => Quote(s, o, h) }\n}\n")),(0,t.yg)("h2",{id:"approach-3-decode-to-json"},"Approach 3: decode to JSON"),(0,t.yg)("p",null,"In this approach we first decode to the generic ",(0,t.yg)("inlineCode",{parentName:"p"},"Json")," data structure. This approach is very flexible because it can\nextract data from any valid JSON."),(0,t.yg)("p",null,"Note that this implementation is a bit sloppy. It uses ",(0,t.yg)("inlineCode",{parentName:"p"},"toString")," on a JSON node. The node is not necessarily a\nString, it can be of any JSON type! So this might happily process JSON that doesn't match your expectations."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.json._\nimport zio.json.ast.Json\n\nfinal case class Quote(symbol: String, open: String, high: String)\n\nobject Quote {\n  implicit val decoder: JsonDecoder[Quote] = JsonDecoder[Json]\n    .mapOrFail {\n      case Json.Obj(fields) =>\n        def findField(name: String): Either[String, String] =\n          fields\n            .find(_._1 == name)\n            .map(_._2.toString())  // \u26a0\ufe0f .toString on any JSON type\n            .toRight(left = s"Field \'$name\' is missing")\n  \n        for {\n          symbol <- findField("01. symbol")\n          open <- findField("02. open")\n          high <- findField("03. high")\n        } yield Quote(symbol, open, high)\n      case _ =>\n        Left("Not a JSON record")\n    }\n}\n')),(0,t.yg)("h2",{id:"approach-4-decode-to-json-use-cursors"},"Approach 4: decode to JSON, use cursors"),(0,t.yg)("p",null,"Here we also first decode to ",(0,t.yg)("inlineCode",{parentName:"p"},"Json"),", but now we use cursors to find the data we need. Here we do check that the fields\nare actually strings."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.json._\nimport zio.json.ast.{Json, JsonCursor}\n\nfinal case class Quote(symbol: String, open: String, high: String)\n\nobject Quote {\n  private val symbolC = JsonCursor.field("01. symbol") >>> JsonCursor.isString\n  private val openC = JsonCursor.field("02. open") >>> JsonCursor.isString\n  private val highC = JsonCursor.field("03. high") >>> JsonCursor.isString\n\n  implicit val decoder: JsonDecoder[Quote] = JsonDecoder[Json]\n    .mapOrFail { c =>\n      for {\n        symbol <- c.get(symbolC)\n        open <- c.get(openC)\n        high <- c.get(highC)\n      } yield Quote(symbol.value, open.value, high.value)\n  }\n}\n')),(0,t.yg)("h1",{id:"more-custom-decoder-examples"},"More custom decoder examples"),(0,t.yg)("p",null,"Let's consider an ",(0,t.yg)("inlineCode",{parentName:"p"},"Animal")," case class with a ",(0,t.yg)("inlineCode",{parentName:"p"},"categories")," field that should be a list of strings. However, some\nproducers accidentally represent the categories as a comma-separated string instead of a proper list. We want to parse\nboth cases."),(0,t.yg)("p",null,"Here's a custom decode for our Animal case class:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.Chunk\nimport zio.json._\nimport zio.json.ast._\n\ncase class Animal(name: String, categories: List[String])\n\nobject Animal {\n  private val nameC = JsonCursor.field("name") >>> JsonCursor.isString\n  private val categoryArrayC = JsonCursor.field("categories") >>> JsonCursor.isArray\n  private val categoryStringC = JsonCursor.field("categories") >>> JsonCursor.isString\n\n  implicit val decoder: JsonDecoder[Animal] = JsonDecoder[Json]\n    .mapOrFail { c =>\n      for {\n        name <- c.get(nameC).map(_.value)\n        categories <- arrayCategory(c).map(_.toList)\n          .orElse(c.get(categoryStringC).map(_.value.split(\',\').map(_.trim).toList))\n      } yield Animal(name, categories)\n    }\n\n  private def arrayCategory(c: Json): Either[String, Chunk[String]] =\n    c.get(categoryArrayC)\n      .flatMap { arr =>\n        // Get the string elements, and sequence the obtained eithers to a single either\n        sequence(arr.elements.map(_.get(JsonCursor.isString).map(_.value)))\n      }\n\n  private def sequence[A, B](chunk: Chunk[Either[A, B]]): Either[A, Chunk[B]] =\n    chunk.partition(_.isLeft) match {\n      case (Nil, rights) => Right(rights.collect { case Right(r) => r })\n      case (lefts, _) => Left(lefts.collect { case Left(l) => l }.head)\n    }\n}\n')),(0,t.yg)("p",null,"And now, the Json decoder for Animal can handle both formats:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'"""{"name": "Dog", "categories": "Warm-blooded, Mammal"}""".fromJson[Animal]\n// res13: Either[String, Animal] = Right(\n//   value = Animal(name = "Dog", categories = List("Warm-blooded", "Mammal"))\n// )\n// >> Right(Animal(Dog,List(Warm-blooded, Mammal)))\n"""{"name": "Snake", "categories": [ "Cold-blooded", "Reptile"]}""".fromJson[Animal]\n// res14: Either[String, Animal] = Right(\n//   value = Animal(name = "Snake", categories = List("Cold-blooded", "Reptile"))\n// )\n// >>  Right(Animal(Snake,List(Cold-blooded, Reptile)))\n')),(0,t.yg)("h1",{id:"json-ast-and-cursors"},"JSON AST and Cursors"),(0,t.yg)("p",null,"In most cases it is not necessary to work with the JSON AST directly,\ninstead it is more convenient to decode directly to domain objects.\nHowever, sometimes it is handy to work with a lower level representation of JSON.\nThis may for example be the case when you need to work with deeply nested JSON structures\nthat would result in deeply nested case classes,\nor when you expect a lot of variation in the JSON structure, which would result in nasty decoders."),(0,t.yg)("h2",{id:"json-ast"},"JSON AST"),(0,t.yg)("p",null,"To get the AST representation of a JSON string, use the ",(0,t.yg)("inlineCode",{parentName:"p"},"fromJson[Json]")," method."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.json._\nimport zio.json.ast._\n\nval jsonString: String            = """{"name": "John Doe"}"""\n// jsonString: String = "{\\"name\\": \\"John Doe\\"}"\nval jsonAst: Either[String, Json] = jsonString.fromJson[Json]\n// jsonAst: Either[String, Json] = Right(\n//   value = Obj(fields = IndexedSeq(("name", Str(value = "John Doe"))))\n// )\n')),(0,t.yg)("p",null,"The ",(0,t.yg)("inlineCode",{parentName:"p"},"Json")," type is a recursive data structure that can be navigated in a fairly straightforward way."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.Chunk\nimport zio.json._\nimport zio.json.ast.Json\nimport zio.json.ast.Json._\n\nval jsonString: String = """{"name": "John Doe"}"""\n// jsonString: String = "{\\"name\\": \\"John Doe\\"}"\nval jsonAst: Json      = jsonString.fromJson[Json].toOption.get\n// jsonAst: Json = Obj(fields = IndexedSeq(("name", Str(value = "John Doe"))))\njsonAst match {\n  case Obj(fields: Chunk[(String, Json)]) => ()\n  case Arr(elements: Chunk[Json])         => ()\n  case Bool(value: Boolean)               => ()\n  case Str(value: String)                 => ()\n  case Num(value: java.math.BigDecimal)   => ()\n  case Json.Null                          => ()\n}\n')),(0,t.yg)("p",null,"To get the ",(0,t.yg)("inlineCode",{parentName:"p"},"name")," field, you could do the following:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.json._\nimport zio.json.ast.Json\n\nval json: Option[Json] = """{"name": "John Doe"}""".fromJson[Json].toOption\n// json: Option[Json] = Some(\n//   value = Obj(fields = IndexedSeq(("name", Str(value = "John Doe"))))\n// )\nval name: Option[String] = json.flatMap { json =>\n  json match {\n    case Json.Obj(fields) => fields.collectFirst { case ("name", Json.Str(name)) => name }\n    case _                => None\n  }\n}\n// name: Option[String] = Some(value = "John Doe")\n')),(0,t.yg)("h2",{id:"cursors"},"Cursors"),(0,t.yg)("p",null,"In practice, it is normally more convenient to use cursors to navigate the JSON AST."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.json._\nimport zio.json.ast.Json\nimport zio.json.ast.JsonCursor\nimport zio.json.ast.Json.Str\n\nval json: Either[String, Json]    = """{"name": "John Doe"}""".fromJson[Json]\n// json: Either[String, Json] = Right(\n//   value = Obj(fields = IndexedSeq(("name", Str(value = "John Doe"))))\n// )\nval cursor: JsonCursor[Json, Str] = JsonCursor.field("name").isString\n// cursor: JsonCursor[Json, Str] = FilterType(\n//   parent = DownField(\n//     parent = FilterType(parent = Identity, jsonType = Obj),\n//     name = "name"\n//   ),\n//   jsonType = Str\n// )\nval name: Either[String, String]  = json.flatMap(_.get(cursor).map(_.value))\n// name: Either[String, String] = Right(value = "John Doe")\n')),(0,t.yg)("p",null,"Cursors can be composed to navigate more complex JSON structures."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.json._\nimport zio.json.ast.Json\nimport zio.json.ast.JsonCursor\n\nval json1: Either[String, Json] = """{"posts": [{"id": 0, "title": "foo"}]}""".fromJson[Json]\n// json1: Either[String, Json] = Right(\n//   value = Obj(\n//     fields = IndexedSeq(\n//       (\n//         "posts",\n//         Arr(\n//           elements = IndexedSeq(\n//             Obj(\n//               fields = IndexedSeq(\n//                 ("id", Num(value = 0)),\n//                 ("title", Str(value = "foo"))\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\nval json2: Either[String, Json] = """{"userPosts": [{"id": 1, "title": "bar"}]}""".fromJson[Json]\n// json2: Either[String, Json] = Right(\n//   value = Obj(\n//     fields = IndexedSeq(\n//       (\n//         "userPosts",\n//         Arr(\n//           elements = IndexedSeq(\n//             Obj(\n//               fields = IndexedSeq(\n//                 ("id", Num(value = 1)),\n//                 ("title", Str(value = "bar"))\n//               )\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n\nval commonCursor = \n  JsonCursor.isArray >>> \n    JsonCursor.element(0) >>> \n    JsonCursor.isObject >>> \n    JsonCursor.field("title") >>> \n    JsonCursor.isString\n// commonCursor: JsonCursor[Json, Str] = FilterType(\n//   parent = DownField(\n//     parent = FilterType(\n//       parent = FilterType(\n//         parent = DownElement(\n//           parent = FilterType(\n//             parent = FilterType(parent = Identity, jsonType = Arr),\n//             jsonType = Arr\n//           ),\n//           index = 0\n//         ),\n//         jsonType = Obj\n//       ),\n//       jsonType = Obj\n//     ),\n//     name = "title"\n//   ),\n//   jsonType = Str\n// )\n\nval cursor1 = JsonCursor.field("posts")\n// cursor1: JsonCursor[Json.Obj, Json] = DownField(\n//   parent = FilterType(parent = Identity, jsonType = Obj),\n//   name = "posts"\n// )\nval cursor2 = JsonCursor.field("userPosts")\n// cursor2: JsonCursor[Json.Obj, Json] = DownField(\n//   parent = FilterType(parent = Identity, jsonType = Obj),\n//   name = "userPosts"\n// )\n\ndef getTitle(json: Either[String, Json]) =\n  for {\n    ast   <- json\n    posts <- ast.get(cursor1).orElse(ast.get(cursor2))\n    title <- posts.get(commonCursor).map(_.value)\n  } yield title\n\nval title1 = getTitle(json1)\n// title1: Either[String, String] = Right(value = "foo")\nval title2 = getTitle(json2)\n// title2: Either[String, String] = Right(value = "bar")\n')))}g.isMDXComponent=!0}}]);