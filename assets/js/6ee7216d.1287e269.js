"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[69636],{95788:(e,a,n)=>{n.d(a,{Iu:()=>p,yg:()=>m});var r=n(11504);function t(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){t(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,r,t=function(e,a){if(null==e)return{};var n,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],a.indexOf(n)>=0||(t[n]=e[n]);return t}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(t[n]=e[n])}return t}var s=r.createContext({}),c=function(e){var a=r.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},p=function(e){var a=c(e.components);return r.createElement(s.Provider,{value:a},e.children)},y="mdxType",g={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},u=r.forwardRef((function(e,a){var n=e.components,t=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),y=c(n),u=t,m=y["".concat(s,".").concat(u)]||y[u]||g[u]||i;return n?r.createElement(m,o(o({ref:a},p),{},{components:n})):r.createElement(m,o({ref:a},p))}));function m(e,a){var n=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[y]="string"==typeof e?e:t,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},34412:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(45072),t=(n(11504),n(95788));const i={id:"zlayer",title:"ZLayer"},o=void 0,l={unversionedId:"reference/contextual/zlayer",id:"reference/contextual/zlayer",title:"ZLayer",description:"A ZLayer[-RIn, +E, +ROut] describes a layer of an application: every layer in an application requires some services as input RIn and produces some services as the output ROut.",source:"@site/docs/reference/contextual/zlayer.md",sourceDirName:"reference/contextual",slug:"/reference/contextual/zlayer",permalink:"/reference/contextual/zlayer",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/contextual/zlayer.md",tags:[],version:"current",frontMatter:{id:"zlayer",title:"ZLayer"},sidebar:"reference-sidebar",previous:{title:"ZIO Environment Use-cases",permalink:"/reference/contextual/zio-environment-use-cases"},next:{title:"Automatic ZLayer Derivation",permalink:"/reference/contextual/automatic-zlayer-derivation"}},s={},c=[{value:"Creation",id:"creation",level:2},{value:"From a Simple Value or an Existing Service",id:"from-a-simple-value-or-an-existing-service",level:3},{value:"From Non-resourceful Effects",id:"from-non-resourceful-effects",level:3},{value:"From Functions",id:"from-functions",level:3},{value:"Automatic Derivation",id:"automatic-derivation",level:3},{value:"Converting a Layer to a Scoped Value",id:"converting-a-layer-to-a-scoped-value",level:2},{value:"Falling Back to an Alternate Layer",id:"falling-back-to-an-alternate-layer",level:2},{value:"Converting a Layer to a ZIO Application",id:"converting-a-layer-to-a-zio-application",level:2},{value:"Retrying",id:"retrying",level:2},{value:"Layer Projection",id:"layer-projection",level:2},{value:"Tapping",id:"tapping",level:2}],p={toc:c},y="wrapper";function g(e){let{components:a,...n}=e;return(0,t.yg)(y,(0,r.c)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,t.yg)("p",null,"A ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer[-RIn, +E, +ROut]")," describes a layer of an application: every layer in an application requires some services as input ",(0,t.yg)("inlineCode",{parentName:"p"},"RIn")," and produces some services as the output ",(0,t.yg)("inlineCode",{parentName:"p"},"ROut"),"."),(0,t.yg)("p",null,"We can think of a layer as mental model of an asynchronous function from ",(0,t.yg)("inlineCode",{parentName:"p"},"RIn")," to the ",(0,t.yg)("inlineCode",{parentName:"p"},"Either[E, ROut]"),":"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"type ZLayer[-RIn, +E, +ROut] = RIn => async Either[E, ROut]\n")),(0,t.yg)("p",null,"For example, a ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer[Socket & Persistence, Throwable, Database]")," can be thought of as a function that map ",(0,t.yg)("inlineCode",{parentName:"p"},"Socket")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"Persistence")," services into ",(0,t.yg)("inlineCode",{parentName:"p"},"Database")," service:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"(Socket, Persistence) => Database\n")),(0,t.yg)("p",null,"So we can say that the ",(0,t.yg)("inlineCode",{parentName:"p"},"Database")," service has two dependencies: ",(0,t.yg)("inlineCode",{parentName:"p"},"Socket")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"Persistence")," services."),(0,t.yg)("p",null,"In some cases, a ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer")," may not have any dependencies or requirements from the environment. In this case, we can specify ",(0,t.yg)("inlineCode",{parentName:"p"},"Any")," for the ",(0,t.yg)("inlineCode",{parentName:"p"},"RIn")," type parameter. The ",(0,t.yg)("a",{parentName:"p",href:"/reference/contextual/layer"},(0,t.yg)("inlineCode",{parentName:"a"},"Layer"))," type alias provided by ZIO is a convenient way to define a layer without requirements."),(0,t.yg)("p",null,"ZLayers are:"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},(0,t.yg)("strong",{parentName:"p"},"Recipes for Creating Services")," \u2014 They describe how to create services from given dependencies. For example, the ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer[Socket & Database, Throwable, UserRepo]")," is a recipe for building a service that requires ",(0,t.yg)("inlineCode",{parentName:"p"},"Socket")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"Database")," service, and it produces a ",(0,t.yg)("inlineCode",{parentName:"p"},"UserRepo")," service.")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},(0,t.yg)("strong",{parentName:"p"},"An Alternative to Constructors")," \u2014 We can think of ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer")," as a more powerful version of a constructor, it is an alternative way to represent a constructor. Like a constructor, it allows us to build the ",(0,t.yg)("inlineCode",{parentName:"p"},"ROut")," service in terms of its dependencies (",(0,t.yg)("inlineCode",{parentName:"p"},"RIn"),").")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},(0,t.yg)("strong",{parentName:"p"},"Composable")," \u2014 Because of their excellent ",(0,t.yg)("strong",{parentName:"p"},"composition properties"),", layers are the idiomatic way in ZIO to create services that depend on other services. We can define layers that are relying on each other.")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},(0,t.yg)("strong",{parentName:"p"},"Effectful and Resourceful")," \u2014 The construction of ZIO layers can be effectful and resourceful. They can be acquired effectfully and safely released when the services are done being utilized or even in case of failure, interruption, or defects in the application. "),(0,t.yg)("p",{parentName:"li"},"For example, to create a recipe for a ",(0,t.yg)("inlineCode",{parentName:"p"},"Database")," service, we should describe how the ",(0,t.yg)("inlineCode",{parentName:"p"},"Database")," will be initialized using an acquisition action. In addition, it may contain information about how the ",(0,t.yg)("inlineCode",{parentName:"p"},"Database")," releases its connection pools.")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},(0,t.yg)("strong",{parentName:"p"},"Asynchronous")," \u2014 Unlike class constructors which are blocking, ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer")," is fully asynchronous and non-blocking. Note that in non-blocking applications we typically want to avoid creating something that is blocking inside its constructor."),(0,t.yg)("p",{parentName:"li"},"For example, when we are constructing some sort of Kafka streaming service, we might want to connect to the Kafka cluster in the constructor of our service, which takes some time. So it wouldn't be a good idea to block inside the constructor. There are some workarounds for fixing this issue, but they are not as perfect as the ZIO solution which allows for asynchronous, non-blocking constructors.")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},(0,t.yg)("strong",{parentName:"p"},"Parallelism")," \u2014 ZIO layers can be acquired in parallel, unlike class constructors, which do not support parallelism. When we compose multiple layers and then acquire them, the construction of each layer will occur in parallel. This will reduce the initialization time of ZIO applications with a large number of dependencies."),(0,t.yg)("p",{parentName:"li"},"With ZIO ZLayer, our constructor could be asynchronous, but it could also block. We can acquire resources asynchronously or in a blocking fashion, and spend some time doing that, and we don't need to worry about it. That is not an anti-pattern. This is the best practice with ZIO. And that is because ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer")," has the full power of the ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO")," data type, and as a result, we have strictly more power on our constructors with ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer"),".")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},(0,t.yg)("strong",{parentName:"p"},"Resilient")," \u2014 Layer construction can be resilient. So if the acquiring phase fails, we can have a schedule to retry the acquiring stage. This helps us write apps that are error-proof and respond appropriately to failures."))),(0,t.yg)("p",null,"Let's see how we can create a layer:"),(0,t.yg)("h2",{id:"creation"},"Creation"),(0,t.yg)("p",null,"There are four main ways to create a ZLayer:"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("inlineCode",{parentName:"li"},"ZLayer.succeed")," for creating layers from simple values."),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("inlineCode",{parentName:"li"},"ZLayer.scoped")," for creating layers with ",(0,t.yg)("em",{parentName:"li"},"for comprehension")," style from resourceful effects."),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("inlineCode",{parentName:"li"},"ZLayer.apply"),"/",(0,t.yg)("inlineCode",{parentName:"li"},"ZLayer.fromZIO")," for creating layers with ",(0,t.yg)("em",{parentName:"li"},"for comprehension")," style from effectual but not resourceful effects."),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("inlineCode",{parentName:"li"},"ZLayer.fromFunction")," for creating layers that are neither effectual nor resourceful.")),(0,t.yg)("p",null,"Now let's look at each of these methods."),(0,t.yg)("h3",{id:"from-a-simple-value-or-an-existing-service"},"From a Simple Value or an Existing Service"),(0,t.yg)("p",null,"With ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer.succeed")," we can construct a ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer")," from a value. It returns a ",(0,t.yg)("inlineCode",{parentName:"p"},"ULayer[A]")," value, which represents a layer of an application that has a service of type ",(0,t.yg)("inlineCode",{parentName:"p"},"A"),":"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"def succeed[A: Tag](a: A): ULayer[A]\n")),(0,t.yg)("p",null,"Using ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer.succeed")," we can create a layer containing ",(0,t.yg)("em",{parentName:"p"},"simple value")," or a ",(0,t.yg)("em",{parentName:"p"},"service"),":"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},"To create a layer from a ",(0,t.yg)("em",{parentName:"li"},"simple value"),":")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval configLayer: ULayer[AppConfig] = ZLayer.succeed(AppConfig("localhost", 8080))\n')),(0,t.yg)("p",null,"In the example above, we created a ",(0,t.yg)("inlineCode",{parentName:"p"},"configLayer")," that provides us an instance of ",(0,t.yg)("inlineCode",{parentName:"p"},"AppConfig"),"."),(0,t.yg)("ol",{start:2},(0,t.yg)("li",{parentName:"ol"},"To create a layer from an ",(0,t.yg)("em",{parentName:"li"},"existing service"),":")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait EmailService {\n  def send(email: String, content: String): UIO[Unit]\n}\n\nobject EmailService {\n  val layer: ZLayer[Any, Nothing, EmailService] = \n    ZLayer.succeed( \n      new EmailService {\n        override def send(email: String, content: String): UIO[Unit] = ???\n      }\n    )\n}\n")),(0,t.yg)("h3",{id:"from-non-resourceful-effects"},"From Non-resourceful Effects"),(0,t.yg)("p",null,"This is the for-comprehension way of creating a ZIO service using ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer.apply"),":"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait A\ntrait B\ntrait C\ncase class CLive(a: A, b: B) extends C\n\nobject CLive {\n  val layer: ZLayer[A & B, Nothing, C] =\n    ZLayer {\n      for {\n        a <- ZIO.service[A]\n        b <- ZIO.service[B]\n      } yield CLive(a, b)\n    }\n}\n")),(0,t.yg)("h3",{id:"from-functions"},"From Functions"),(0,t.yg)("p",null,"A ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer[R, E, A]")," can be thought of as a function from ",(0,t.yg)("inlineCode",{parentName:"p"},"R")," to ",(0,t.yg)("inlineCode",{parentName:"p"},"A"),". So we can convert functions to the ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer")," using the ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer.fromFunction")," constructor."),(0,t.yg)("p",null,"In the following example, the ",(0,t.yg)("inlineCode",{parentName:"p"},"CLive")," implementation requires two ",(0,t.yg)("inlineCode",{parentName:"p"},"A")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"B")," services, and we can easily convert that case class to a ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer"),":"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait A\ntrait B\ntrait C\ncase class CLive(a: A, b: B) extends C\n\nobject CLive {\n  val layer: ZLayer[A & B, Nothing, C] = \n    ZLayer.fromFunction(CLive.apply _)\n}\n")),(0,t.yg)("p",null,"Below is a complete working example:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class DatabaseConfig()\n\nobject DatabaseConfig {\n  val live = ZLayer.succeed(DatabaseConfig())\n}\n\ncase class Database(databaseConfig: DatabaseConfig)\n\nobject Database {\n  val live: ZLayer[DatabaseConfig, Nothing, Database] =\n    ZLayer.fromFunction(Database.apply _)\n}\n\ncase class Analytics()\n\nobject Analytics {\n  val live: ULayer[Analytics] = ZLayer.succeed(Analytics())\n}\n\ncase class Users(database: Database, analytics: Analytics)\n\nobject Users {\n  val live = ZLayer.fromFunction(Users.apply _)\n}\n\ncase class App(users: Users, analytics: Analytics) {\n  def execute: UIO[Unit] =\n    ZIO.debug(s"This app is made from ${users} and ${analytics}")\n}\n\nobject App {\n  val live = ZLayer.fromFunction(App.apply _)\n}\n\nobject MainApp extends ZIOAppDefault {\n\n  def run =\n    ZIO\n      .serviceWithZIO[App](_.execute)\n      // Cannot use `provide` due to this dotty bug: https://github.com/lampepfl/dotty/issues/12498\n      .provideLayer(\n        (((DatabaseConfig.live >>> Database.live) ++ Analytics.live >>> Users.live) ++ Analytics.live) >>> App.live\n      )\n}\n')),(0,t.yg)("h3",{id:"automatic-derivation"},"Automatic Derivation"),(0,t.yg)("p",null,"Simple layers can be derived using ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer.derive"),". See ",(0,t.yg)("a",{parentName:"p",href:"/reference/contextual/automatic-zlayer-derivation"},"Automatic ZLayer Derivation"),"."),(0,t.yg)("h2",{id:"converting-a-layer-to-a-scoped-value"},"Converting a Layer to a Scoped Value"),(0,t.yg)("p",null,"Every ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer")," can be converted to a scoped ",(0,t.yg)("inlineCode",{parentName:"p"},"ZIO")," by using ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer.build"),":"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ntrait Database {\n  def close: UIO[Unit]\n}\n\nobject Database {\n  def connect: ZIO[Any, Throwable, Database] = ???\n}\n\nval database: ZLayer[Any, Throwable, Database] =\n  ZLayer.scoped {\n    ZIO.acquireRelease {\n      Database.connect.debug("connecting to the database")\n    } { database =>\n      database.close\n    }\n  }\n\nval scopedDatabase: ZIO[Scope, Throwable, ZEnvironment[Database]] =\n  database.build\n')),(0,t.yg)("h2",{id:"falling-back-to-an-alternate-layer"},"Falling Back to an Alternate Layer"),(0,t.yg)("p",null,"If a layer fails, we can provide an alternative layer by using ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer#orElse")," so it will fall back to the second layer:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Database\n\nval postgresDatabaseLayer: ZLayer[Any, Throwable, Database] = ???\nval inmemoryDatabaseLayer: ZLayer[Any, Throwable, Database] = ???\n\nval databaseLayer: ZLayer[Any, Throwable, Database] =\n  postgresDatabaseLayer.orElse(inmemoryDatabaseLayer)\n")),(0,t.yg)("h2",{id:"converting-a-layer-to-a-zio-application"},"Converting a Layer to a ZIO Application"),(0,t.yg)("p",null,"Sometimes our entire application is a ZIO Layer, e.g. an HTTP Server, so by calling the ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer#launch")," we can convert that to a ZIO application. This will build the layer and use it until it is interrupted."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"object MainApp extends ZIOAppDefault {\n\n  val httpServer: ZLayer[Any, Nothing, HttpServer] =\n    ZLayer.make[HttpServer](\n      JsonParserLive.layer,\n      TemplateEngineLive.layer \n    )\n\n  def run = httpServer.launch\n\n}\n")),(0,t.yg)("h2",{id:"retrying"},"Retrying"),(0,t.yg)("p",null,"We can retry constructing a layer in case of failure:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval databaseLayer: ZLayer[Any, Throwable, DatabaseConnection]   = ???\n\nval retriedLayer : ZLayer[Clock, Throwable, DatabaseConnection] = databaseLayer.retry(Schedule.fibonacci(1.second))\n")),(0,t.yg)("h2",{id:"layer-projection"},"Layer Projection"),(0,t.yg)("p",null,"We can project out a part of ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer")," by providing a projection function to the ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer#project")," method:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ncase class Connection(host: String, port: Int)  \ncase class Login(user: String, password: String)\n\ncase class DBConfig(\n  connection: Connection, \n  login: Login\n)\n\nval connection: ZLayer[DBConfig, Nothing, Connection] = \n  ZLayer.service[DBConfig].project(_.connection)\n")),(0,t.yg)("h2",{id:"tapping"},"Tapping"),(0,t.yg)("p",null,"We can perform a specified effect based on the success or failure result of the layer using ",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer#tap"),"/",(0,t.yg)("inlineCode",{parentName:"p"},"ZLayer#tapError"),". This would not change the layer's signature:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval config: ZLayer[Any, Throwable, AppConfig] =\n  ZLayer.fromZIO(\n    ZIO.attempt(???) // reading config from a file\n  )\n\nval res: ZLayer[Any, Throwable, AppConfig] =\n  config\n    .tap(cnf => ZIO.debug(s"layer acquisition succeeded with $cnf"))\n    .tapError(err => ZIO.debug(s"error occurred during reading the config $err"))\n')))}g.isMDXComponent=!0}}]);