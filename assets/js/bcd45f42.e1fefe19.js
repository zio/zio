"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[39693],{15680:(e,n,t)=>{t.d(n,{xA:()=>s,yg:()=>u});var a=t(96540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},s=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},y=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),d=c(t),y=o,u=d["".concat(l,".").concat(y)]||d[y]||m[y]||i;return t?a.createElement(u,r(r({ref:n},s),{},{components:t})):a.createElement(u,r({ref:n},s))}));function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=y;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p[d]="string"==typeof e?e:o,r[1]=p;for(var c=2;c<i;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}y.displayName="MDXCreateElement"},63345:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>c});var a=t(58168),o=(t(96540),t(15680));const i={id:"nonemptyforeach",title:"NonEmptyForEach"},r=void 0,p={unversionedId:"zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach",id:"zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach",title:"NonEmptyForEach",description:"NomEmptyForEach[F] describes a parameterized type F[A] that contains one or more values of type A.",source:"@site/docs/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach.md",sourceDirName:"zio-prelude/functional-abstractions/parameterized-types",slug:"/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach",permalink:"/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach.md",tags:[],version:"current",frontMatter:{id:"nonemptyforeach",title:"NonEmptyForEach"},sidebar:"ecosystem-sidebar",previous:{title:"Invariant",permalink:"/zio-prelude/functional-abstractions/parameterized-types/invariant"},next:{title:"Functional Data Types",permalink:"/zio-prelude/functional-data-types/"}},l={},c=[],s={toc:c},d="wrapper";function m(e){let{components:n,...t}=e;return(0,o.yg)(d,(0,a.A)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"NomEmptyForEach[F]")," describes a parameterized type ",(0,o.yg)("inlineCode",{parentName:"p"},"F[A]")," that contains one or more values of type ",(0,o.yg)("inlineCode",{parentName:"p"},"A"),"."),(0,o.yg)("p",null,"Its signature is:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"trait ForEach[F[+_]] {\n  def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: F[A])(f: A => G[B]): G[F[B]]\n}\n\ntrait NonEmptyForEach[F[+_]] extends ForEach[F] {\n  def forEach1[G[+_]: AssociativeBoth : Covariant, A, B](fa: F[A])(f: A => G[B]): G[F[B]]\n  final def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: F[A])(f: A => G[B]): G[F[B]] =\n    forEach1(fa)(f)\n}\n\ntrait Covariant[F[+_]] {\n  def map[A, B](f: A => B): F[A] => F[B]\n}\n\ntrait AssociativeBoth[F[_]] {\n  def both[A, B](fa: => F[A], b: => F[B]): F[(A, B)]\n}\n\ntrait IdentityBoth[F[_]] extends AssociativeBoth[F] {\n  def any: F[Any]\n}\n")),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyForEach")," functional abstraction builds on the ",(0,o.yg)("inlineCode",{parentName:"p"},"ForEach")," abstraction to describe a type that contains one or more ",(0,o.yg)("inlineCode",{parentName:"p"},"A")," values rather than zero or more ",(0,o.yg)("inlineCode",{parentName:"p"},"A")," values."),(0,o.yg)("p",null,"For example ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyChunk")," has a ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyForEach")," instance defined for it because it always contains at least one value. In contrast ",(0,o.yg)("inlineCode",{parentName:"p"},"Chunk")," only has a ",(0,o.yg)("inlineCode",{parentName:"p"},"ForEach")," instance defined for it because it could be empty."),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyForEach")," generalizes over collection types and types that always contain at least one value, such as ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyChunk"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyList"),", and certain tree data structures."),(0,o.yg)("p",null,"The defining operator of the ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyForEach")," abstraction is ",(0,o.yg)("inlineCode",{parentName:"p"},"forEach1"),", which has the same signature as the ",(0,o.yg)("inlineCode",{parentName:"p"},"forEach")," operator defined by the ",(0,o.yg)("inlineCode",{parentName:"p"},"ForEach")," abstraction except that it doesn't require an identity element with respect to the combining operator for ",(0,o.yg)("inlineCode",{parentName:"p"},"G")," values."),(0,o.yg)("p",null,"Recall that if instances of ",(0,o.yg)("inlineCode",{parentName:"p"},"Covariant")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"AssociativeBoth")," exist for a data type we can define the ",(0,o.yg)("inlineCode",{parentName:"p"},"map")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"zipWith")," operators and if an instance of ",(0,o.yg)("inlineCode",{parentName:"p"},"IdentityBoth")," exists as well we can define the ",(0,o.yg)("inlineCode",{parentName:"p"},"succeed")," operator."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"def map[F[+_], A, B](fa: F[A])(f: A => B)(implicit covariant: Covariant[F]): F[B] =\n  covariant.map(f)(fa)\n\ndef succeed[F[+_], A](a: => A)(implicit covariant: Covariant[F], both: IdentityBoth[F]): F[A] =\n  covariant.map[Any, A](_ => a)(both.any)\n\ndef zipWith[F[+_], A, B, C](\n  fa: F[A],\n  fb: F[B]\n)(f: (A, B) => C)(implicit covariant: Covariant[F], both: AssociativeBoth[F]): F[C] =\n  covariant.map(f.tupled)(both.both(fa, fb))\n")),(0,o.yg)("p",null,"To see why we don't need an identity element for the combining operator when the collection contains at least one value let's compare the implementation of the ",(0,o.yg)("inlineCode",{parentName:"p"},"ForEach")," instance for ",(0,o.yg)("inlineCode",{parentName:"p"},"List")," with the implementation of the ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyForEach")," instance for the ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyList")," data type from ZIO Prelude."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.prelude.NonEmptyList\n\nimplicit val ListForEach: ForEach[List] =\n  new ForEach[List] {\n    def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: List[A])(f: A => G[B]): G[List[B]] =\n      fa.foldRight(succeed[G, List[B]](List.empty)) { (a, gbs) =>\n        zipWith(f(a), gbs)(_ :: _)\n      }\n  }\n// ListForEach: ForEach[List] = repl.MdocSession$MdocApp$$anon$1@8a99a2b\n\nimplicit val NonEmptyListNonEmptyForEach: ForEach[NonEmptyList] =\n  new NonEmptyForEach[NonEmptyList] {\n    def forEach1[G[+_]: AssociativeBoth: Covariant, A, B](fa: NonEmptyList[A])(f: A => G[B]): G[NonEmptyList[B]] =\n      fa.reduceMapRight(a => map(f(a))(NonEmptyList.single))((a, gbs) => zipWith(f(a), gbs)(NonEmptyList.cons))\n  }\n// NonEmptyListNonEmptyForEach: ForEach[NonEmptyList] = repl.MdocSession$MdocApp$$anon$2@71384067\n")),(0,o.yg)("p",null,"In our implementation of ",(0,o.yg)("inlineCode",{parentName:"p"},"ForEach")," for ",(0,o.yg)("inlineCode",{parentName:"p"},"List")," we needed to use the ",(0,o.yg)("inlineCode",{parentName:"p"},"succeed")," operator to handle the case where the collection was empty, because in that case we had to be able to lift an empty collection into the context of ",(0,o.yg)("inlineCode",{parentName:"p"},"G"),". The ",(0,o.yg)("inlineCode",{parentName:"p"},"succeed")," operator requires an ",(0,o.yg)("inlineCode",{parentName:"p"},"IdentityBoth")," instance because we have to be able to construct a neutral value of type ",(0,o.yg)("inlineCode",{parentName:"p"},"G")," that we can then fill with the value we are lifting using the ",(0,o.yg)("inlineCode",{parentName:"p"},"map")," operator."),(0,o.yg)("p",null,"In contrast, in our implementation of ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyForEach")," we never need to call ",(0,o.yg)("inlineCode",{parentName:"p"},"succeed")," because there is always at least one one element in the collection. So we can just apply the function ",(0,o.yg)("inlineCode",{parentName:"p"},"f")," to each element in the collection and then use the ",(0,o.yg)("inlineCode",{parentName:"p"},"zipWith")," operator to combine the results."),(0,o.yg)("p",null,"The fact that the collection can never be empty allows us to relax constraints on other operators as well."),(0,o.yg)("p",null,"For example, we can define an operator called ",(0,o.yg)("inlineCode",{parentName:"p"},"reduceMapLeft")," that is a more powerful version of ",(0,o.yg)("inlineCode",{parentName:"p"},"foldLeft")," that does not require an initial value."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.prelude._\n\ndef reduceMapLeft[F[+_]: ForEach, A, S](as: F[A])(map: A => S)(reduce: (S, S) => S): S =\n  as.foldLeft[Option[S]](None) {\n    case (Some(s), a) => Some(reduce(s, map(a)))\n    case (None, a) => Some(map(a))\n  }.get\n")),(0,o.yg)("p",null,"We know it is safe to call ",(0,o.yg)("inlineCode",{parentName:"p"},"get")," here because the collection is guaranteed to have at least one element."),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"reduceMapLeft")," operator allows us to define additional operators for reducing a collection to a summary value that would not be safe to call on a collection that might be empty."),(0,o.yg)("p",null,"In particular, we can define a more powerful version of the ",(0,o.yg)("inlineCode",{parentName:"p"},"foldMap")," operator defined on the ",(0,o.yg)("inlineCode",{parentName:"p"},"ForEach")," abstraction called ",(0,o.yg)("inlineCode",{parentName:"p"},"reduceMap"),"."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"def reduceMap[F[+_]: ForEach, A, B: Associative](as: F[A])(f: A => B): B =\n  reduceMapLeft(as)(f)(_ <> _)\n")),(0,o.yg)("p",null,"Since we know the collection contains at least one element we do not need an ",(0,o.yg)("inlineCode",{parentName:"p"},"identity")," value with respect to the associative ",(0,o.yg)("inlineCode",{parentName:"p"},"combine")," operator, just like we did not need an ",(0,o.yg)("inlineCode",{parentName:"p"},"any")," value with respect to the ",(0,o.yg)("inlineCode",{parentName:"p"},"both")," operator in ",(0,o.yg)("inlineCode",{parentName:"p"},"forEach1"),"."),(0,o.yg)("p",null,"With this we can easily do something like calculate the sum, product, min, and max of a collection in a single pass."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.prelude.newtypes._\n\ndef stats[F[+_]: ForEach, A](as: F[A])(\n  implicit sum: Associative[Sum[A]],\n  prod: Associative[Prod[A]],\n  min: Associative[Min[A]],\n  max: Associative[Max[A]]\n): (A, A, A, A) =\n  reduceMap(as)(a => (Sum[A](a), Prod[A](a), Min[A](a), Max[A](a)))\n")),(0,o.yg)("p",null,"This is a very nice way to describe reducing a collection to a summary value and gives us additional flexibility to use ways of combining that are associative but do not have an identity element relative to the ",(0,o.yg)("inlineCode",{parentName:"p"},"foldMap")," operator."),(0,o.yg)("p",null,"As we can see, the ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyForEach")," functional abstraction builds on the ",(0,o.yg)("inlineCode",{parentName:"p"},"ForEach")," functional abstraction to describe parameterized types that contain one or more values of the type they are parameterized on. This lets us define a wide variety of operators, even more than the ones we could define for the ",(0,o.yg)("inlineCode",{parentName:"p"},"ForEach")," abstraction."),(0,o.yg)("p",null,"So if you are defining your own data type like a collection and it will never be empty you should definitely define a ",(0,o.yg)("inlineCode",{parentName:"p"},"NonEmptyForEach")," instance for it so you can take advantage of all the nice operators that are defined in terms of it."))}m.isMDXComponent=!0}}]);