"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[4131],{15680:(e,t,n)=>{n.d(t,{xA:()=>l,yg:()=>g});var a=n(96540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),d=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=d(e.components);return a.createElement(c.Provider,{value:t},e.children)},s="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),s=d(n),u=o,g=s["".concat(c,".").concat(u)]||s[u]||m[u]||r;return n?a.createElement(g,i(i({ref:t},l),{},{components:n})):a.createElement(g,i({ref:t},l))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var p={};for(var c in t)hasOwnProperty.call(t,c)&&(p[c]=t[c]);p.originalType=e,p[s]="string"==typeof e?e:o,i[1]=p;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},61421:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>p,toc:()=>d});var a=n(58168),o=(n(96540),n(15680));const r={id:"http-codec",title:"HttpCodec"},i=void 0,p={unversionedId:"zio-http/reference/http-codec",id:"zio-http/reference/http-codec",title:"HttpCodec",description:"In ZIO HTTP when we work with HTTP requests and responses, we are not dealing with raw bytes but with structured data. This structured data is represented by the Request and Response types. But under the hood, these types are serialized and deserialized to and from raw bytes. This process is handled by HTTP Codecs. We can think of HttpCodec as a pair of functions both for encoding and decoding requests and responses:",source:"@site/docs/zio-http/reference/http-codec.md",sourceDirName:"zio-http/reference",slug:"/zio-http/reference/http-codec",permalink:"/zio-http/reference/http-codec",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/http-codec.md",tags:[],version:"current",frontMatter:{id:"http-codec",title:"HttpCodec"},sidebar:"ecosystem-sidebar",previous:{title:"Endpoint",permalink:"/zio-http/reference/endpoint"},next:{title:"ProtocolStack",permalink:"/zio-http/reference/aop/protocol-stack"}},c={},d=[{value:"Built-in Codecs",id:"built-in-codecs",level:2},{value:"ContentCodec",id:"contentcodec",level:3},{value:"HeaderCodec",id:"headercodec",level:3},{value:"MethodCodec",id:"methodcodec",level:3},{value:"QueryCodec",id:"querycodec",level:3},{value:"StatusCodec",id:"statuscodec",level:3},{value:"Operations",id:"operations",level:2},{value:"Combining Codecs Sequentially",id:"combining-codecs-sequentially",level:3},{value:"Combining Codecs Alternatively",id:"combining-codecs-alternatively",level:3},{value:"Optional Codecs",id:"optional-codecs",level:3},{value:"Expecting a Specific Value",id:"expecting-a-specific-value",level:3},{value:"Transforming Codecs",id:"transforming-codecs",level:3},{value:"Annotating Codecs",id:"annotating-codecs",level:3},{value:"Usage",id:"usage",level:2},{value:"Imperative Programming",id:"imperative-programming",level:3},{value:"Declarative Programming",id:"declarative-programming",level:3}],l={toc:d},s="wrapper";function m(e){let{components:t,...n}=e;return(0,o.yg)(s,(0,a.A)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"In ZIO HTTP when we work with HTTP requests and responses, we are not dealing with raw bytes but with structured data. This structured data is represented by the ",(0,o.yg)("inlineCode",{parentName:"p"},"Request")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"Response")," types. But under the hood, these types are serialized and deserialized to and from raw bytes. This process is handled by HTTP Codecs. We can think of ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec")," as a pair of functions both for encoding and decoding requests and responses:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait HttpCodec[-AtomTypes, Value] {\n  final def decodeRequest(request: Request)(implicit trace: Trace): Task[Value]\n  final def decodeResponse(response: Response)(implicit trace: Trace): Task[Value]\n\n  final def encodeRequest(value: Value): Request\n  final def encodeResponse[Z](value: Value, outputTypes: Chunk[MediaTypeWithQFactor]): Response\n}\n")),(0,o.yg)("p",null,"HTTP messages consist of various parts, such as headers, body, and status codes. ZIO HTTP needs to know how to encode and decode each part of the HTTP message. So it has a set of built-in codecs that each one is responsible for a specific part of the HTTP message."),(0,o.yg)("h2",{id:"built-in-codecs"},"Built-in Codecs"),(0,o.yg)("p",null,"ZIO HTTP provides a set of built-in codecs for common HTTP message parts. Here is a list of built-in codecs:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"type ContentCodec[A] = HttpCodec[HttpCodecType.Content, A]\ntype HeaderCodec[A]  = HttpCodec[HttpCodecType.Header, A]\ntype MethodCodec[A]  = HttpCodec[HttpCodecType.Method, A]\ntype QueryCodec[A]   = HttpCodec[HttpCodecType.Query, A]\ntype StatusCodec[A]  = HttpCodec[HttpCodecType.Status, A]\n")),(0,o.yg)("p",null,"These codecs are nothing different from the ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec")," type we saw earlier. They are just specialized versions of ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec")," for specific parts of the HTTP message."),(0,o.yg)("h3",{id:"contentcodec"},"ContentCodec"),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"ContentCodec[A]")," is a codec for the body of the HTTP message with type ",(0,o.yg)("inlineCode",{parentName:"p"},"A"),". To create a ",(0,o.yg)("inlineCode",{parentName:"p"},"ContentCodec")," we can use the ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.content")," method. If we want to have codec for a stream of content we can use ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.contentStream")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.binaryStream"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\nimport zio.http.codec._\n\nval stringCodec           : ContentCodec[String] = HttpCodec.content[String]\nval contentTypedCodec     : ContentCodec[String] = HttpCodec.content[String](MediaType.text.plain)\nval namedContentCodec     : ContentCodec[Int]    = HttpCodec.content[Int](name = "age")\nval namedContentTypedCodec: ContentCodec[Int]    = HttpCodec.content[Int](name = "age", MediaType.text.plain)\n')),(0,o.yg)("p",null,"HttpCodecs are composable, we can use ",(0,o.yg)("inlineCode",{parentName:"p"},"++")," to combine two codecs:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'val nameAndAgeCodec: ContentCodec[(String, Int)] = HttpCodec.content[String]("name") ++ HttpCodec.content[Int]("age")\n')),(0,o.yg)("p",null,"We can also ",(0,o.yg)("inlineCode",{parentName:"p"},"transform")," a codec to another codec. In the following example, we transform the previous codec, which is a codec for a tuple of ",(0,o.yg)("inlineCode",{parentName:"p"},"(String, Int)"),", to a codec for a case class ",(0,o.yg)("inlineCode",{parentName:"p"},"User"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"val userContentCodec: ContentCodec[User] =\n  nameAndAgeCodec.transform[User] {\n    case (name: String, age: Int) => User(name, age)\n  }(user => (user.name, user.age))\n")),(0,o.yg)("p",null,"More details about ",(0,o.yg)("a",{parentName:"p",href:"#transforming-codecs"},"transforming codecs")," will be discussed later in this page."),(0,o.yg)("p",null,"Another simple way to create a ",(0,o.yg)("inlineCode",{parentName:"p"},"ContentCodec")," for a case class is to use ZIO Schema. By using ZIO Schema we can derive a schema for a case class and then use it to create a ",(0,o.yg)("inlineCode",{parentName:"p"},"ContentCodec"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.http.codec._\nimport zio.schema._\n\ncase class User(name: String, age: Int)\n\nobject User {\n  implicit val schema = DeriveSchema.gen[User]\n}\n\nval userCodec: ContentCodec[User] = HttpCodec.content[User]\n")),(0,o.yg)("p",null,"To create a codec for a stream of content we can use ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.contentStream"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\nimport zio.http.codec._\n\nval temperature: ContentCodec[ZStream[Any, Nothing, Double]] = \n  HttpCodec.contentStream[Double](name = "temperature")\n')),(0,o.yg)("p",null,"To create a codec for a binary stream we can use ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.binaryStream"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\nimport zio.http.codec._\n\nval binaryStream: ContentCodec[ZStream[Any, Nothing, Byte]] = \n  HttpCodec.binaryStream(name = "large-file")\n')),(0,o.yg)("h3",{id:"headercodec"},"HeaderCodec"),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"HeaderCodec[A]")," is a codec for the headers of the HTTP message with type ",(0,o.yg)("inlineCode",{parentName:"p"},"A"),". To create a ",(0,o.yg)("inlineCode",{parentName:"p"},"HeaderCodec")," we can use the ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.header")," constructor:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.http._\nimport zio.http.codec._\n\nval acceptHeaderCodec: HeaderCodec[Header.Accept] = HttpCodec.header(Header.Accept)\n")),(0,o.yg)("p",null,"Or we can use the ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.name"),", which takes the name of the header as a parameter, which is useful for custom headers:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\nimport zio.http.codec._\nimport java.util.UUID\n\nval acceptHeaderCodec: HeaderCodec[UUID] = HttpCodec.name[UUID]("X-Correlation-ID")\n')),(0,o.yg)("p",null,"We can also create a codec that encode/decode multiple headers by combining them with ",(0,o.yg)("inlineCode",{parentName:"p"},"++"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.http._\nimport zio.http.codec._\n\nval acceptHeaderCodec     : HeaderCodec[Header.Accept]      = HttpCodec.header(Header.Accept)\nval contentTypeHeaderCodec: HeaderCodec[Header.ContentType] = HttpCodec.header(Header.ContentType)\n\nval acceptAndContentTypeCodec: HeaderCodec[(Header.Accept, Header.ContentType)] = \n  acceptHeaderCodec ++ contentTypeHeaderCodec\n")),(0,o.yg)("h3",{id:"methodcodec"},"MethodCodec"),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"MethodCodec[A]")," is a codec for the method of the HTTP message with type ",(0,o.yg)("inlineCode",{parentName:"p"},"A"),". We can use ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.method")," which takes a ",(0,o.yg)("inlineCode",{parentName:"p"},"Method")," as a parameter to create a ",(0,o.yg)("inlineCode",{parentName:"p"},"MethodCodec"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.http._\nimport zio.http.codec._\n\nval getMethodCodec: HttpCodec[HttpCodecType.Method, Unit] = HttpCodec.method(Method.GET)\n")),(0,o.yg)("p",null,"There are also predefined codecs for all the HTTP methods, e.g. ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.connect"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.delete"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.get"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.head"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.options"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.patch"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.post"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.put"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.trace"),"."),(0,o.yg)("h3",{id:"querycodec"},"QueryCodec"),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"QueryCodec[A]")," is a codec for the query parameters of the HTTP message with type ",(0,o.yg)("inlineCode",{parentName:"p"},"A"),". To be able to encode and decode query parameters, ZIO HTTP provides a wide range of query codecs. If we are dealing with a single query parameter we can use ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.query"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.queryBool"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.queryInt"),", and ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.queryTo"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\nimport zio.http.codec._\nimport java.util.UUID\n\nval nameQueryCodec  : QueryCodec[String]         = HttpCodec.query("name")       // e.g. ?name=John\nval ageQueryCodec   : QueryCodec[Int]            = HttpCodec.queryInt("age")     // e.g. ?age=30 \nval activeQueryCodec: QueryCodec[Boolean]        = HttpCodec.queryBool("active") // e.g. ?active=true\n\n// e.g. ?uuid=43abea9e-0b0e-11ef-8d07-e755ec5cd767\nval uuidQueryCodec  : QueryCodec[UUID]           = HttpCodec.queryTo[UUID]("uuid")\n')),(0,o.yg)("p",null,"We can combine multiple query codecs with ",(0,o.yg)("inlineCode",{parentName:"p"},"++"),":"),(0,o.yg)("p",null,"If we have multiple query parameters we can use ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.queryAll"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.queryAllBool"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.queryAllInt"),", and ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.queryAllTo"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.codec._\nimport java.util.UUID\n\nval queryAllCodec    : QueryCodec[Chunk[String]] = HttpCodec.queryAll("q")      // e.g. ?q=one&q=two&q=three\nval queryAllIntCodec : QueryCodec[Chunk[Int]]    = HttpCodec.queryAllInt("id")  // e.g. ?ids=1&ids=2&ids=3\n\n// e.g. ?uuid=43abea9e-0b0e-11ef-8d07-e755ec5cd767&uuid=43abea9e-0b0e-11ef-8d07-e755ec5cd768\nval queryAllUUIDCodec: QueryCodec[Chunk[UUID]]   = HttpCodec.queryAllTo[UUID]("uuid")\n')),(0,o.yg)("h3",{id:"statuscodec"},"StatusCodec"),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"StatusCodec[A]")," is a codec for the status code of the HTTP message with type ",(0,o.yg)("inlineCode",{parentName:"p"},"A"),". To create a ",(0,o.yg)("inlineCode",{parentName:"p"},"StatusCodec")," we can use the ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.status")," method:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.http._\nimport zio.http.codec._\n\nval okStatusCodec: StatusCodec[Unit] = HttpCodec.status(Status.Ok)\n")),(0,o.yg)("p",null,"Also, there are predefined codecs for various status codes, e.g. ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.Continue"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.Accepted"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec.NotFound"),", etc."),(0,o.yg)("h2",{id:"operations"},"Operations"),(0,o.yg)("p",null,"The primary advantage of ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec")," is its composability, which means we can combine multiple codecs to create new ones. This is useful when we want to encode and decode multiple parts of the HTTP message, such as headers, body, and status codes; so we start by creating codecs for each part and then combine them to create a codec for the whole HTTP message."),(0,o.yg)("h3",{id:"combining-codecs-sequentially"},"Combining Codecs Sequentially"),(0,o.yg)("p",null,"By combining two codecs using the ",(0,o.yg)("inlineCode",{parentName:"p"},"++")," operator, we can create a new codec that sequentially encodes/decodes from left to right:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http.codec._\n\n// e.g. ?name=John&age=30\nval queryCodec: QueryCodec[(String, Int)]  = HttpCodec.query("name") ++ HttpCodec.queryInt("age")\n')),(0,o.yg)("h3",{id:"combining-codecs-alternatively"},"Combining Codecs Alternatively"),(0,o.yg)("p",null,"There is also a ",(0,o.yg)("inlineCode",{parentName:"p"},"|")," operator that allows us to create a codec that can decode either of the two codecs. Assume we have two query codecs, one for ",(0,o.yg)("inlineCode",{parentName:"p"},"q")," and the other for ",(0,o.yg)("inlineCode",{parentName:"p"},"query"),". We can create a new codec that tries to decode ",(0,o.yg)("inlineCode",{parentName:"p"},"q")," first and if it fails, it tries to decode ",(0,o.yg)("inlineCode",{parentName:"p"},"query"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http.codec._\n\nval eitherQueryCodec: QueryCodec[String] = HttpCodec.query("q") | HttpCodec.query("query")\n')),(0,o.yg)("p",null,"Assume we have a request"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\n\nval request: Request = Request(url = URL.root.copy(queryParams = QueryParams("query" -> "foo")))\n')),(0,o.yg)("p",null,"We can decode the query parameter using the ",(0,o.yg)("inlineCode",{parentName:"p"},"decodeRequest")," method:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval result: Task[String] = eitherQueryCodec.decodeRequest(request)\n")),(0,o.yg)("h3",{id:"optional-codecs"},"Optional Codecs"),(0,o.yg)("p",null,"Sometimes we want to decode a part of the HTTP message only if it exists. We can use the ",(0,o.yg)("inlineCode",{parentName:"p"},"optional")," method to transform a codec to an optional codec:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.codec._\n\nval optionalQueryCodec: QueryCodec[Option[String]] = HttpCodec.query("q").optional\n\nval request = Request(url = URL.root.copy(queryParams = QueryParams("query" -> "foo")))\nval result: Task[Option[String]] = optionalQueryCodec.decodeRequest(request)\n')),(0,o.yg)("h3",{id:"expecting-a-specific-value"},"Expecting a Specific Value"),(0,o.yg)("p",null,"To write a codec that only accepts a specific value, we can use the ",(0,o.yg)("inlineCode",{parentName:"p"},"expect")," method:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.codec._\n\nval expectHeaderValueCodec: HeaderCodec[Unit] = HttpCodec.name[String]("X-Custom-Header").expect("specific-value")\nval request: Request = Request(headers = Headers("X-Custom-Header" -> "specific-value"))\nval response: Task[Unit] = expectHeaderValueCodec.decodeRequest(request)\n')),(0,o.yg)("p",null,"The above codec will only accept the request if the value of the header ",(0,o.yg)("inlineCode",{parentName:"p"},"X-Custom-Header")," is ",(0,o.yg)("inlineCode",{parentName:"p"},"specific-value"),"."),(0,o.yg)("h3",{id:"transforming-codecs"},"Transforming Codecs"),(0,o.yg)("p",null,"HttpCodecs are invariant in their ",(0,o.yg)("inlineCode",{parentName:"p"},"Value")," type parameter, so to transform a codec of type ",(0,o.yg)("inlineCode",{parentName:"p"},"A")," to a codec of type ",(0,o.yg)("inlineCode",{parentName:"p"},"B"),", we need two functions, one for mapping ",(0,o.yg)("inlineCode",{parentName:"p"},"A")," to ",(0,o.yg)("inlineCode",{parentName:"p"},"B")," and the other for mapping ",(0,o.yg)("inlineCode",{parentName:"p"},"B")," to ",(0,o.yg)("inlineCode",{parentName:"p"},"A"),"."),(0,o.yg)("p",null,"For example, assume we have a codec of type ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec[HttpCodecType.Content, (String, Int)]"),". If we want to transform it to a codec of type ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec[HttpCodecType.Content, User]"),", we require two functions:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"A function that maps a value of type ",(0,o.yg)("inlineCode",{parentName:"li"},"(String, Int)")," to a value of type ",(0,o.yg)("inlineCode",{parentName:"li"},"User"),"."),(0,o.yg)("li",{parentName:"ul"},"A function that maps a value of type ",(0,o.yg)("inlineCode",{parentName:"li"},"User")," to a value of type ",(0,o.yg)("inlineCode",{parentName:"li"},"(String, Int)"),".")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http.codec._\n\ncase class User(name: String, age: Int)\n\nval nameAndAgeCodec: ContentCodec[(String, Int)] = HttpCodec.content[String]("name") ++ HttpCodec.content[Int]("age")\n\nval userContentCodec: ContentCodec[User] =\n  nameAndAgeCodec.transform[User] {\n    case (name: String, age: Int) => User(name, age)\n  }(user => (user.name, user.age))\n')),(0,o.yg)("h3",{id:"annotating-codecs"},"Annotating Codecs"),(0,o.yg)("p",null,"HttpCodec has several methods for annotating codecs:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"annotate"),": To attach a metadata to the codec."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"named"),": To attach a name to the codec."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"examples"),": To attach examples to the codec."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"??"),": To attach a documentation to the codec.")),(0,o.yg)("p",null,"This additional information can be used for ",(0,o.yg)("a",{parentName:"p",href:"/zio-http/reference/endpoint#openapi-documentation"},"generating API documentation, e.g. OpenAPI"),"."),(0,o.yg)("h2",{id:"usage"},"Usage"),(0,o.yg)("p",null,"Having a codec for HTTP messages is useful when we want to program declaratively instead of imperative programming."),(0,o.yg)("p",null,"Let's compare these two programming styles in ZIO HTTP and see how we can benefit from using ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec")," for writing declarative APIs."),(0,o.yg)("h3",{id:"imperative-programming"},"Imperative Programming"),(0,o.yg)("p",null,"When writing an HTTP API, we have to think about a function that takes a ",(0,o.yg)("inlineCode",{parentName:"p"},"Request")," and returns a ",(0,o.yg)("inlineCode",{parentName:"p"},"Response"),", i.e. the handler function. In imperative programming, we have to deal with the low-level details of how to extract the required information from the ",(0,o.yg)("inlineCode",{parentName:"p"},"Request"),", validate it, and finally construct the proper ",(0,o.yg)("inlineCode",{parentName:"p"},"Response"),". In such a way, we have to write all these logics step by step."),(0,o.yg)("p",null,"In the following example, we are going to write an API for a bookstore. The API has a single endpoint ",(0,o.yg)("inlineCode",{parentName:"p"},"/books?id=<book-id>")," that returns the book with the given ",(0,o.yg)("inlineCode",{parentName:"p"},"id")," as a query parameter. If the book is found, it returns a ",(0,o.yg)("inlineCode",{parentName:"p"},"200 OK")," response with the book as the body. If the book is not found, it returns a ",(0,o.yg)("inlineCode",{parentName:"p"},"404 Not Found")," response with an error message:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/style/ImperativeProgrammingExample.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/style/ImperativeProgrammingExample.scala"'},'package example.endpoint.style\n\nimport zio._\n\nimport zio.schema.codec.JsonCodec.schemaBasedBinaryCodec\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\n\nobject ImperativeProgrammingExample extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen[Book]\n  }\n\n  object BookRepo {\n\n    case class NotFoundError(message: String)\n\n    def find(id: String): ZIO[Any, NotFoundError, Book] =\n      if (id == "1")\n        ZIO.succeed(Book("Zionomicon", List("John A. De Goes", "Adam Fraser")))\n      else\n        ZIO.fail(NotFoundError("The requested book was not found!"))\n  }\n\n  val route: Route[Any, Response] =\n    Method.GET / "books" -> handler { (req: Request) =>\n      for {\n        id    <- ZIO.fromOption(req.queryParam("id")).orElseFail(Response.badRequest("Missing query parameter id"))\n        books <- BookRepo.find(id).mapError(err => Response.notFound(err.message))\n      } yield Response.ok.copy(body = Body.from(books))\n    }\n\n  def run = Server.serve(route.toRoutes).provide(Server.default)\n}\n')),(0,o.yg)("p",null,"The type of handler in the above example is ",(0,o.yg)("inlineCode",{parentName:"p"},"Handler[Any, Response, Request, Response]"),", which means we have to write a function that takes a ",(0,o.yg)("inlineCode",{parentName:"p"},"Request")," and returns a ",(0,o.yg)("inlineCode",{parentName:"p"},"Response")," and in case of failure, it will return a failure value of type ",(0,o.yg)("inlineCode",{parentName:"p"},"Response"),". In the handler function, we have to manually extract the ",(0,o.yg)("inlineCode",{parentName:"p"},"id")," from the query parameters, then do the business logic to find the book with the given ",(0,o.yg)("inlineCode",{parentName:"p"},"id"),", and finally construct the proper ",(0,o.yg)("inlineCode",{parentName:"p"},"Response"),". "),(0,o.yg)("h3",{id:"declarative-programming"},"Declarative Programming"),(0,o.yg)("p",null,"In declarative programming, we can separate the two concerns from each other: the definition of the API and its implementation. By having the codecs for the HTTP messages, we can define how the ",(0,o.yg)("inlineCode",{parentName:"p"},"Request")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"Response")," should look like and based on our requirements how they should be encoded and decoded. ZIO Http has the ",(0,o.yg)("inlineCode",{parentName:"p"},"Endpoint")," API that makes it easy to define the API in a declarative way by utilizing ",(0,o.yg)("inlineCode",{parentName:"p"},"HttpCodec"),". After defining the API using ",(0,o.yg)("inlineCode",{parentName:"p"},"Endpoint"),", we can implement it using the ",(0,o.yg)("inlineCode",{parentName:"p"},"Endpoint#implement")," method."),(0,o.yg)("p",null,"In the following example, we are going to rewrite the previous example using the ",(0,o.yg)("inlineCode",{parentName:"p"},"Endpoint")," API:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/style/DeclarativeProgrammingExample.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/style/DeclarativeProgrammingExample.scala"'},'package example.endpoint.style\n\nimport zio._\n\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\nimport zio.http.codec.QueryCodec\nimport zio.http.endpoint.Endpoint\nimport zio.http.endpoint.EndpointMiddleware.None\n\nobject DeclarativeProgrammingExample extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n  case class NotFoundError(message: String)\n\n  object NotFoundError {\n    implicit val schema: Schema[NotFoundError] = DeriveSchema.gen\n  }\n\n  object BookRepo {\n    def find(id: String): ZIO[Any, NotFoundError, Book] = {\n      if (id == "1")\n        ZIO.succeed(Book("Zionomicon", List("John A. De Goes", "Adam Fraser")))\n      else\n        ZIO.fail(NotFoundError("The requested book was not found!"))\n    }\n  }\n\n  val endpoint: Endpoint[Unit, String, NotFoundError, Book, None] =\n    Endpoint(RoutePattern.GET / "books")\n      .query(QueryCodec.query("id"))\n      .out[Book]\n      .outError[NotFoundError](Status.NotFound)\n\n  val getBookHandler: Handler[Any, NotFoundError, String, Book] =\n    handler(BookRepo.find(_))\n\n  val routes = endpoint.implement(getBookHandler).toRoutes @@ Middleware.debug\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n')),(0,o.yg)("p",null,"As we will see, we have declared a clear specification of the API and separately implemented it. The very interesting point about the implementation section is that it is not concerned with the low-level details of how to extract the required information from the ",(0,o.yg)("inlineCode",{parentName:"p"},"Request")," and how to construct the proper ",(0,o.yg)("inlineCode",{parentName:"p"},"Response"),". The ",(0,o.yg)("inlineCode",{parentName:"p"},"implement")," method takes a handler of type ",(0,o.yg)("inlineCode",{parentName:"p"},"Handler[Any, NotFoundError, String, Book]"),", which means we have to write a handler function that takes a ",(0,o.yg)("inlineCode",{parentName:"p"},"String")," and returns a ",(0,o.yg)("inlineCode",{parentName:"p"},"Book")," and in case of failure, it will return a ",(0,o.yg)("inlineCode",{parentName:"p"},"NotFoundError")," error. No manual decoding of ",(0,o.yg)("inlineCode",{parentName:"p"},"Request")," and no manual encoding of ",(0,o.yg)("inlineCode",{parentName:"p"},"Response")," is required. So in the handler function, we only have to focus on the business logic."))}m.isMDXComponent=!0}}]);